---
layout: post
title: "Docker 簡單介紹"
date: 2016-11-25 16:28:35 +0800
comments: true
categories: server
---

docker 讓應用程式佈署在軟體容器下的工作可以自動化進行，藉此在Linux作業系統上，提供一個額外的軟體抽象層，以及作業系統層虛擬化的自動管理機制。

<!-- more -->

Docker 的優點

* 秒級實作
* 對系統資源的使用率很高，一台主機可以同時執行數千個 Docker 容器
* 更快速的交付和部署
	* 使用一個標準的映像檔來建立一套開發容器，開發完成之後，維運人員可以直接使用這個容器來部署程式碼。
* 更有效率的虛擬化
	* 不需額外的虛擬化支援，它是核心層級的虛擬化
* 更輕鬆的遷移和擴展
	* Docker 容器幾乎可以在任意的平台上執行
* 更簡單的管理

Docker vs VM

* Docker 僅載入所需要的函式庫與執行檔，而不像VM需要安裝大容量的作業系統
* VM是用硬體端的hypervisor技術來同時執行多個虛擬主機，一般可預見需要大量的運行資源。Docker則是用軟體端的作業系統來實現虛擬分割的技術，由於僅載入核心的函式庫

```ruby
#查看版本
docker --version
docker-compose --version
docker-machine --version

#從 hub 取得所需要的 images :後面為版本號，若沒加則會拉最新的
docker pull ubuntu:12.04 

#執行 docker ，若本地沒有 image，就會自動去 Docker Hub pull 下來
docker run -t -i ubuntu:12.04 bash
#-t 在容器中分配一個虛擬終端（pseudo-tty）並綁定到容器的標準輸入上
#-i 建立與容器標準輸入（STDIN）的互動連結，讓容器的標準輸入保持打開
#執行後啟動 bash

docker run -d -p 80:80 --name webserver nginx
# -p 80:80 (主機 port, container port)
#--name webserver
# -d daemon 模式，docker 只要一執行完它的程式就會終止了

docker run -it -v ~/Downloads: ubuntu:12.04 bash
#建立容器並啟動，且掛載本地目錄(local 在前，container 在後)

#啟動 container
docker start <imageID>|<imageName>

#重新啟動
docker restart <imageID>|<imageName>

#停止 container 
docker stop <imageID>|<imageName>

#搜尋官方的 Image
docker search 

#目前有哪些 docker 正在跑
docker ps

#查看所有的 container 包含停止的
docker ps -a 

#查看目前有哪些 images
docker images

#移除 image
docker rmi <imageID>|<imageName>
docker rmi nginx
docker rmi nginx -f

#移除 container (要先 stop 才可以移除)
docker rm <containerID>
#一次移除全部
docker rm $(docker ps -a -q)

#看 container log
docker logs -f <imageID>|<imageName>

#連到 container 最後執行
#當多個窗口同時 attach 到同一個容器的時候，所有窗口都會同步顯示。當某個窗口因命令阻塞時,其他窗口也無法執行操作了
docker attach <imageID>|<imageName>

#進去 container 執行 bash
docker exec -it <imageID>|<imageName> bash

#commit
docker commit -m 'message' -a 'author'

#建立 tag
docker tag <imageID> <tag>

#上傳 images
docker push
```

![](https://blog.fntsr.tw/wp-content/uploads/2014/12/Docker-Command-Diagram.png)


##Dockerfile

[Dockerfile 指令](https://philipzheng.gitbooks.io/docker_practice/content/dockerfile/instructions.html)

```ruby
#一般會建議放置 Dockerfile 的目錄為空目錄。也可以透過 .dockerignore 檔案（每一行新增一條排除模式：exclusion patterns）來讓 Docker 忽略路徑下的目錄和檔案。
docker build -t <tagName> .
  
#這樣也可以，只是不指定名稱
docker build .
```

###FROM
一定要有，只能有一個 FROM，基於某個已存在的 image 進行二次開發。

```ruby
FROM ubuntu:14.04.2
```

###MAINTAINER
指定維護者訊息。

```ruby
MAINTAINER <name | email>
```

###RUN
對映像檔執行相對應的命令。每運行一條 RUN 指令，映像檔就會新增一層，主要用來安裝 packages、設定系統環境等

```ruby
RUN <command> 或 RUN ["executable", "param1", "param2"]
```
前者將在 shell 終端中運行命令，即 /bin/sh -c；後者則使用 exec 執行。指定使用其它終端可以透過第二種方式實作，例如 RUN ["/bin/bash", "-c", "echo hello"]。

每條 RUN 指令將在當前映像檔基底上執行指定命令，並產生新的映像檔。當命令較長時可以使用 \ 來換行。


###EXPOSE
設定 Docker 伺服器容器對外的埠號，供外界使用。在啟動容器時需要透過 -P，Docker 會自動分配一個埠號轉發到指定的埠號（當然也可以自己給，例如 -p 1055:80)

```ruby
EXPOSE 80
```

###ADD
該命令將複製指定的 <src> 到容器中的 <dest>。 其中 <src> 可以是 Dockerfile 所在目錄的相對路徑；也可以是一個 URL；還可以是一個 tar 檔案（其複製後會自動解壓縮）。

```ruby
ADD <src> <dest>
ADD text.conf /etc/apache2/test.conf
```

###USER
切換使用者身份，Docker 預設使用者是 root，但若不需要，建議切換使用者身份，畢竟 root 權限太大了，使用上有安全的風險。

```ruby
USER Leon
```

###VOLUME
建立一個可以從本地端或其他容器掛載的掛載點，一般用來存放資料庫和需要保存的資料等。

```ruby
VOLUME ["/data"]
```

###WORKDIR
用來切換工作目錄，Docker 預設工作目錄是在根目錄，只有 RUN 能執行 cd 指令切換目錄，只作用在當下的 RUN，也就是說每一個 RUN 都是獨立進行的。如果想讓其他指令在指定的目錄下執行，就得靠 WORKDIR。WORKDIR 的變更影響是持續的，不用每個指令前都使用一次 WORKDIR 

```ruby
WORKDIR /a
WORKDIR b
WORKDIR c
RUN pwd

#則最終路徑為 /a/b/c
```

###ENV
指定一個環境變數，會被後續 RUN 指令使用，並在容器運行時保持。

```ruby
ENV <key> <value>

ENV PG_MAJOR 9.3
ENV PG_VERSION 9.3.4
RUN curl -SL http://example.com/postgres-$PG_VERSION.tar.xz | tar -xJC /usr/src/postgress && …
ENV PATH /usr/local/postgres-$PG_MAJOR/bin:$PATH
```

###COPY
能將本機端的檔案或目錄，複製到 image 內。

```ruby
#複製本地端的 <src>（為 Dockerfile 所在目錄的相對路徑）到容器中的 <dest>。
COPY <src> <dest>
COPY test.rb ./
```

###ENTRYPOINT
指定 Docker image 運行成 instance (也就是 Docker container) 時，要執行的指令或檔案。在這個範本中，test.rb 就是要執行的檔案。

```ruby
ENTRYPOINT ["./test.rb"] 
```

###CMD
指定啟動容器時執行的命令，每個 Dockerfile 只能有一條 CMD 命令。如果指定了多條命令，只有最後一條會被執行。
如果使用者啟動容器時候指定了運行的命令，則會覆蓋掉 CMD 指定的命令。

```ruby
#使用 exec 執行，推薦使用
CMD ["executable","param1","param2"] 
#在 /bin/sh 中執行，使用在給需要互動的指令
#提供給 ENTRYPOINT 的預設參數
CMD command param1 param2 CMD ["param1","param2"]
```

###範例
```ruby
FROM ubuntu:latest

RUN apt-get update -qq && apt-get install -y aptitude git imagemagick curl vim bash-completion htop nodejs mysql-client libmysqlclient-dev

RUN gpg --keyserver hkp://keys.gnupg.net --recv-keys 409B6B1796C275462A1703113804BB82D39DC0E3
RUN \curl -sSL https://get.rvm.io | bash -s stable
RUN /bin/bash -l -c "rvm install 2.1.5"
RUN /bin/bash -l -c "gem install bundler -v 1.10.5 --no-ri --no-rdoc"

ENV APP_ROOT /yourator

RUN mkdir $APP_ROOT
WORKDIR $APP_ROOT
ADD . $APP_ROOT
RUN /bin/bash -l -c "bundle install"
```

參考文件：

* [Get started with Docker for Mac](https://docs.docker.com/docker-for-mac/)
* [Docker —— 從入門到實踐](https://philipzheng.gitbooks.io/docker_practice/content/index.html)
* [淺談輕量化的虛擬技術 - Docker容器](http://www.cc.ntu.edu.tw/chinese/epaper/0036/20160321_3611.html)
* [撰寫一份符合需求的 Dockerfile](http://cepave.com/how-to-write-dockerfile/)
* [Dockerfile簡單介紹](http://bonze.tw/%E4%BC%BA%E6%9C%8D%E5%99%A8%E7%A0%94%E7%A9%B6%E5%AE%A4/dockerfile%E7%B0%A1%E5%96%AE%E4%BB%8B%E7%B4%B9)
* [Dockerfile裡指定執行命令用ENTRYPOING和用CMD有何不同？](https://segmentfault.com/q/1010000000417103)