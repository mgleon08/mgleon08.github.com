<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Rails | Leon's Blogging]]></title>
  <link href="http://mgleon08.github.com/blog/categories/rails/atom.xml" rel="self"/>
  <link href="http://mgleon08.github.com/"/>
  <updated>2016-07-17T20:03:23+08:00</updated>
  <id>http://mgleon08.github.com/</id>
  <author>
    <name><![CDATA[LeonJi]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Custom Seed File]]></title>
    <link href="http://mgleon08.github.com/blog/2016/07/04/custom-seed-file/"/>
    <updated>2016-07-04T22:27:18+08:00</updated>
    <id>http://mgleon08.github.com/blog/2016/07/04/custom-seed-file</id>
    <content type="html"><![CDATA[<p>在 <code>db</code> 下有個 seed.rb，可以寫一些假資料 or 要匯入的資料，在執行 <code>rake db:seed</code> 就會執行了<br/>
但是當有多個檔案，就可以自己寫個 <code>task</code> 來覆蓋原本的 <code>rake db:seed</code></p>

<!-- more -->


<p></p>

<pre><code class="ruby">#檔案可以放在 db/seeds 資料夾底下
#db/seeds/hello.rb
puts 'hello'

#lib/tasks/custom_seed.rake
namespace :db do
  namespace :seed do
    Dir[File.join(Rails.root, 'db', 'seeds', '*.rb')].each do |filename|
      task_name = File.basename(filename, '.rb').intern    
      task task_name =&gt; :environment do
        load(filename) if File.exist?(filename)
      end
    end
  end
end
</code></pre>

<p>接著執行</p>

<pre><code class="ruby">rake db:seed:hello
#=&gt;hello
</code></pre>

<p>參考文件： <br/>
<a href="http://stackoverflow.com/questions/19872271/adding-a-custom-seed-file">Adding a custom seed file</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[好用的 Hash Method]]></title>
    <link href="http://mgleon08.github.com/blog/2016/07/04/rails-hash/"/>
    <updated>2016-07-04T21:58:11+08:00</updated>
    <id>http://mgleon08.github.com/blog/2016/07/04/rails-hash</id>
    <content type="html"><![CDATA[<p>在 rails 當中經常會使用 hash，rails 也提供很多方便的 methods</p>

<!--more-->


<h1>Hash</h1>

<pre><code class="ruby">Hash["a", 100, "b", 200]             #=&gt; {"a"=&gt;100, "b"=&gt;200}
Hash[ [ ["a", 100], ["b", 200] ] ]   #=&gt; {"a"=&gt;100, "b"=&gt;200}
Hash["a" =&gt; 100, "b" =&gt; 200]         #=&gt; {"a"=&gt;100, "b"=&gt;200}
</code></pre>

<h1>merge &amp; merge!</h1>

<p>回傳新的 hash，後面一樣的 key 則會覆蓋前面的</p>

<blockquote><p>以後面的為優先</p></blockquote>

<pre><code class="ruby">h1 = { "a" =&gt; 100, "b" =&gt; 200 }
h2 = { "b" =&gt; 254, "c" =&gt; 300 }
h1.merge(h2)   #=&gt; {"a"=&gt;100, "b"=&gt;254, "c"=&gt;300}

#將重複的做其他處理
h1.merge(h2){|key, oldval, newval| newval - oldval}
#=&gt; {"a"=&gt;100, "b"=&gt;54,  "c"=&gt;300}
h1             #=&gt; {"a"=&gt;100, "b"=&gt;200}
</code></pre>

<p><code>merge!</code> 直接改變原先的 hash</p>

<pre><code class="ruby">h1.merge!(h2)
#=&gt; {"a"=&gt;100, "b"=&gt;254, "c"=&gt;300}
h1
#=&gt; {"a"=&gt;100, "b"=&gt;254, "c"=&gt;300}
</code></pre>

<h1>reverse_merge &amp; reverse_merge!</h1>

<p>回傳新的 hash，前面一樣的 key 則會覆蓋後面的</p>

<p>通常用在指定hash的預設值</p>

<blockquote><p>以前面的為優先</p></blockquote>

<pre><code class="ruby">h1 = { "a" =&gt; 100, "b" =&gt; 200 }
h2 = { "b" =&gt; 254, "c" =&gt; 300 }

h1.merge(h2)
#=&gt; {"a"=&gt;100, "b"=&gt;254, "c"=&gt;300}
h1.reverse_merge(h2)
#=&gt; {"b"=&gt;200, "c"=&gt;300, "a"=&gt;100}
</code></pre>

<h1>deep_merge &amp; deep_merge!</h1>

<p>在兩個hash的鍵值相同，而值也是個hash的情況下</p>

<pre><code class="ruby">h1 = {:a =&gt; {:b =&gt; 1}}
h2 = {:a =&gt; {:c =&gt; 2}}

h1.merge(h2)
#=&gt; {:a=&gt;{:c=&gt;2}} error
h1.deep_merge(h2)
#=&gt; {:a=&gt;{:b=&gt;1, :c=&gt;2}}
</code></pre>

<h1>fetch</h1>

<p>即使是 nil, false 也會回傳，只有在空值的時候回傳預設值</p>

<pre><code class="ruby">h = { "a" =&gt; 100, "b" =&gt; false , 'c' =&gt; nil}
#=&gt; {"a"=&gt;100, "b"=&gt;false, "c"=&gt;nil}
h.fetch('a', 8)
#=&gt; 100
h.fetch('b', 8)
#=&gt; false
h.fetch('c', 8)
#=&gt; nil
h.fetch('d', 8)
#=&gt; 8
</code></pre>

<h1>except &amp; except!</h1>

<p>通常用在確保某些欄位不要被傳進來的參數修改到</p>

<pre><code class="ruby">h1 = { a:100, b:200 }
h1.except(:a)
</code></pre>

<h1>symbolize_keys &amp; symbolize_keys!</h1>

<p>回傳新的 hash，key 值轉成 symbol</p>

<blockquote><p>通常用在確保 key 的一致性</p></blockquote>

<pre><code class="ruby">hash = { 'name' =&gt; 'Rob', 'age' =&gt; '28' }

hash.symbolize_keys
# =&gt; {:name=&gt;"Rob", :age=&gt;"28"}
</code></pre>

<h1>stringify_keys &amp; stringify_keys!</h1>

<p>回傳新的 hash，key 值轉成 string</p>

<p>alias <code>to_options</code> &amp; <code>to_options!</code></p>

<blockquote><p>通常用在確保 key 的一致性</p></blockquote>

<pre><code class="ruby">hash = { name: 'Rob', age: '28' }

hash.stringify_keys
#=&gt; { "name" =&gt; "Rob", "age" =&gt; "28" }

#若有衝突已後面為優先
{"a" =&gt; 1, :a =&gt; 2}.stringify_keys
#=&gt; {"a"=&gt;2}
</code></pre>

<h1>slice &amp; slice!</h1>

<p>有 <code>!</code> 行為會不太一樣，要注意</p>

<pre><code class="ruby">h1 = { "a" =&gt; 100, "b" =&gt; 200 }

h1.slice("a")
#=&gt; {"a"=&gt;100}
h1
#=&gt; {"a"=&gt;100, "b"=&gt;200}

h1.slice!("a")
#=&gt; {"b"=&gt;200}
h1
#=&gt; {"a"=&gt;100}
</code></pre>

<h1>extract!</h1>

<p>將需要的值提取出來，成為新的 hash</p>

<pre><code class="ruby">h1 = { "a" =&gt; 100, "b" =&gt; 200 }
h1.extract!("a")
#=&gt; {"a"=&gt;100}
h1
#=&gt; {"b"=&gt;200}
</code></pre>

<h1>to_query</h1>

<p>Alias for Hash#to_query</p>

<pre><code class="ruby">{name: 'David', nationality: 'Danish'}.to_query
#=&gt; "name=David&amp;nationality=Danish"

{name: 'David', nationality: 'Danish'}.to_query('user')
# =&gt; "user%5Bname%5D=David&amp;user%5Bnationality%5D=Danish"
</code></pre>

<h1>other</h1>

<h3>attributes</h3>

<p>將物件轉成 hash</p>

<pre><code class="ruby">foo = Book.first
#=&gt; #&lt;Book id: 22, name: "book", desc: "desc", created_at: "xxx", updated_at: "xxx"&gt;

foo.attributes
#=&gt; {"id"=&gt;22, "name"=&gt;"book", "desc"=&gt;"desc", "star"=&gt;1, "created_at"=&gt;xxx, "updated_at"=&gt;xxx}
</code></pre>

<p>官方文件：<br/>
<a href="http://ruby-doc.org/core-2.1.5/Hash.html">Ruby Doc Hash</a><br/>
<a href="http://apidock.com/rails/v4.2.1/Hash">Hash apidock</a></p>

<p>參考文件：<br/>
<a href="https://ihower.tw/rails4/activesupport.html">ActiveSupport - 工具函式庫</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Class << Self]]></title>
    <link href="http://mgleon08.github.com/blog/2016/07/04/class-self/"/>
    <updated>2016-07-04T00:01:37+08:00</updated>
    <id>http://mgleon08.github.com/blog/2016/07/04/class-self</id>
    <content type="html"><![CDATA[<p>有時會看到這種特別的寫法 <code>class &lt;&lt; self</code>，有兩種不同的用法</p>

<!-- more -->


<h1>class method</h1>

<p>將所以需要 <code>self.</code> 全部包在裡面，就不用一個一個 <code>self.</code><br/>
不過這比較看是個人偏好，有些人會覺得 <code>self.</code> 可讀性較高</p>

<p><a href="http://stackoverflow.com/questions/10964081/class-self-vs-self-method-with-ruby-whats-better">class &lt;&lt; self vs self.method with Ruby: what&rsquo;s better?</a></p>

<pre><code class="ruby">class Foo
    def self.bar
        puts 'bar'
    end
    def self.bar2
        puts 'bar2'
    end
end

puts Foo.bar
#bar
puts Foo.bar2
#bar2
</code></pre>

<p>上下相等</p>

<pre><code class="ruby">class Foo
  class &lt;&lt; self
    def bar
      puts 'bar'
    end
    def bar2
      puts 'bar2'
    end
  end
end

puts Foo.bar
#bar
puts Foo.bar2
#bar2
</code></pre>

<h1>對單一物件，宣告出一個類別</h1>

<pre><code class="ruby">class Foo
  def foo
    return 'foo'
  end
end

f1 = Foo.new
f2 = Foo.new

puts f1.foo # foo
puts f2.foo # foo

# 只對f1 修改方法
class &lt;&lt; f1
  def foo
    return 'Edit foo'
  end
end

puts f1.foo # Edit foo
puts f2.foo # foo

# 只對f1 新增方法
class &lt;&lt; f1
  def bar
    return 'bar'
  end
end

puts f1.bar # bar
puts f2.bar # undefined method `bar'
</code></pre>

<p>參考文件：<br/>
<a href="http://wemee.blogspot.tw/2014/07/ruby-class.html">Ruby: class &lt;&lt; self</a><br/>
<a href="http://stackoverflow.com/questions/10964081/class-self-vs-self-method-with-ruby-whats-better">class &lt;&lt; self vs self.method with Ruby: what&rsquo;s better?</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Retrieving Multiple Objects in Batches 批次取出多筆記錄]]></title>
    <link href="http://mgleon08.github.com/blog/2016/06/22/retrieving-multiple-objects-in-batches/"/>
    <updated>2016-06-22T00:32:45+08:00</updated>
    <id>http://mgleon08.github.com/blog/2016/06/22/retrieving-multiple-objects-in-batches</id>
    <content type="html"><![CDATA[<p>當要處理多筆資料時，一般都會用 User.all 去取資料</p>

<!-- more -->


<p>但是當資料相當龐大，一次取出那麼多會非常佔用記憶體<br/>
因此有以下解決方式，一次拿一部分（預設為1000）</p>

<h1>find_each</h1>

<ul>
<li>一筆一筆放入區塊。</li>
</ul>


<pre><code class="ruby">User.find_each(start: 2000, batch_size: 5000) do |user|
  NewsMailer.weekly(user).deliver_now
end

#:start 選項可以設定批次的起始 ID。
#:batch_size 選項允許你在將各筆記錄傳進區塊前，指定一批要取多少筆記錄。
</code></pre>

<h1>find_in_batches</h1>

<ul>
<li>取出記錄放入陣列傳至區塊</li>
</ul>


<pre><code class="ruby">Invoice.find_in_batches do |invoices|
  export.add_invoices(invoices)
end

#和 find_each 一樣的選項 :batch_size 與 :start。
</code></pre>

<p>官方資料：<br/>
<a href="http://guides.rubyonrails.org/active_record_querying.html">Active Record Query Interface</a><br/>
<a href="http://rails.ruby.tw/active_record_querying.html">Active Record 查詢</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Cache Etag Memcache]]></title>
    <link href="http://mgleon08.github.com/blog/2016/06/13/cache-etag-memcache/"/>
    <updated>2016-06-13T23:22:01+08:00</updated>
    <id>http://mgleon08.github.com/blog/2016/06/13/cache-etag-memcache</id>
    <content type="html"><![CDATA[<p>當有資料不常去做更動，就能夠用 cache 去讀取增加速度!</p>

<!-- more -->


<ul>
<li>cache 處太多，程式會變複雜，增加維護的難度</li>
<li>cache 會增加除錯難度，資料不再只有唯一的資料庫版本</li>
<li>cache 如果沒寫好，可能會產生資料不一致的Bug、時間顯示相關的Bug(例如顯示資料的時間雖然時間不會變，但是如果是要顯示多少小時以前，就會變動了)等等</li>
<li>cache 增加了寫程式的難度，像是Expire過期資料、資料的安全性(放在cache 層的資料也需要被保護注意安全)</li>
<li>會增加撰寫UI的難度，因為 cache 相關的程式可能會混在樣本中</li>
</ul>


<h1>Cache Store</h1>

<ul>
<li>預設的 memory_store 只適合單機開發，重啟 Rails cache 資料就不見了。</li>
<li>正式上線的網站會推薦使用 <code>Memcached</code></li>
<li>它是一套Name-Value Pair(NVP)分散式記憶體快取系統，當你有多個Rails伺服器的時候，也可以很方便的共用快取資料。</li>
</ul>


<h1>Etag</h1>

<p>ETag 是用來辨識當前的頁面是否有所改變（Rails 預設就有使用了）</p>

<p>第一次</p>

<ol>
<li>Client 發 Request</li>
<li>Rails 流程

<ul>
<li><ol>
<li>Render body</li>
</ol>
</li>
<li><ol>
<li>Create ETag</li>
</ol>
</li>
<li><ol>
<li>Body &amp; ETag included in response(<code>headers['ETag'] = Digest::MD5.hexdigest(body)</code>)</li>
</ol>
</li>
</ul>
</li>
<li>Rails 發 Response

<ul>
<li>200 Success Head 裡包含 ￼headers[&lsquo;ETag&rsquo;]</li>
</ul>
</li>
<li>Client 接收並 caches response</li>
</ol>


<p>第二次</p>

<ol>
<li>Client 發 Request 並帶著 <code>headers['If-None-Match']</code> 就是 Etag 但不知道為什麼要叫這名字</li>
<li>Rails 流程

<ul>
<li><ol>
<li>Render body</li>
</ol>
</li>
<li><ol>
<li>Create ETag</li>
</ol>
</li>
<li><ol>
<li>Compare ETag</li>
</ol>
</li>
<li><ol>
<li>If ETags match then body not included in response</li>
</ol>
</li>
</ul>
</li>
<li>Rails 發 Response

<ul>
<li>304 Not Modified</li>
</ul>
</li>
<li>Client 接收並 reads response from cache</li>
</ol>


<p>以上雖然就不需要再重新 response body，但是每次 request 都必須再把整個 body 去 generate 一次 ETag 這是相當沒有效率的事</p>

<p>所以可以透過 Customer Etag 來改善</p>

<pre><code class="ruby">class ItemsController &lt; ApplicationController
  etag {current_user.id}
    def show    @item = Item.find(params[:id])￼    fresh_when(@item)
    #headers['ETag'] = Digest::MD5.hexdigest(@item.cache_key)
    #加上面的 etag {current_user.id} 等於 fresh_when([@item, current_user.id])，可以有更多參數去判斷是否有改變  endend
</code></pre>

<p>這樣一來就只要 id 和 update_at 兩個就可以知道到底整個頁面有沒有東西變動過</p>

<h1>memcache store uses dalli</h1>

<p>Dalli is a high performance pure Ruby client for accessing memcached servers</p>

<ol>
<li>Approximately 20% faster than memcache-client.</li>
<li>Provides proper failover with recovery and adjustable timeouts.</li>
<li>Easier to integrate with monitoring tools like NewRelic RPM in order to track usage. 4. ThreadSafe.</li>
<li><p>Backwards compatible with the previous memcache-client API.</p></li>
<li><p>安裝Memcached</p></li>
</ol>


<pre><code class="ruby">brew install memcached
</code></pre>

<ul>
<li>加上memcached的函式庫</li>
</ul>


<pre><code class="ruby">gem "dalli"
</code></pre>

<p>編輯<code>config/environments/development.rb</code>和<code>production.rb</code>加上</p>

<pre><code class="ruby">config.action_controller.perform_caching = true
config.cache_store = :dalli_store
</code></pre>

<pre><code class="ruby"># 存入
Rails.cache.write('first', Post.first)
# 取出
Rails.cache.read('first')
# 删除
Rails.cache.delete('first')
# 查看
Rails.cache.exist?('first')
# fetch: 檢查 key 是否存在, 不存在, 把 block 里的结果作為 value, 并返回结果. 如果存在, 就不去執行 block 的内容
Rails.cache.fetch('last_post') { Post.last }
# =&gt; blah
# 还可以设定过期时间
Rails.cache.fetch('time', expires_in: 4.seconds) { Time.now }
</code></pre>

<h3>使用時機</h3>

<p>資料庫裡不常變動的資料，ex:所有國家</p>

<p>使用</p>

<pre><code class="ruby">def cached_skills
  Rails.cache.fetch([self.class.name, id, :skills], expires_in: 240.hours) {
    skills.to_a
  }
end
</code></pre>

<ul>
<li>[self.class.name, id, :skills]這是存儲的關鍵</li>
<li>cache 將會在240小時後過期</li>
<li>如果不轉 array (to_a)直接將 active-record 的 relations 儲存到 cache 的話，每次訪問 cache 這個 relations 還是會查詢資料庫的</li>
</ul>


<p>gem：<br/>
<a href="https://github.com/petergoldstein/dalli">dalli</a></p>

<p>官方文件：<br/>
<a href="http://guides.ruby-china.org/caching_with_rails.html">Rails 缓存简介</a><br/>
<a href="http://guides.rubyonrails.org/caching_with_rails.html">Caching with Rails: An overview</a><br/>
<a href="https://memcached.org/">memcached</a></p>

<p>參考文件：<br/>
<a href="https://ihower.tw/rails4/caching.html">快取</a><br/>
<a href="https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/http-caching">Google Developers: HTTP 快取</a><br/>
<a href="http://grantcss.com/blog/2014/12/04/introduce-dalli/">數據緩存提升性能gem - Dalli介紹</a><br/>
<a href="https://ihower.tw/blog/archives/1768">如何使用 memcached 做快取</a><br/>
<a href="https://danielzhangqinglong.github.io/2015/03/19/rails-caching/">Rails中使用memcached內存緩存技術</a><br/>
<a href="https://danielzhangqinglong.github.io/2015/04/03/intro-http-caching-with-rails/">译 ~ 介绍Rails中的条件HTTP缓存</a><br/>
<a href="https://ruby-china.org/topics/24996">Rails 3 和 Rails 4 中 ETags 工作原理</a><br/>
<a href="http://enginechang.logdown.com/posts/249025-discussion-on-memory-cache">淺談memory cache</a><br/>
<a href="https://ruby-china.org/topics/19389">总结 Web 应用中常用的各种 Cache</a><br/>
<a href="http://rails-everyday.group.iteye.com/group/wiki/1160">Rails Cache</a><br/>
<a href="https://www.nateberkopec.com/2015/07/15/the-complete-guide-to-rails-caching.html">Speed Up Your Rails App by 66% - The Complete Guide to Rails Caching</a><br/>
<a href="https://www.fastly.com/blog/accelerating-rails-part-1-built-caching">Accelerating Rails, Part 1: Built-in Caching</a><br/>
<a href="https://www.fastly.com/blog/accelerating-rails-part-2-dynamic-http-caching">Accelerating Rails, Part 2: Dynamic HTTP Caching</a></p>
]]></content>
  </entry>
  
</feed>
