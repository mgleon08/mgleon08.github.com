<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Rails | Leon's Blogging]]></title>
  <link href="http://mgleon08.github.com/blog/categories/rails/atom.xml" rel="self"/>
  <link href="http://mgleon08.github.com/"/>
  <updated>2019-02-18T22:50:14+08:00</updated>
  <id>http://mgleon08.github.com/</id>
  <author>
    <name><![CDATA[LeonJi]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Rails + Puma + Nginx + MySQL With Docker]]></title>
    <link href="http://mgleon08.github.com/blog/2019/01/13/rails-puma-nginx-mysql-with-docker/"/>
    <updated>2019-01-13T23:57:34+08:00</updated>
    <id>http://mgleon08.github.com/blog/2019/01/13/rails-puma-nginx-mysql-with-docker</id>
    <content type="html"><![CDATA[<!-- more -->


<p>將 Rails + Puma,  Nginx,  MySQL 都拆開成各自的 container，並透過 docker-compose 將多個 container 串起來，各司其職，協同服務。</p>

<ul>
<li>Nginx 在最前面解析請求並處理靜態資源</li>
<li>Puma 位於 Nginx 於 Rails 程序之間，用於處理動態的請求；最後面還有一個數據存儲的 MySQL</li>
</ul>


<p>container 分配</p>

<ul>
<li>app - 用來啟動 Rails + Puma</li>
<li>web - 存放 nginx，負責解析各種外部請求，處理靜態的資源
(靜態資源就是運行 rake assets:precompile 生成在 public/assets 中的內容)</li>
<li>db - MySQL</li>
</ul>


<p>在現有的 rails project 加上 docker 所需的 file</p>

<pre><code class="ruby">rails_project
├── docker
│   └── app
│       └── Dockerfile
│   └── db
│       └── grant_user.sql
│   └── web
│       ├── Dockerfile
│       └── nginx.conf
├── docker-compose.yml
└── .env
</code></pre>

<h3>docker/app/Dockerfile</h3>

<pre><code class="ruby"># Base image
FROM ruby:2.5.1

# Install plugin
RUN apt-get update -qq &amp;&amp; apt-get install -y build-essential vim

# Install mysql
RUN apt-get install -y default-libmysqlclient-dev

# Install nodejs
RUN curl -sL https://deb.nodesource.com/setup_11.x | bash - &amp;&amp;\
    apt-get install -y nodejs

# Clears out the local repository of retrieved package files
RUN apt-get -q clean

# Set an environment variable where the Rails app is installed to inside of Docker image
ENV APP_PATH /usr/src/app
RUN mkdir -p $APP_PATH

# Set working directory
WORKDIR $APP_PATH

# Setting env up
ENV RAILS_ENV production
ENV RACK_ENV production
# Setting local
ENV LC_ALL C.UTF-8
# Setting timezone
ENV TZ Asia/Taipei
RUN cp /usr/share/zoneinfo/$TZ /etc/localtime &amp;&amp; echo $TZ &gt; /etc/timezone

# COPY Gemfile &amp; Gemfil.lock
COPY Gemfile* $APP_PATH/

# Run bundle
RUN bundle install --jobs 20 --retry 5 --without development test --path vendor/bundle

# Adding project files
COPY . $APP_PATH/

# Build Frond-End
RUN RAILS_ENV=$RAILS_ENV bundle exec rake assets:precompile

EXPOSE 3000

CMD ["bundle", "exec", "puma", "-C", "config/puma.rb"]
</code></pre>

<h3>docker/web/Dockerfile</h3>

<pre><code class="ruby"># Base image
FROM nginx:1.15.8

# Install dependencies
RUN apt-get update -qq &amp;&amp; apt-get -y install apache2-utils vim

# Establish where Nginx should look for files
ENV RAILS_ROOT /usr/src/app
# Setting local
ENV LC_ALL C.UTF-8
# Setting timezone
ENV TZ Asia/Taipei
RUN cp /usr/share/zoneinfo/$TZ /etc/localtime &amp;&amp; echo $TZ &gt; /etc/timezone

# Set our working directory inside the image
WORKDIR $RAILS_ROOT

# create log directory
RUN mkdir log

# copy over static assets
COPY public public/

# Copy Nginx config template
COPY docker/web/nginx.conf /tmp/docker.nginx

# substitute variable references in the Nginx config template for real values from the environment
# put the final config in its place
RUN envsubst '$RAILS_ROOT' &lt; /tmp/docker.nginx &gt; /etc/nginx/conf.d/default.conf
EXPOSE 80

# Use the "exec" form of CMD so Nginx shuts down gracefully on SIGTERM (i.e. `docker stop`)
CMD [ "nginx", "-g", "daemon off;" ]
</code></pre>

<h3>docker/web/nginx.conf</h3>

<pre><code class="ruby"># define our application server

upstream rails_app {
  # The app service 3000 port that points to the docker-compose definition
   server app:3000;
}

server {
   listen 80;
   # define your domain or IP
   server_name localhost;

   # define the public application root
   root   $RAILS_ROOT/public;
   index  index.html;

   # define where Nginx should write its logs
   access_log $RAILS_ROOT/log/nginx.access.log;
   error_log $RAILS_ROOT/log/nginx.error.log;

   # deny requests for files that should never be accessed
   # ~ regular 區分大小寫, .env / .git
   location ~ /\. {
      deny all;
   }

   # ~* regular 不分大小寫, .rb / .log
   location ~* ^.+\.(rb|log)$ {
      deny all;
   }

   # serve static (compiled) assets directly if they exist (for rails production)
   location ~ ^/(assets|images|javascripts|stylesheets|swfs|system)/   {
      # $uri: localhost/404.html，則 $uri 為 `/404.html`
      # @rails: 後面定義的 location @rails
      # 如果 url 匹配進來，則先按 $uri 處理，若沒有找到，則交給 @rails 處理
      try_files $uri @rails;
      # close access log
      access_log off;
      # to serve pre-gzipped version
      # 設定為 `on` ，在處理壓縮之前，先查找已經預壓縮的文件（.gz）
      # 避免每次對同一個文件進行重複的壓縮處理
      gzip_static on;

      expires max;
      # public 對每個用戶有效; private 對當前用戶有效
      add_header Cache-Control public;

      add_header Last-Modified "";
      add_header ETag "";
      break;
   }

   # send non-static file requests to the app server
   location / {
      try_files $uri @rails;
   }

   location @rails {
      internal; # 只能被內部的請求呼叫，外部的呼叫請求會返回 'Not found'
      proxy_set_header  X-Real-IP  $remote_addr;
      proxy_set_header  X-Forwarded-For $proxy_add_x_forwarded_for;
      proxy_set_header Host $http_host;
      proxy_redirect off;
      proxy_pass http://rails_app; # 導向到 upstream rails_app
   }
}
</code></pre>

<h3>database.yml</h3>

<p><code>host name</code> 必須對應到 docker-compose 所定義的 <code>service name</code>，並且透過環境變數所設定的 user 來登入</p>

<pre><code class="ruby">default: &amp;default
  adapter: mysql2
  encoding: utf8
  pool: &lt;%= ENV.fetch("RAILS_MAX_THREADS") { 5 } %&gt;
  host: db
  port: 3306
  username: &lt;%= ENV.fetch('MYSQL_USER') { 'root' } %&gt;
  password: &lt;%= ENV.fetch('MYSQL_PASSWORD') { 'password' } %&gt;
  socket: /tmp/mysql.sock
</code></pre>

<h3>docker/db/grant_user.sql</h3>

<p>因為在 mysql 有另外建立一個 user，並且在 database.yml 也是透過這個 user 來登入，因此必須授權給此 user 權限，才能夠操作</p>

<pre><code class="ruby">GRANT ALL PRIVILEGES ON *.* TO 'user_name'@'%';
FLUSH PRIVILEGES;
</code></pre>

<h3>docker-compose.yml</h3>

<pre><code class="ruby">version: '3'
services:
  app:
    build:
      context: .
      dockerfile: ./docker/app/Dockerfile
    env_file:
      - .env
    volumes:
      - .:/usr/src/app
    depends_on:
      - db
  db:
    image: mysql:5.7.23
    command: --default-authentication-plugin=mysql_native_password
    restart: always
    env_file:
      - .env
    ports:
      - "3306:3306"
    volumes:
      - db-data:/var/lib/mysql
  web:
    build:
      context: .
      dockerfile: ./docker/web/Dockerfile
    ports:
      - 80:80
    depends_on:
      - app
volumes:
  db-data:
    external: false
</code></pre>

<h3>.env</h3>

<p>docker-compose 所需要用到的環境變數，app &amp; web 都會用到</p>

<pre><code class="ruby">MYSQL_ROOT_PASSWORD=password
MYSQL_USER=user_name
MYSQL_PASSWORD=user_password
</code></pre>

<h3>Example project</h3>

<p><a href="https://github.com/mgleon08/product_system_production">product_system_production</a></p>

<pre><code class="ruby">git clone https://github.com/mgleon08/product_system_production
# 建立 image
docker-compose build
# 啟動
docker-compose up -d
# 因為是建立新的 user 來造訪 mysql，因此必須先授權此 user 權限
p# 確認是否授權成功
docker-compose exec db mysql -u user_name -p -e"show grants;"
# 建立資料庫
docker-compose run --rm app bundle exec rails db:create
# 跑 migrate
docker-compose run --rm app bundle exec rails db:migrate
# 建立假資料
docker-compose run --rm app bundle exec rails db:seed
# 查看畫面, 記得是 http
http://localhost
</code></pre>

<h3>Production</h3>

<p>Rails5.2 之後，secret_key_base 的設定改了，在 production 上要在 config 裡面加上 master.key file，並將 local 的亂碼貼上去</p>

<ul>
<li><a href="https://mgleon08.github.io/blog/2018/07/14/rails-credentials/">Rails 5.2 Credentials</a></li>
<li><a href="https://keithpblog.org/post/encrypted-secrets/">Rails 5.2: encrypted secrets</a></li>
</ul>


<h1>最後另外附上 develop 的 docker</h1>

<pre><code class="ruby"># docker-compose
version: '3'
services:
  db:
    image: mysql:5.7.23
    command: --default-authentication-plugin=mysql_native_password
    restart: always
    environment:
      MYSQL_ROOT_PASSWORD: password
    ports:
      - "3306:3306"
    volumes:
      - ./opt/data:/var/lib/mysql
  backend:
    container_name: product_system
    build:
      context: .
      args:
        UID: ${UID:-1001}
    volumes:
      - .:/usr/src/app
    ports:
      - "3000:3000"
    depends_on:
      - db
    user: deploy
</code></pre>

<pre><code class="ruby"># Dockerfile
FROM ruby:2.5.1

RUN apt-get update -qq &amp;&amp;\
    curl -sL https://deb.nodesource.com/setup_11.x | bash - &amp;&amp;\
    apt-get install -y nodejs cmake &amp;&amp;\
    apt-get clean

ARG UID
RUN adduser deploy --uid $UID --disabled-password --gecos ""

ENV APP /usr/src/app
RUN mkdir $APP
WORKDIR $APP

COPY Gemfile* $APP/
RUN bundle install -j3 --path vendor/bundle

COPY . $APP/

CMD ["bundle", "exec", "rails", "server", "-p", "3000", "-b", "0.0.0.0"]
</code></pre>

<p>參考文件:</p>

<ul>
<li><a href="https://qiita.com/eighty8/items/0288ab9c127ddb683315#db%E6%8E%A5%E7%B6%9A%E7%94%A8%E3%81%AE%E6%83%85%E5%A0%B1%E3%83%95%E3%82%A1%E3%82%A4%E3%83%AB">Docker + Rails + Puma + Nginx + MySQL</a></li>
<li><a href="https://itnext.io/docker-rails-puma-nginx-postgres-999cd8866b18">Docker + Rails + Puma + Nginx + Postgres</a></li>
<li><a href="https://stackoverflow.com/questions/8821864/config-assets-compile-true-in-rails-production-why-not/8827757#8827757">config.assets.compile=true in Rails production, why not?</a></li>
<li><a href="http://chrisstump.online/2016/02/20/docker-existing-rails-application/">Docker for an Existing Rails Application</a></li>
<li><a href="https://stackoverflow.com/questions/5877929/what-does-upstream-mean-in-nginx">What does upstream mean in nginx?</a></li>
<li><a href="https://www.fooish.com/sql/grant-privileges.html">SQL GRANT 授與資料庫使用權限</a></li>
<li><a href="https://blog.hellojcc.tw/2015/12/07/nginx-beginner-tutorial/">nginx 基礎設定教學</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[TaiwanUserID 台灣身分證字號驗證]]></title>
    <link href="http://mgleon08.github.com/blog/2018/07/24/taiwan-user-id/"/>
    <updated>2018-07-24T21:38:14+08:00</updated>
    <id>http://mgleon08.github.com/blog/2018/07/24/taiwan-user-id</id>
    <content type="html"><![CDATA[<p>你知道台灣身分證字號是怎麼算出來的嗎?</p>

<!-- more -->


<p>剛好公司同事有寫到，蠻有趣的來紀錄一下，要快還是要用 <code>while</code> 阿~</p>

<h1>公式</h1>

<pre><code>戶籍代表的字母數字：
Ａ台北市-10 Ｂ台中市-11 Ｃ基隆市-12 Ｄ台南市-13 Ｅ高雄市-14 Ｆ台北縣-15
Ｇ宜蘭縣-16 Ｈ桃園縣-17 Ｉ嘉義市-34 Ｊ新竹縣-18 Ｋ苗栗縣-19 Ｌ台中縣-20
Ｍ南投縣-21 Ｎ彰化縣-22 Ｏ新竹市-35 Ｐ雲林縣-23 Ｑ嘉義縣-24 Ｒ台南縣-25
Ｓ高雄縣-26 Ｔ屏東縣-27 Ｕ花蓮縣-28 Ｖ台東縣-29 Ｗ金門縣-32 Ｘ澎湖縣-30
Ｙ陽明山-31 Ｚ連江縣-33

公式
A123456789 -&gt; 10123456789

1   0   1    2    3    4    5    6    7   8   9 (拆解字母後的數字)
*   *   *    *    *    *    *    *    *   *   *
1   9   8    7    6    5    4    3    2   1   1 (固定係數)
-----------------------------------------------
1 + 0 + 8 + 14 + 18 + 20 + 20 + 18 + 14 + 8 + 9 = 130

130 % 10 == 0
</code></pre>

<h1>Code</h1>

<pre><code class="ruby">require 'benchmark'

LOCATION_CODE = {
  'A' =&gt; [1, 0], 'B' =&gt; [1, 1], 'C' =&gt; [1, 2], 'D' =&gt; [1, 3], 'E' =&gt; [1, 4], 'F' =&gt; [1, 5], 'G' =&gt; [1, 6], 'H' =&gt; [1, 7], 'I' =&gt; [3, 4],
  'J' =&gt; [1, 8], 'K' =&gt; [1, 9], 'L' =&gt; [2, 0], 'M' =&gt; [2, 1], 'N' =&gt; [2, 2], 'O' =&gt; [3, 5], 'P' =&gt; [2, 3], 'Q' =&gt; [2, 4], 'R' =&gt; [2, 5],
  'S' =&gt; [2, 6], 'T' =&gt; [2, 7], 'U' =&gt; [2, 8], 'V' =&gt; [2, 9], 'W' =&gt; [3, 2], 'X' =&gt; [3, 0], 'Y' =&gt; [3, 1], 'Z' =&gt; [3, 3]
}

MULTIPLIER = [1, 9, 8, 7, 6, 5, 4, 3, 2, 1, 1]

def id_card_validate(id)
  return false unless id =~ /\A[A-Z](1|2)\d{8}\z/
  chars = id.chars
  numbers = LOCATION_CODE[chars.shift] + chars.map(&amp;:to_i)
  sum = numbers.zip(MULTIPLIER).map{ |a, b| a * b }.reduce(:+)
  # sum, i = 0, 0
  # while i &lt;= 10
  #   sum += numbers[i] * MULTIPLIER[i]
  #   i += 1
  # end
  (sum % 10).zero?
end

n = 100000
Benchmark.bmbm do |x|
  x.report('leonji'){ n.times{ id_card_validate('A123456789') } }
end

# Rehearsal ------------------------------------------
# leonji   0.770000   0.010000   0.780000 (  0.796012)
# --------------------------------- total: 0.780000sec

#              user     system      total        real
# leonji   0.770000   0.000000   0.770000 (  0.792737)
</code></pre>

<p>參考文件</p>

<ul>
<li><a href="http://tzoyiing.pixnet.net/blog/post/29821245-%5B%E8%BD%89%E8%B2%BC%5D-%E8%BA%AB%E4%BB%BD%E8%A8%BC%E5%AD%97%E8%99%9F%E7%B7%A8%E7%A2%BC%E5%85%AC%E5%BC%8F%E8%AA%AA%E6%98%8E~%E6%95%99%E4%BD%A0%E5%A6%82%E4%BD%95%E9%A9%97">[轉貼] 身份證字號編碼公式說明~教你如何驗證</a></li>
<li><a href="https://tonytonyjan.net/2015/04/15/national-identification-card-validator-of-taiwan/">台灣身份證字號驗證器</a></li>
<li><a href="https://github.com/wayne5540/taiwanese_id_builder">taiwanese_id_builder</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Environment Banner]]></title>
    <link href="http://mgleon08.github.com/blog/2018/07/23/environment-banner/"/>
    <updated>2018-07-23T21:35:24+08:00</updated>
    <id>http://mgleon08.github.com/blog/2018/07/23/environment-banner</id>
    <content type="html"><![CDATA[<p>可以很快速的知道目前環境上的版本是什麼</p>

<!-- more -->


<p>公司因為多台機器不同環境，因此有同事做了一個 <code>Environment banner</code>，可以很方便地知道目前是哪一個 branch 哪一個 版本，這邊就來記錄一下</p>

<pre><code class="ruby"># app/helpers/environment_banner_helper.rb
module EnvironmentBannerHelper
  RELEASE_INFO_PATH = Rails.public_path.join('release_info')

  def current_branch
    if git_available?
      # 讀取當前 HEAD 所在的 branch 名稱
      `git rev-parse --abbrev-ref HEAD`.chomp
    else
      # 當在 deploy 的時候，無法用 git (除非另外裝)，因此可以先將資訊存放在某的檔案，或是環境變數
      git_info[:branch] # 檔案
      # ENV.fetch("CURRENT_BRANCH", "--branch-not-found--") # ENV
    end
  end

  def current_sha
    if git_available?
      # 讀取當前的 log 最新一行
      `git log --oneline -1`
    else
      # 當在 deploy 的時候，無法用 git (除非另外裝)，因此可以先將資訊存放在某的檔案，或是環境變數
      git_info[:sha] # 檔案
      # ENV.fetch("CURRENT_SHA", "--sha-not-found--") # ENV
    end
  end

  # 確認當前環境有沒有 git
  def git_available?
    to_dev_null = "&gt; /dev/null 2&gt;&amp;1"
    system("which git #{to_dev_null} &amp;&amp; git rev-parse --git-dir #{to_dev_null}")
  end

  # 主要是為了 capistrano 上面會有不同的 release 資料夾
  def release_number
    return unless check_release_info &amp;&amp; IO.readlines(RELEASE_INFO_PATH)[0]
    IO.readlines(RELEASE_INFO_PATH)[0].gsub(/\D/, '').prepend('#')
  end

  def git_info
    return { sha: "N/A", branch: "N/A"} unless check_release_info &amp;&amp; IO.readlines(RELEASE_INFO_PATH)[1]
    line = IO.readlines(RELEASE_INFO_PATH)[1].split(/\s+/)
    {
      sha:    line[0][0..6],
      branch: line[1].gsub(/refs\/heads\//, '')
    }
  end

  def check_release_info
    File.exist? RELEASE_INFO_PATH
  end
end
</code></pre>

<pre><code class="ruby"># app/views/layouts/application.html.erb
&lt;% unless Rails.env.production? %&gt;
  &lt;div class="environment-banner &lt;%= Rails.env %&gt;"&gt;
    &lt;%= Rails.env %&gt; | &lt;%= "#{current_branch} @ #{current_sha} #{release_number}" %&gt;
  &lt;/div&gt;
&lt;% end %&gt;
</code></pre>

<pre><code class="css">/* app/assets/stylesheets/application.scss */
.environment-banner.development {
  background: $green;
  color: $white;
}
</code></pre>

<p>capistrano deploy 時新增 <code>release_info</code> 檔案方式</p>

<pre><code class="ruby">set :repo_url, 'git@github.com:xxx/xxx.git'
ask :branch, `git rev-parse --abbrev-ref HEAD`.chomp

# 將所有 git 撞況寫到一個 file 上，再透過該 file 來顯示
# readlink 可以找到實際檔案位置，awk 分析出路徑上最後的 release 資料夾名稱
execute("echo current_release: `readlink -f #{release_path} | awk -F'/' '{print $NF}'` &gt; #{shared_path.join('public/release_info')}")
# header
execute("git ls-remote -h #{fetch(:repo_url)} #{fetch(:branch)} &gt;&gt; #{shared_path.join('public/release_info')}")
# tag
execute("git ls-remote -t #{fetch(:repo_url)} | tail -n 1 &gt;&gt; #{shared_path.join('public/release_info')}")
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Deploying Rails API + Nuxt.js + Devise-JWT API App to Production With Heroku]]></title>
    <link href="http://mgleon08.github.com/blog/2018/07/22/deploying-rails-nuxt-jwt-to-production-with-heroku/"/>
    <updated>2018-07-22T23:12:48+08:00</updated>
    <id>http://mgleon08.github.com/blog/2018/07/22/deploying-rails-nuxt-jwt-to-production-with-heroku</id>
    <content type="html"><![CDATA[<p>接著來把做好的 <code>Rails API + Nuxt.js + Devise-JWT</code> deploy 到 heroku</p>

<!-- more -->


<ul>
<li><a href="https://medium.com/@fishpercolator/deploying-your-nuxt-rails-api-app-to-production-with-heroku-54efd09eec22">Deploying your Nuxt+Rails API app to production with Heroku</a></li>
</ul>


<p>由於一開始我們希望用 docker-compose 來 build 環境，因此將前後端都 commit 在一起，但在部屬的時候希望將兩個分開，這時就可以用到 <code>git subtree</code></p>

<p><a href="https://heroku.com"><img src="https://www.herokucdn.com/deploy/button.svg" alt="Deploy" /></a></p>

<h1>Backend</h1>

<p>Rails5.2 必須先將 <code>production</code> 的 <code>config.require_master_key</code> 打開</p>

<pre><code class="ruby"># autheg-backend/config/environments/production.rb
config.require_master_key = true
</code></pre>

<p>記得要把 <code>cors.rb</code> 設定成 herokuapp 的 domain (根據前端專案的名稱)</p>

<pre><code class="ruby"># autheg-backend/config/initializers/cors.rb
origins 'localhost:3000', 'autheg-frontend-demo.herokuapp.com'
# or
origins '*'
</code></pre>

<p>安裝 <a href="https://devcenter.heroku.com/articles/heroku-cli">heroku-cli</a></p>

<pre><code class="ruby">brew install heroku/brew/heroku
</code></pre>

<p>create backend 的 heroku 專案</p>

<pre><code class="ruby"># 先到最上層的資料夾
cd autheg
# 如果看到這個 "Name is already taken"，就換一個名字即可
heroku apps:create autheg-backend-demo
</code></pre>

<p>預設 remote name 會是 heroku，因為等下要在 create frontend remote，因此先改名</p>

<pre><code class="ruby"># 更改 local 的 remote name
git remote rename heroku backend
</code></pre>

<p>將後端 autheg-backend push 上去</p>

<pre><code class="ruby"># 透過 subtree 先將後端 autheg-backend push 上去
git subtree push --prefix autheg-backend backend master
</code></pre>

<p>建立環境變數</p>

<pre><code class="ruby">heroku config:set -a autheg-backend-demo RAILS_MASTER_KEY=(local 裡面的 config.master.key)

heroku config:set -a autheg-backend-demo JWT_SECRET=$(heroku run -a autheg-backend-demo rails secret)
</code></pre>

<p>建立 table data</p>

<pre><code class="ruby">heroku run -a autheg-backend-demo rails db:schema:load
</code></pre>

<p>新增 db 資料</p>

<pre><code class="ruby">heroku run -a autheg-backend-demo rails console

# user
User.create! email: "test@example.com", password: "password"

# example
{"foo" =&gt; "green", "bar" =&gt; "red", "baz" =&gt; "purple"}.each {|n,c| Example.create!(name: n, colour: c)}
</code></pre>

<p>接下來就可以透過 <a href="http://yet-another-rest-client.com/">YARC</a> or <a href="https://www.getpostman.com/">Postman</a> 來測試有沒有成功!</p>

<pre><code class="ruby">POST https://autheg-backend-demo.herokuapp.com/api/users/sign_in

{
   "user":{
      "email":"test@example.com",
      "password":"password"
   }
}
</code></pre>

<h1>Frontend</h1>

<p><a href="https://github.com/nuxt/docs/blob/master/en/faq/heroku-deployment.md">nuxt heroku-deployment</a></p>

<p>create frontend 的 heroku 專案</p>

<pre><code class="ruby"># 先到最上層的資料夾
cd autheg
# 如果看到這個 "Name is already taken"，就換一個名字即可
heroku apps:create autheg-frontend-demo
</code></pre>

<p>rename remote name</p>

<pre><code class="ruby">git remote rename heroku frontend
</code></pre>

<p>設定環境變數，要跑在 production 模式，因此要將之前安裝在 dev 環境中的套件，安裝上去</p>

<blockquote><p>The following command tells your app to run in production mode and on all interfaces (0.0.0.0) but tells yarn/npm to run in development mode, so that all the dev packages are installed as part of the build process.</p></blockquote>

<pre><code class="ruby">heroku config:set -a autheg-frontend-demo NODE_ENV=production HOST=0.0.0.0 NPM_CONFIG_PRODUCTION=false
</code></pre>

<p>改一下 <code>package.json</code>，讓 heroku deploy 之後可以 build 檔案出來</p>

<pre><code class="ruby">"heroku-postbuild": "npm run build"
</code></pre>

<p>設定 backend 的 API 路徑</p>

<pre><code class="ruby">heroku config:set -a autheg-frontend-demo API_URL=https://autheg-backend-demo.herokuapp.com/api
</code></pre>

<p>接著就可以到首頁上去測試了</p>

<pre><code class="ruby">https://autheg-frontend-demo.herokuapp.com/
# email: test@example.com
# password: password
</code></pre>

<h1>Heroku</h1>

<p>其他 heroku 功能</p>

<pre><code class="ruby"># create new heroku project
heroku create

# push heroku
git push heroku master

# env config remove
heroku config:remove TOKEN

# log
heroku logs --tail

# scale
heroku ps:scale web=2

# ssh
heroku run -a autheg-backend bash

# run 指令
heroku run -a autheg-backend-demo rails console
</code></pre>

<h1>git subtree</h1>

<p>git subtree 本身不支援 force push，因此要透過其他方式來達成</p>

<ul>
<li><a href="https://gist.github.com/tduarte/eac064b4778711b116bb827f8c9bef7b">publish-ghpages.md</a></li>
</ul>


<pre><code class="ruby">git checkout master # you can avoid this line if you are in master...
git subtree split --prefix dist -b gh-pages # create a local gh-pages branch containing the splitted output folder
git push -f origin gh-pages:gh-pages # force the push of the gh-pages branch to the remote gh-pages branch at origin
git branch -D gh-pages # delete the local gh-pages because you will need it: ref
</code></pre>

<p>參考文件</p>

<ul>
<li><a href="https://medium.com/@fishpercolator/deploying-your-nuxt-rails-api-app-to-production-with-heroku-54efd09eec22">Deploying your Nuxt+Rails API app to production with Heroku</a></li>
<li><a href="https://hexo.crboy.net/2016/09/amazing-git-subtree/">神奇的 Git Subtree</a></li>
<li><a href="http://yutin.logdown.com/posts/188306-git-subtree-total-addendum-library">Git SubTree 共編 Library</a></li>
<li><a href="http://erning.net/blog/2012/05/09/the-twelve-factor-app/">The Twelve-Factor App</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Rails API + Nuxt.js + Devise-JWT]]></title>
    <link href="http://mgleon08.github.com/blog/2018/07/17/rails-nuxt-jwt/"/>
    <updated>2018-07-17T17:39:32+08:00</updated>
    <id>http://mgleon08.github.com/blog/2018/07/17/rails-nuxt-jwt</id>
    <content type="html"><![CDATA[<p>在網路上發現這篇文章，覺得寫得很不錯，所以這次就跟著這篇一起做一遍~</p>

<!-- more-->


<p><a href="https://medium.com/@fishpercolator/how-to-separate-frontend-backend-with-rails-api-nuxt-js-and-devise-jwt-cf7dd9da9d16">How to separate frontend + backend with Rails API, Nuxt.js and Devise-JWT</a></p>

<p>來學習，<code>Rails API / Nuxt.js / JWT / Docker</code></p>

<ul>
<li><a href="#part1">Part 1: Creating a development environment</a></li>
<li><a href="#part2">Part 2: Getting them talking to each other</a></li>
<li><a href="#part3">Part 3: Authentication with Devise-JWT</a></li>
</ul>


<h1><span id="part1">Part 1: Creating a development environment</span></h1>

<pre><code class="ruby"># backend
mkdir autheg
cd autheg
rails new autheg-backend -T --skip-spring -C -B -d postgresql --api
# -T = skip test
# -C = skip action cable
# -B = skip bundle 主要是作者要跑在 docker 裡面
# --api = 沒有任何 view 純 API server

#frontend
vue init nuxt-community/starter-template autheg-frontend
cd autheg-frontend
yarn generate-lock-entry &gt; yarn.lock
# 跟 -B 類似，為了不 install
</code></pre>

<h3>backend</h3>

<pre><code class="ruby"># autheg/autheg-backend/Dockerfile
FROM ruby:2.5

ARG UID 
RUN adduser rails --uid $UID --disabled-password --gecos ""
# 可以透過 $UID 給予不同的 user ID，並且進到任何的 container 都可以用相同的 user ID
# --disabled-password - 讓 rails 無法用密碼登入
# --gecos 用戶的詳細訊息（如姓名，年齡，電話等），因為 adduser 會提示你輸入用戶的密碼和相關的finger訊息，但是這個可以用選項--gecos來覆蓋。

ENV APP /usr/src/app
RUN mkdir $APP
WORKDIR $APP

COPY Gemfile* $APP/
RUN bundle install -j3 --path vendor/bundle
# Gems and yarn packages are installed into the mounted volumes. 
# This will stop you from needing to rebuild the whole Docker image every time you change the Gemfile or package.json.

COPY . $APP/

CMD ["bin/rails", "server", "-p", "8080", "-b", "0.0.0.0"]
# 這裡原本是 rails，但實際在 run 的時候會有 error，因此改為 bin/rails
</code></pre>

<p><code>.dockerignore</code> 避免 Docker 在 build 的時候，一併複製過去</p>

<pre><code class="ruby"># autheg/autheg-backend/.dockerignore
/vendor/bundle
/log
/tmp
</code></pre>

<pre><code class="ruby"># autheg/autheg-backend/.gitignore
/vendor/bundle/
</code></pre>

<h3>frontend</h3>

<pre><code class="ruby"># autheg/autheg-frontend/Dockerfile

FROM node:9

ARG UID
RUN adduser frontend --uid $UID --disabled-password --gecos ""

ENV APP /usr/src/app
RUN mkdir $APP
WORKDIR $APP

COPY package.json yarn.lock $APP/
RUN yarn
# Gems and yarn packages are installed into the mounted volumes. 
# This will stop you from needing to rebuild the whole Docker image every time you change the Gemfile or package.json.

COPY . $APP/

CMD ["yarn", "run", "dev"]
</code></pre>

<p><code>.dockerignore</code> 避免 Docker 在 build 的時候，一併複製過去</p>

<pre><code class="ruby"># autheg/autheg-frontend/.dockerignore
/node_modules/
</code></pre>

<h3>all</h3>

<pre><code class="ruby"># autheg/docker-compose.yml

version: '3' # dockerfile 版本 
services:
  db: # 對應 rails database.yml 的 host
    image: postgres
    ports:
      - "5432"
  backend: # 會變成 REPOSITORY name autheg_backend
    build:
      context: autheg-backend # 要 build 的資料夾位置
      args:
        UID: ${UID:-1001}
    volumes:
      - ./autheg-backend:/usr/src/app
      # 放哪裡沒有一定 /var/www/html,  /usr/src/app,  /home 都有人放
    ports:
      - "8080:8080"
    depends_on:
      - db
    user: rails # 對應到 adduser 的名稱
  frontend: # 會變成 REPOSITORY name autheg_frontend
    build:
      context: autheg-frontend
      args:
        UID: ${UID:-1001}
    volumes:
      - ./autheg-frontend:/usr/src/app
    ports:
      - "3000:3000"
    user: frontend # 對應到 adduser 的名稱
</code></pre>

<p>接下來執行</p>

<pre><code>docker-compose build
</code></pre>

<pre><code class="ruby"># docker images
REPOSITORY          TAG                 IMAGE ID            CREATED              SIZE
autheg_frontend     latest              18b1178326a7        About a minute ago   890MB
autheg_backend      latest              528bfe5bf6d6        2 minutes ago        1.03GB
</code></pre>

<pre><code>docker-compose run -u root backend bundle
</code></pre>

<pre><code class="ruby"># docker ps -a
CONTAINER ID        IMAGE               COMMAND                  CREATED              STATUS                          PORTS                     NAMES
a11609898c96        autheg_backend      "bundle"                 About a minute ago   Exited (0) About a minute ago                             autheg_backend_run_1
f088297e9b9b        postgres            "docker-entrypoint.s…"   About a minute ago   Up About a minute               0.0.0.0:32783-&gt;5432/tcp   autheg_db_1

docker volume ls
# DRIVER              VOLUME NAME
# local               64117d4ab46a1d0575cc7136e745cc70bf568cfb3e200c80c69ae035cde89085
</code></pre>

<pre><code>docker-compose run frontend yarn
</code></pre>

<pre><code class="ruby"># docker ps -a
CONTAINER ID        IMAGE               COMMAND                  CREATED                  STATUS                     PORTS                     NAMES
d51e53bd1370        autheg_frontend     "yarn"                   Less than a second ago   Exited (0) 3 seconds ago                             autheg_frontend_run_1
a11609898c96        autheg_backend      "bundle"                 3 minutes ago            Exited (0) 3 minutes ago                             autheg_backend_run_1
f088297e9b9b        postgres            "docker-entrypoint.s…"   3 minutes ago            Up 3 minutes               0.0.0.0:32783-&gt;5432/tcp   autheg_db_1
</code></pre>

<p>要再跑 bundle &amp; yarn 是因為有做 volumes，因此利用 docker 所建立的環境，跑 host 的 bundle &amp; yarn，讓兩邊一致</p>

<blockquote><p>The reason you need to run bundle and yarn after building is because your docker-compose file mounts your host volumes into the containers so you need to install the packages into the host volumes as well as the images that are used to create the containers</p></blockquote>

<h3>編輯 database.yml &amp; package.json</h3>

<pre><code class="diff"> default: &amp;default
   adapter: postgresql
   encoding: unicode
+  host: db
+  username: postgres
</code></pre>

<pre><code class="diff">   "private": true,
   "scripts": {
-    "dev": "nuxt",
+    "dev": "HOST=0.0.0.0 nuxt",
     "build": "nuxt build",
     "start": "nuxt start",
     "generate": "nuxt generate",
</code></pre>

<p><code>HOST=0.0.0.0 nuxt</code> so it’s visible on your host machine</p>

<p>再啟動一個 container 用來建立新資料庫</p>

<pre><code>docker-compose run backend bin/rails db:create
</code></pre>

<p>此時 db 會 create 在，一開始設定的 db container <code>autheg_db_1</code> 裡面，可以</p>

<pre><code class="ruby">docker exec -it autheg_db_1 bash
su - postgres
psql -ls
# 就會看到 create 好的 database
</code></pre>

<p>看一下目前產生的 container</p>

<pre><code class="ruby"># docker ps -a
CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS                     PORTS                     NAMES
85d3ec81e943        autheg_backend      "bin/rails db:create"    6 minutes ago       Exited (0) 6 minutes ago                             autheg_backend_run_2
6e1f7b406a70        autheg_frontend     "yarn"                   7 minutes ago       Exited (0) 7 minutes ago                             autheg_frontend_run_1
55ff63bb46e9        autheg_backend      "bundle"                 25 minutes ago      Exited (0) 8 minutes ago                             autheg_backend_run_1
e889c2e713d0        postgres            "docker-entrypoint.s…"   25 minutes ago      Up 25 minutes              0.0.0.0:32770-&gt;5432/tcp   autheg_db_1
</code></pre>

<p>將所有 container 啟動</p>

<pre><code class="ruby">docker-compose up
# docker-compose stop
# docker-compose down
</code></pre>

<p>就能看到</p>

<ul>
<li>rails : <code>http://localhost:8080/</code></li>
<li>nuxt : <code>http://localhost:3000/</code></li>
</ul>


<p><img src="https://cdn-images-1.medium.com/max/1600/1*hoai7Zion_e9-0uZQGr1Sw.png" alt="" />
<em>from <a href="https://medium.com/@fishpercolator/how-to-separate-frontend-backend-with-rails-api-nuxt-js-and-devise-jwt-cf7dd9da9d16">How to separate frontend + backend with Rails API, Nuxt.js and Devise-JWT</a></em></p>

<h1><span id="part2">Part 2: Getting them talking to each other</span></h1>

<p>新增 table, model, controller</p>

<pre><code class="ruby">docker-compose run backend bash
&gt; bin/rails g resource example name:string colour:string
&gt; bin/rails db:migrate
&gt; bin/rails c
&gt; &gt; {"foo" =&gt; "green", "bar" =&gt; "red", "baz" =&gt; "purple"}.each {|n,c| Example.create!(name: n, colour: c)}
</code></pre>

<p>編輯 controller</p>

<pre><code class="ruby"># autheg-backend/app/controllers/examples_controller.rb
class ExamplesController &lt; ApplicationController
  def index
    examples = Example.all.select(:id, :name, :colour)
    render json: examples
  end
end
</code></pre>

<pre><code class="ruby"># autheg-backend/config/routes.rb
Rails.application.routes.draw do
  scope :api, defaults: { format: :json } do
    resources :examples
  end
end
</code></pre>

<p>這個步驟目前先不做，要等後面安裝 <code>devise</code> 才需要</p>

<pre><code class="ruby"># autheg-backend/app/controllers/application_controller.rb
class ApplicationController &lt; ActionController::API
  include ActionController::MimeResponds
  respond_to :json
end
</code></pre>

<p>現在打 <code>http://localhost:8080/api/examples</code> 就會看到</p>

<p><img src="https://cdn-images-1.medium.com/max/1600/1*76hf6XcYJM_xLdpbd0jZGw.png" alt="" />
<em>from <a href="https://medium.com/@fishpercolator/how-to-separate-frontend-backend-with-rails-api-nuxt-js-and-devise-jwt-cf7dd9da9d16">How to separate frontend + backend with Rails API, Nuxt.js and Devise-JWT</a></em></p>

<p>接著安裝 <a href="https://github.com/axios/axios">axios</a> &amp; <a href="https://vuetifyjs.com/en/">vuetify</a></p>

<pre><code class="ruby">docker-compose run frontend yarn add @nuxtjs/axios @nuxtjs/vuetify
</code></pre>

<p>這邊是 hardcode 在上面，正式機不應該這樣寫</p>

<pre><code class="js">// autheg-frontend/nuxt.config.js
  modules: [
    '@nuxtjs/vuetify',
    '@nuxtjs/axios'
  ],
  axios: {
    host: 'localhost',
    port: 8080,
    prefix: '/api'
  }
</code></pre>

<p>更改畫面</p>

<p>The <code>nuxt</code> option to the link tells it to use Nuxt’s router to handle the link, rather than doing it in the browser.</p>

<pre><code class="js">// autheg-frontend/layouts/default.vue
&lt;template&gt;
  &lt;div id="app"&gt;
    &lt;v-app&gt;
      &lt;v-toolbar app dark&gt;
        &lt;v-toolbar-title&gt;Auth example&lt;/v-toolbar-title&gt;
        &lt;v-spacer /&gt;
        &lt;v-btn icon nuxt href="http://mgleon08.github.com/"&gt;&lt;v-icon&gt;home&lt;/v-icon&gt;&lt;/v-btn&gt;
      &lt;/v-toolbar&gt;
      &lt;v-content&gt;
        &lt;v-container fluid&gt;
          &lt;nuxt/&gt;
        &lt;/v-container&gt;
      &lt;/v-content&gt;
    &lt;/v-app&gt;
  &lt;/div&gt;
&lt;/template&gt;
</code></pre>

<p><code>mounted()</code> 會在 template 初始化的時候呼叫，並且會 call <code>updateExamples()</code> method，去 call <code>/examples</code> API 拿資料回來</p>

<p>```js
// autheg-frontend/pages/index.vue
<template>
  <v-layout>
    <v-flex>
      <v-list>
        <v-list-tile v-for="example in examples" :key="example.id" :class="example.colour">
          <v-list-tile-content></v-list-tile-content>
        </v-list-tile>
      </v-list>
    </v-flex>
  </v-layout>
</template></p>

<script>
export default {
  data () {
    return {
      examples: []
    }
  },
  methods: {
    async updateExamples() {
      this.examples = await this.$axios.$get('/examples')
    }
  },
  mounted () {
    this.updateExamples()
  }
}
</script>


<pre><code>
接著會看到 browser console 會 error，主要是因為 [CROS](https://en.wikipedia.org/wiki/Cross-origin_resource_sharing) 的原因

&gt; JavaScript isn’t allowed to query endpoints on other domains unless those domains set the CORS headers appropriately

![](https://cdn-images-1.medium.com/max/1600/1*5PhACGlQd7cfjiA-DqksuA.png)
*from [How to separate frontend + backend with Rails API, Nuxt.js and Devise-JWT](https://medium.com/@fishpercolator/how-to-separate-frontend-backend-with-rails-api-nuxt-js-and-devise-jwt-cf7dd9da9d16)*

接著要去 `backend` 新增 `cros` 的設定，讓 `frontend` 可以 call

先將 Gemfile 的 comment 打開
</code></pre>

<h1>autheg-backend/Gemfile</h1>

<p>gem &lsquo;rack-cors&rsquo;</p>

<h1>autheg-backend/config/initializers/cors.rb</h1>

<p>Rails.application.config.middleware.insert_before 0, Rack::Cors do
  allow do
    origins &lsquo;localhost:3000&rsquo; # 也可以 * 就是所有 domain 都可以打進來</p>

<pre><code>resource '*',
  headers: :any,
  methods: [:get, :post, :put, :patch, :delete, :options, :head]
</code></pre>

<p>  end
end
```</p>

<p>接著跑</p>

<pre><code>docker-compose run -u root backend bundle
</code></pre>

<p>然後重新起動 container</p>

<pre><code>ctrl + c
docker-compose up
</code></pre>

<p><img src="https://cdn-images-1.medium.com/max/1600/1*LUreZEc1i0c5WfhoDCLxSQ.png" alt="" />
<em>from <a href="https://medium.com/@fishpercolator/how-to-separate-frontend-backend-with-rails-api-nuxt-js-and-devise-jwt-cf7dd9da9d16">How to separate frontend + backend with Rails API, Nuxt.js and Devise-JWT</a></em></p>

<h1><span id="part3">Part 3: Authentication with Devise-JWT</span></h1>

<p>這次要加上 devise 加上 JWT</p>

<ul>
<li><a href="https://jwt.io/">JWT</a></li>
<li><a href="https://github.com/plataformatec/devise">devise</a></li>
<li><a href="https://github.com/waiting-for-dev/devise-jwt">devise-jwt</a></li>
</ul>


<p>先在 Gemfile 新增</p>

<pre><code class="ruby"># autheg-backend/Gemfile
gem 'devise'
gem 'devise-jwt'
</code></pre>

<p>bundle</p>

<pre><code class="ruby">docker-compose run -u root backend bundle
</code></pre>

<p>接著先安裝 devise 參考 <a href="https://github.com/plataformatec/devise#getting-started">getting-started</a></p>

<pre><code class="ruby"># 開新的 container 安裝 devise
docker-compose run backend bash
bin/rails g devise:install
bin/rails g devise user
bin/rails db:migrate
</code></pre>

<p>到這個步驟都還沒用到 <a href="https://jwt.io/">JWT</a>，接下來要要決定如何使令牌無效，原文選擇用 <code>黑名單</code> 的方式</p>

<pre><code class="ruby">bin/rails g model jwt_blacklist jti:string:index exp:datetime
</code></pre>

<p>並將欄位加上 <code>null: false</code> 和移除 <code>t.timestamps</code></p>

<pre><code class="ruby">def change
  create_table :jwt_blacklists do |t|
    t.string :jti, null: false
    t.datetime :exp, null: false
  end
  add_index :jwt_blacklists, :jti
end
</code></pre>

<p>在 model 加上 <code>include Devise::JWT::RevocationStrategies::Blacklist</code></p>

<pre><code class="ruby"># autheg-backend/app/models/jwt_blacklist.rb
class JwtBlacklist &lt; ApplicationRecord
  include Devise::JWT::RevocationStrategies::Blacklist
end
</code></pre>

<h3>secret setting</h3>

<blockquote><p>在這裡遇到個問題 <a href="https://github.com/waiting-for-dev/devise-jwt/issues/56">No implicit conversion of nil into String</a>，主要是用的 rails 版本，與原文章的 ralis(5.1) 不同，導致遇到在 5.2 版本時已經沒有 <code>secrets.yml</code>&hellip; 轉而改用 <code>credentials.yml.enc</code>，所以在這裡記錄一下兩個版本的設定</p></blockquote>

<h3>Before rails 5.2</h3>

<p>接著產生一組 secret，做設定</p>

<pre><code class="ruby">bin/rails secret
# 9dd044df628a496e83c668f..
</code></pre>

<pre><code class="ruby"># autheg-backend/config/secrets.yml
development:
  secret_key_base: xxx
  jwt_secret: 9dd044df628a496e83c668f..

test:
  secret_key_base: xxx
  jwt_secret: 9dd044df628a496e83c668f..

production:
  secret_key_base: &lt;%= ENV["SECRET_KEY_BASE"] %&gt;
  jwt_secret: &lt;%= ENV["JWT_SECRET"] %&gt;
</code></pre>

<pre><code class="ruby"># autheg-backend/config/initializers/devise.rb
config.jwt do |jwt|
  jwt.secret = Rails.application.secrets.jwt_secret
end
</code></pre>

<h3>After rails 5.2</h3>

<ul>
<li><a href="https://medium.com/cedarcode/rails-5-2-credentials-9b3324851336">Rails 5.2 credentials</a></li>
<li><a href="https://www.viget.com/articles/storing-secret-credentials-in-rails-5-2-and-up/">Storing Secret Credentials in Rails 5.2 and Up</a></li>
<li><a href="https://keithpblog.org/post/encrypted-secrets/">Rails 5.2: encrypted secrets</a></li>
</ul>


<pre><code class="ruby">bin/rails secret
# 9dd044df628a496e83c668f..
</code></pre>

<p>這時必須在 console執行 <code>EDITOR="vim" rails credentials:edit</code>，但是在 container 並沒有 <code>vim</code> 和 <code>sudo</code> 這個指令，因此要先切換成 root 去安裝 <code>vim</code> 才有辦法執行</p>

<pre><code class="ruby">docker-compose run -u root backend bash
apt-get update
apt-get install vim -y # 安裝 vim 
EDITOR="vim" bin/rails credentials:edit

# 接著編輯
secret_key_base: xxx
jwt_secret: 9dd044df628a496e83c668f..
</code></pre>

<pre><code class="ruby"># autheg-backend/config/initializers/devise.rb
config.jwt do |jwt|
  jwt.secret = Rails.application.credentials[:jwt_secret]
end
</code></pre>

<p>上面 secret 設定好就可以繼續</p>

<p>設定 <code>response format</code></p>

<pre><code class="ruby"># autheg-backend/app/controllers/application_controller.rb
class ApplicationController &lt; ActionController::API
  include ActionController::MimeResponds
  respond_to :json
end
</code></pre>

<pre><code class="ruby"># autheg-backend/app/models/user.rb
class User &lt; ApplicationRecord
  # Include default devise modules. Others available are:
  # :confirmable, :lockable, :timeoutable and :omniauthable
  devise :database_authenticatable, :registerable,
         :recoverable, :rememberable, :trackable, :validatable,
         :jwt_authenticatable, jwt_revocation_strategy: JwtBlacklist
end
</code></pre>

<p>設定好跑</p>

<pre><code class="ruby">bin/rails db:migrate
</code></pre>

<p>將 router 的 <code>devise_scope :user</code> 移到 api scope 裡面</p>

<pre><code class="ruby">Rails.application.routes.draw do
  # For details on the DSL available within this file, see http://guides.rubyonrails.org/routing.html
  scope :api, defaults: { format: :json } do
    resources :examples
    devise_for :users
  end
end
</code></pre>

<p>restart containers</p>

<pre><code>ctrl + c
docker-compose up
</code></pre>

<p>console 新增一個 User</p>

<pre><code class="ruby">bin/rails c
User.create!(email: 'test@example.com', password: 'password')
</code></pre>

<p>接下來就可以來測試 <code>user login</code> 原文推薦使用 <a href="http://yet-another-rest-client.com/">YARC</a> 不過個人偏好 <a href="https://www.getpostman.com/">Postman</a>，都可以</p>

<pre><code class="ruby">POST /api/users/sign_in

{  
   "user":{  
      "email":"test@example.com",
      "password":"password"
   }
}
</code></pre>

<p><img src="https://cdn-images-1.medium.com/max/1600/1*2cTvgN1s2-6VkCLknzuwXQ.png" alt="" />
<em>from <a href="https://medium.com/@fishpercolator/how-to-separate-frontend-backend-with-rails-api-nuxt-js-and-devise-jwt-cf7dd9da9d16">How to separate frontend + backend with Rails API, Nuxt.js and Devise-JWT</a></em></p>

<p>這裡可以看到 Response Headers 多了一個欄位</p>

<pre><code class="ruby"># 原本

{
  "x-runtime": "0.496080",
  "etag": "W/\"9a9c93785c7d5e5890c3189efa33ca10\"",
  "vary": "Origin",
  "content-type": "application/json; charset=utf-8",
  "location": "/",
  "cache-control": "max-age=0, private, must-revalidate",
  "transfer-encoding": "chunked",
  "x-request-id": "c6a59d67-2551-496f-8f99-f69c5b79bd75",
  "status": 201
}

# 加上 jwt

{
  "x-runtime": "0.998534",
  "etag": "W/\"d2403cf91d814bea7a094efecd1e0ae9\"",
  "authorization": "Bearer eyJhbGciOiJIUzI1NiJ9.eyJzdWIiOiIxIiwic2NwIjoidXNlciIsImF1ZCI6bnVsbCwiaWF0IjoxNTMxNjY2NjA0LCJleHAiOjE1MzE2NzAyMDQsImp0aSI6ImYzMjkxMWViLTY0ZDEtNDU0NS1iNGJjLTQ5MjE2NjQwMDc1OCJ9.nP5vGhbiPfC5acnQOusY_bEZCAWF2TZ29vq28SMUX2U",
  "vary": "Origin",
  "content-type": "application/json; charset=utf-8",
  "location": "/",
  "cache-control": "max-age=0, private, must-revalidate",
  "transfer-encoding": "chunked",
  "x-request-id": "4eec0e2f-5cb5-4c4d-9ed9-be9385c79a5d",
  "status": 201
}
</code></pre>

<p>接著要來覆蓋掉 devise 原本的 session controller，讓我們可以將 jwt 加進去</p>

<p>先 generate devise 內建的 sessino controller</p>

<pre><code class="ruby">bin/rails generate devise:controllers users -c=sessions
</code></pre>

<p>並且新增一個 router，已便可以拿到 user 的 detail 資訊</p>

<blockquote><p>這裡跟原文章不太一樣，這邊是藉由 devise 內建的 generate 產生 session controller file，是放在 app/controller/users/sessions_controller.rb，原文章應該是自行建立的檔案放在 app/controller/sessions_controller.rb，因此底下的 router 設定也會有稍微不同</p></blockquote>

<pre><code class="ruby"># autheg-backend/config/routes.rb
Rails.application.routes.draw do
  scope :api, defaults: { format: :json } do
    resources :examples
    devise_for :users, controllers: { sessions: 'users/sessions' }
    devise_scope :user do
      get 'users/current', to: 'users/sessions#show'
    end
  end
end
</code></pre>

<p>將 Gemfile 裡的 <code>jbuilder</code> gem 打開</p>

<pre><code class="ruby"># Gemfile
gem 'jbuilder', '~&gt; 2.5'
</code></pre>

<pre><code class="ruby">docker-compose run -u root backend bundle
# restart containers
docker-compose up
</code></pre>

<pre><code class="ruby"># autheg-backend/app/controllers/users/sessions_controller.rb
class Users::SessionsController &lt; Devise::SessionsController
  def create
    super { @token = current_token }
  end

  def show
  end

  private

  def current_token
    request.env['warden-jwt_auth.token']
  end
end
</code></pre>

<pre><code class="ruby"># autheg-backend/app/views/users/create.json.jbuilder
json.token @token
</code></pre>

<pre><code class="ruby"># autheg-backend/app/views/users/show.json.jbuilder
if user_signed_in?
  json.user do
    json.(current_user, :id, :email)
  end
end
</code></pre>

<p>接下來可以測試 login 了</p>

<pre><code class="ruby"># 登入拿 token
POST /api/users/sign_in

{  
   "user":{  
      "email":"test@example.com",
      "password":"password"
   }
}

# 在 Header 加上剛剛登入拿到的 token
# "authorization": "Bearer eyJhbGciOiJIUzI1NiJ9.eyJzdW ..."
GET /api/users/current

# 登出，記得也要帶 token 才知道誰要登出
# "authorization": "Bearer eyJhbGciOiJIUzI1NiJ9.eyJzdW ..."
DELETE /api/users/sign_out
</code></pre>

<p>測試 ok 後，接下來在 <code>ExamplesController</code> 加上 <code>authentication</code></p>

<pre><code class="ruby"># autheg-backend/app/controllers/examples_controller.rb
class ExamplesController &lt; ApplicationController
  before_action :authenticate_user!

  def index
    examples = Example.all.select(:id, :name, :colour)
    render json: examples
  end
end
</code></pre>

<p>這時 <code>GET /api/examples</code> 就必須帶 <code>token</code> 否則會 <code>error</code></p>

<pre><code class="ruby">GET /api/examples

{
  "error": "You need to sign in or sign up before continuing."
}
</code></pre>

<p>接下來回到 frontend，會發現 <code>401 Unauthorized error</code> 所以要在 frontend 加上 <code>authentication</code></p>

<p>新增後端 <code>sign_in</code> <code>sign_out</code> <code>detail</code> API &amp; <code>@nuxtjs/auth</code></p>

<pre><code>docker-compose run frontend yarn add @nuxtjs/auth
</code></pre>

<pre><code class="js">// autheg-frontend/nuxt.config.js
modules: [
  '@nuxtjs/vuetify',
  '@nuxtjs/axios',
  '@nuxtjs/auth'
],
auth: {
  endpoints: {
    login:  { url: '/users/sign_in' },
    logout: { url: '/users/sign_out', method: 'delete' },
    user:   { url: '/users/current' }
  }
}
</code></pre>

<pre><code class="js">// autheg-frontend/store/index.js
export default {
  state: () =&gt; ({
  })
}
</code></pre>

<p>restart container 讓 frontend 吃到剛剛的設定</p>

<p>```js
// autheg-frontend/pages/login.vue</p>

<p><template>
  <v-layout>
    <v-flex>
      <v-card v-if="$auth.state.loggedIn">
        <v-alert type="error" :value="error"></v-alert>
        <v-card-text>
          Logged in as 
        </v-card-text>
        <v-card-actions>
          <v-btn @click="logout">Log out</v-btn>
        </v-card-actions>
      </v-card>
      <v-card v-else>
        <v-alert type="error" :value="error"></v-alert>
        <v-card-text>
          <v-form>
            <v-text-field v-model="email" label="Email" />
            <v-text-field v-model="password" label="Password" type="password" />
          </v-form>
          <v-card-actions>
            <v-btn @click="login">Log in</v-btn>
          </v-card-actions>
        </v-card-text>
      </v-card>
    </v-flex>
  </v-layout>
</template></p>

<script>
export default {
  data () {
    return {
      email: '',
      password: '',
      error: null
    }
  },
  methods: {
    login: function () {
      this.$auth.login({
        data: {
          user: {
            email: this.email,
            password: this.password
          }
        }
      }).catch(e => {this.error = e + ''})
    },
    logout: function () {
      this.$auth.logout().catch(e => {this.error = e + ''})
    }
  }
}
</script>


<pre><code>
現在可以到 `/login` 試試看登入了

如果想要讓 user 沒有 login 的狀態下都 redirect 到 `login page` 就加上
</code></pre>

<p>// autheg-frontend/pages/index.vue
<template>
  <v-layout>
    <v-flex>
      <v-list>
        <v-list-tile v-for="example in examples" :key="example.id" :class="example.colour">
          <v-list-tile-content></v-list-tile-content>
        </v-list-tile>
      </v-list>
    </v-flex>
  </v-layout>
</template></p>

<script>
export default {
  middleware: ['auth'],
  data () {
    return {
      examples: []
    }
  },
  methods: {
    async updateExamples() {
      this.examples = await this.$axios.$get('/examples')
    }
  },
  mounted () {
    this.updateExamples()
  }
}
</script>


<p>```</p>

<p>現在可以 try 一下</p>

<p><img src="https://cdn-images-1.medium.com/max/1600/1*012-LUDxJttnF6Jtn0Cm7A.png" alt="" />
<em>from <a href="https://medium.com/@fishpercolator/how-to-separate-frontend-backend-with-rails-api-nuxt-js-and-devise-jwt-cf7dd9da9d16">How to separate frontend + backend with Rails API, Nuxt.js and Devise-JWT</a></em></p>

<p><img src="https://cdn-images-1.medium.com/max/1600/1*X7EYUzlYqfSEDGUlTaK7vQ.png" alt="" />
<em>from <a href="https://medium.com/@fishpercolator/how-to-separate-frontend-backend-with-rails-api-nuxt-js-and-devise-jwt-cf7dd9da9d16">How to separate frontend + backend with Rails API, Nuxt.js and Devise-JWT</a></em></p>

<p>參考文件</p>

<ul>
<li><a href="https://medium.com/@fishpercolator/how-to-separate-frontend-backend-with-rails-api-nuxt-js-and-devise-jwt-cf7dd9da9d16">How to separate frontend + backend with Rails API, Nuxt.js and Devise-JWT</a></li>
<li><a href="https://medium.com/@fishpercolator/deploying-your-nuxt-rails-api-app-to-production-with-heroku-54efd09eec22">Deploying your Nuxt+Rails API app to production with Heroku</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
