<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Rails | Leon's Blogging]]></title>
  <link href="http://mgleon08.github.com/blog/categories/rails/atom.xml" rel="self"/>
  <link href="http://mgleon08.github.com/"/>
  <updated>2018-08-07T21:22:32+08:00</updated>
  <id>http://mgleon08.github.com/</id>
  <author>
    <name><![CDATA[LeonJi]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Nothing Is Something by Sandi Metz]]></title>
    <link href="http://mgleon08.github.com/blog/2018/07/26/nothing-is-something-by-sandi-metz/"/>
    <updated>2018-07-26T21:36:02+08:00</updated>
    <id>http://mgleon08.github.com/blog/2018/07/26/nothing-is-something-by-sandi-metz</id>
    <content type="html"><![CDATA[<p>這是 Sandi Metz 2015 的演講，雖然有點舊，但還是很不錯，來紀錄一下</p>

<!-- more -->


<h3>Smalltalk Infected</h3>

<p>一開始先介紹 <code>if</code> 可以改寫為自己的 method</p>

<pre><code class="ruby">true.class # TrueClass
false.class # FalseClass
</code></pre>

<pre><code class="ruby">class TrueClass
 def if_true
    yield
    self
 end

 def if_false
    self
 end
end

class FalseClass
 def if_true
    self
 end

 def if_false
    yield
    self
 end
end
</code></pre>

<pre><code class="ruby">(1 == 1).if_true{ puts "evaluated block" }
evaluated block
# =&gt; true
</code></pre>

<p>接下來改寫為 <code>Object</code> <code>FalseClass</code> <code>NilClass</code> 因為在 ruby 的世界中，除了 <code>false</code> 和 <code>nil</code> 是 &ldquo;Falsy"，其他都是 "truthy&rdquo;</p>

<pre><code class="ruby">class Object
 def if_true
    yield
    self
 end

 def if_false
    self
 end
end

class FalseClass
 def if_true
    self
 end

 def if_false
    yield
    self
 end
end

class NilClass
 def if_true
    self
 end

 def NilClass
    yield
    self
 end
end
</code></pre>

<pre><code class="ruby">(1==1).if_true{ puts 'a' }.if_false{ puts'b' }
a
# true
</code></pre>

<p>但我們並不想改寫 ruby 原本就有的 method，而是將上面的技巧應用在需要的地方</p>

<h3>Condition Averse</h3>

<p>Sometimes nil is nothing</p>

<pre><code class="ruby">ids = ['pig', '', 'sheep']
animals = ids.map {|id| Animal.find(id)}
# =&gt; [#&lt;Animal:0x007f94b290ae90 @name="pig"&gt;, nil,
     #&lt;Animal:0x007f94b290ae18 @name="sheep"&gt;]

animals.each { |animal| puts animal.name }
# =&gt; 'pig'
# NoMethodError: undefined method `name' for nil:NilClass

animals.each { |animal| puts animal.nil? ? 'no animal' : animal.name }
# =&gt; 'pig'
#    'no animal'
#    'sheep'

animals.each { |animal| puts animal &amp;&amp; animal.name }
animals.each { |animal| puts animal.try(:name) }
animals.each { |animal| puts animal.nil? ? '' : animal.name }
animals.each { |animal| puts animal == nil ? '' : animal.name }
animals.each { |animal| puts animal.is_a?(NilClass) ? '' : animal.name }
# =&gt; 'pig'
#    empty string
#    'sheep'
</code></pre>

<h3>Message Centric</h3>

<p>新增 <code>MissingAnimal</code> class</p>

<pre><code class="ruby">class Animal
  def name
    ...
  end 
end

class MissingAnimal 
  def name
    'no animal'
  end 
end

ids = ['pig', '', 'sheep']
animals = ids.map {|id| Animal.find(id) || MissingAnimal.new}
# =&gt; [#&lt;Animal: @name="pig"&gt;, #&lt;MissingAnimal:&gt;, #&lt;Animal: @name="sheep"&gt;]

animals.each { |animal| puts animal.name } 
# =&gt; 'pig'
#    'no animal'
#    'sheep'
</code></pre>

<p>但是這樣反而對 <code>MissingAnimal</code> 會有 dependency，接著在外面再包一層，將 dependency 封裝起來</p>

<pre><code class="ruby">class GuaranteedAnimal 
  def self.find(id)
    Animal.find(id) || MissingAnimal.new 
  end
end

animals = ids.map { |id|GuaranteedAnimal.find(id) }
# =&gt; [#&lt;Animal: @name="pig"&gt;, 
      #&lt;MissingAnimal:&gt;,
      #&lt;Animal: @name="sheep"&gt;]

animals.each {|animal| puts animal.name }
# =&gt; 'pig'
#    'no animal'
#    'sheep'
</code></pre>

<h3>Abstraction Seeking</h3>

<pre><code class="ruby">class House
  def recite
    (1..data.length).map { |i| line(i) }.join("\n")
  end

  def line(number)
    "This is #{phrase(number)}.\n"
  end

  def phrase(number) 
    parts(number).join(" ")
  end

  def parts(number) 
    data.last(number)
  end

  def data
    [ 'the horse and the hound and the horn that belonged to',
    # ...
    'the malt that lay in',
    'the house that Jack built']
  end
end
</code></pre>

<p>接著 Implement <code>RandomHouse</code> <code>EchoHouse</code> without &lsquo;if&rsquo; statements</p>

<p>用繼承 Inheritance?</p>

<pre><code class="ruby">class RandomHouse &lt; House 
  def data
    @data ||= super.shuffle 
  end
end

class EchoHouse &lt; House 
  def parts(number)
    super.zip(super).flatten 
  end
end
</code></pre>

<p>但這樣一個要改寫 <code>data</code> 另一個改寫 <code>parts</code>，當有新需求 <code>RandomEchoHouse</code>，那不就要這兩個 method 在寫一次，也不可能只繼承其中一個</p>

<blockquote><p>Inheritance is for specialization is not for sharing code</p></blockquote>

<p>改用組合 Composition 的方式來處理</p>

<pre><code class="ruby">class House 
  attr_reader :formatter, :data

  def initialize(orderer: DefaultOrder.new, formatter: DefaultFormatter.new) 
    @formatter = formatter
    @data = orderer.order(DATA)
  end

  def parts(number) 
    formatter.format(data.last(number))
  end
  # ...
end

class DefaultOrder 
  def order(data)
    data
  end 
end

class RandomOrder 
  def order(data)
    data.shuffle 
  end
end

class DefaultFormatter 
  def format(parts)
    parts
  end 
end

class EchoFormatter 
  def format(parts)
    parts.zip(parts).flatten 
  end
end


House.new(orderer: RandomOrder.new).line(12)
House.new(formatter: EchoFormatter.new).line(12)
</code></pre>

<p>參考文件</p>

<ul>
<li><a href="https://www.youtube.com/watch?v=OMPfEXIlTVE">[Video]RailsConf 2015 - Nothing is Something</a></li>
<li><a href="https://speakerdeck.com/skmetz/nothing-is-something-railsconf">[Silde] RailsConf 2015 - Nothing is Something</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[TaiwanUserID 台灣身分證字號驗證]]></title>
    <link href="http://mgleon08.github.com/blog/2018/07/24/taiwan-user-id/"/>
    <updated>2018-07-24T21:38:14+08:00</updated>
    <id>http://mgleon08.github.com/blog/2018/07/24/taiwan-user-id</id>
    <content type="html"><![CDATA[<p>你知道台灣身分證字號是怎麼算出來的嗎?</p>

<!-- more -->


<p>剛好公司同事有寫到，蠻有趣的來紀錄一下，要快還是要用 <code>while</code> 阿~</p>

<h1>公式</h1>

<pre><code>戶籍代表的字母數字：
Ａ台北市-10 Ｂ台中市-11 Ｃ基隆市-12 Ｄ台南市-13 Ｅ高雄市-14 Ｆ台北縣-15
Ｇ宜蘭縣-16 Ｈ桃園縣-17 Ｉ嘉義市-34 Ｊ新竹縣-18 Ｋ苗栗縣-19 Ｌ台中縣-20
Ｍ南投縣-21 Ｎ彰化縣-22 Ｏ新竹市-35 Ｐ雲林縣-23 Ｑ嘉義縣-24 Ｒ台南縣-25
Ｓ高雄縣-26 Ｔ屏東縣-27 Ｕ花蓮縣-28 Ｖ台東縣-29 Ｗ金門縣-32 Ｘ澎湖縣-30
Ｙ陽明山-31 Ｚ連江縣-33

公式
A123456789 -&gt; 10123456789

1   0   1    2    3    4    5    6    7   8   9 (拆解字母後的數字)
*   *   *    *    *    *    *    *    *   *   *
1   9   8    7    6    5    4    3    2   1   1 (固定係數)
-----------------------------------------------
1 + 0 + 8 + 14 + 18 + 20 + 20 + 18 + 14 + 8 + 9 = 130

130 % 10 == 0
</code></pre>

<h1>Code</h1>

<pre><code class="ruby">require 'benchmark'

LOCATION_CODE = {
  'A' =&gt; [1, 0], 'B' =&gt; [1, 1], 'C' =&gt; [1, 2], 'D' =&gt; [1, 3], 'E' =&gt; [1, 4], 'F' =&gt; [1, 5], 'G' =&gt; [1, 6], 'H' =&gt; [1, 7], 'I' =&gt; [3, 4],
  'J' =&gt; [1, 8], 'K' =&gt; [1, 9], 'L' =&gt; [2, 0], 'M' =&gt; [2, 1], 'N' =&gt; [2, 2], 'O' =&gt; [3, 5], 'P' =&gt; [2, 3], 'Q' =&gt; [2, 4], 'R' =&gt; [2, 5],
  'S' =&gt; [2, 6], 'T' =&gt; [2, 7], 'U' =&gt; [2, 8], 'V' =&gt; [2, 9], 'W' =&gt; [3, 2], 'X' =&gt; [3, 0], 'Y' =&gt; [3, 1], 'Z' =&gt; [3, 3]
}

MULTIPLIER = [1, 9, 8, 7, 6, 5, 4, 3, 2, 1, 1]

def id_card_validate(id)
  return false unless id =~ /\A[A-Z](1|2)\d{8}\z/
  chars = id.chars
  numbers = LOCATION_CODE[chars.shift] + chars.map(&amp;:to_i)
  sum = numbers.zip(MULTIPLIER).map{ |a, b| a * b }.reduce(:+)
  # sum, i = 0, 0
  # while i &lt;= 10
  #   sum += numbers[i] * MULTIPLIER[i]
  #   i += 1
  # end
  (sum % 10).zero?
end

n = 100000
Benchmark.bmbm do |x|
  x.report('leonji'){ n.times{ id_card_validate('A123456789') } }
end

# Rehearsal ------------------------------------------
# leonji   0.770000   0.010000   0.780000 (  0.796012)
# --------------------------------- total: 0.780000sec

#              user     system      total        real
# leonji   0.770000   0.000000   0.770000 (  0.792737)
</code></pre>

<p>參考文件</p>

<ul>
<li><a href="http://tzoyiing.pixnet.net/blog/post/29821245-%5B%E8%BD%89%E8%B2%BC%5D-%E8%BA%AB%E4%BB%BD%E8%A8%BC%E5%AD%97%E8%99%9F%E7%B7%A8%E7%A2%BC%E5%85%AC%E5%BC%8F%E8%AA%AA%E6%98%8E~%E6%95%99%E4%BD%A0%E5%A6%82%E4%BD%95%E9%A9%97">[轉貼] 身份證字號編碼公式說明~教你如何驗證</a></li>
<li><a href="https://tonytonyjan.net/2015/04/15/national-identification-card-validator-of-taiwan/">台灣身份證字號驗證器</a></li>
<li><a href="https://github.com/wayne5540/taiwanese_id_builder">taiwanese_id_builder</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Environment Banner]]></title>
    <link href="http://mgleon08.github.com/blog/2018/07/23/environment-banner/"/>
    <updated>2018-07-23T21:35:24+08:00</updated>
    <id>http://mgleon08.github.com/blog/2018/07/23/environment-banner</id>
    <content type="html"><![CDATA[<p>可以很快速的知道目前環境上的版本是什麼</p>

<!-- more -->


<p>公司因為多台機器不同環境，因此有同事做了一個 <code>Environment banner</code>，可以很方便地知道目前是哪一個 branch 哪一個 版本，這邊就來記錄一下</p>

<pre><code class="ruby"># app/helpers/environment_banner_helper.rb
module EnvironmentBannerHelper
  RELEASE_INFO_PATH = Rails.public_path.join('release_info')

  def current_branch
    if git_available?
      # 讀取當前 HEAD 所在的 branch 名稱
      `git rev-parse --abbrev-ref HEAD`.chomp
    else
      # 當在 deploy 的時候，無法用 git (除非另外裝)，因此可以先將資訊存放在某的檔案，或是環境變數
      git_info[:branch] # 檔案
      # ENV.fetch("CURRENT_BRANCH", "--branch-not-found--") # ENV
    end
  end

  def current_sha
    if git_available?
      # 讀取當前的 log 最新一行
      `git log --oneline -1`
    else
      # 當在 deploy 的時候，無法用 git (除非另外裝)，因此可以先將資訊存放在某的檔案，或是環境變數
      git_info[:sha] # 檔案
      # ENV.fetch("CURRENT_SHA", "--sha-not-found--") # ENV
    end
  end

  # 確認當前環境有沒有 git
  def git_available?
    to_dev_null = "&gt; /dev/null 2&gt;&amp;1"
    system("which git #{to_dev_null} &amp;&amp; git rev-parse --git-dir #{to_dev_null}")
  end

  # 主要是為了 capistrano 上面會有不同的 release 資料夾
  def release_number
    return unless check_release_info &amp;&amp; IO.readlines(RELEASE_INFO_PATH)[0]
    IO.readlines(RELEASE_INFO_PATH)[0].gsub(/\D/, '').prepend('#')
  end

  def git_info
    return { sha: "N/A", branch: "N/A"} unless check_release_info &amp;&amp; IO.readlines(RELEASE_INFO_PATH)[1]
    line = IO.readlines(RELEASE_INFO_PATH)[1].split(/\s+/)
    {
      sha:    line[0][0..6],
      branch: line[1].gsub(/refs\/heads\//, '')
    }
  end

  def check_release_info
    File.exist? RELEASE_INFO_PATH
  end
end
</code></pre>

<pre><code class="ruby"># app/views/layouts/application.html.erb
&lt;% unless Rails.env.production? %&gt;
  &lt;div class="environment-banner &lt;%= Rails.env %&gt;"&gt;
    &lt;%= Rails.env %&gt; | &lt;%= "#{current_branch} @ #{current_sha} #{release_number}" %&gt;
  &lt;/div&gt;
&lt;% end %&gt;
</code></pre>

<pre><code class="css">/* app/assets/stylesheets/application.scss */
.environment-banner.development {
  background: $green;
  color: $white;
}
</code></pre>

<p>capistrano deploy 時新增 <code>release_info</code> 檔案方式</p>

<pre><code class="ruby">set :repo_url, 'git@github.com:xxx/xxx.git'
ask :branch, `git rev-parse --abbrev-ref HEAD`.chomp

# 將所有 git 撞況寫到一個 file 上，再透過該 file 來顯示
# readlink 可以找到實際檔案位置，awk 分析出路徑上最後的 release 資料夾名稱
execute("echo current_release: `readlink -f #{release_path} | awk -F'/' '{print $NF}'` &gt; #{shared_path.join('public/release_info')}")
# header
execute("git ls-remote -h #{fetch(:repo_url)} #{fetch(:branch)} &gt;&gt; #{shared_path.join('public/release_info')}")
# tag
execute("git ls-remote -t #{fetch(:repo_url)} | tail -n 1 &gt;&gt; #{shared_path.join('public/release_info')}")
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Deploying Rails API + Nuxt.js + Devise-JWT API App to Production With Heroku]]></title>
    <link href="http://mgleon08.github.com/blog/2018/07/22/deploying-rails-nuxt-jwt-to-production-with-heroku/"/>
    <updated>2018-07-22T23:12:48+08:00</updated>
    <id>http://mgleon08.github.com/blog/2018/07/22/deploying-rails-nuxt-jwt-to-production-with-heroku</id>
    <content type="html"><![CDATA[<p>接著來把做好的 <code>Rails API + Nuxt.js + Devise-JWT</code> deploy 到 heroku</p>

<!-- more -->


<ul>
<li><a href="https://medium.com/@fishpercolator/deploying-your-nuxt-rails-api-app-to-production-with-heroku-54efd09eec22">Deploying your Nuxt+Rails API app to production with Heroku</a></li>
</ul>


<p>由於一開始我們希望用 docker-compose 來 build 環境，因此將前後端都 commit 在一起，但在部屬的時候希望將兩個分開，這時就可以用到 <code>git subtree</code></p>

<p><a href="https://heroku.com"><img src="https://www.herokucdn.com/deploy/button.svg" alt="Deploy" /></a></p>

<h1>Backend</h1>

<p>Rails5.2 必須先將 <code>production</code> 的 <code>config.require_master_key</code> 打開</p>

<pre><code class="ruby"># autheg-backend/config/environments/production.rb
config.require_master_key = true
</code></pre>

<p>記得要把 <code>cors.rb</code> 設定成 herokuapp 的 domain (根據前端專案的名稱)</p>

<pre><code class="ruby"># autheg-backend/config/initializers/cors.rb
origins 'localhost:3000', 'autheg-frontend-demo.herokuapp.com'
# or
origins '*'
</code></pre>

<p>安裝 <a href="https://devcenter.heroku.com/articles/heroku-cli">heroku-cli</a></p>

<pre><code class="ruby">brew install heroku/brew/heroku
</code></pre>

<p>create backend 的 heroku 專案</p>

<pre><code class="ruby"># 先到最上層的資料夾
cd autheg
# 如果看到這個 "Name is already taken"，就換一個名字即可
heroku apps:create autheg-backend-demo
</code></pre>

<p>預設 remote name 會是 heroku，因為等下要在 create frontend remote，因此先改名</p>

<pre><code class="ruby"># 更改 local 的 remote name
git remote rename heroku backend
</code></pre>

<p>將後端 autheg-backend push 上去</p>

<pre><code class="ruby"># 透過 subtree 先將後端 autheg-backend push 上去
git subtree push --prefix autheg-backend backend master
</code></pre>

<p>建立環境變數</p>

<pre><code class="ruby">heroku config:set -a autheg-backend-demo RAILS_MASTER_KEY=(local 裡面的 config.master.key)

heroku config:set -a autheg-backend-demo JWT_SECRET=$(heroku run -a autheg-backend-demo rails secret)
</code></pre>

<p>建立 table data</p>

<pre><code class="ruby">heroku run -a autheg-backend-demo rails db:schema:load
</code></pre>

<p>新增 db 資料</p>

<pre><code class="ruby">heroku run -a autheg-backend-demo rails console

# user
User.create! email: "test@example.com", password: "password"

# example
{"foo" =&gt; "green", "bar" =&gt; "red", "baz" =&gt; "purple"}.each {|n,c| Example.create!(name: n, colour: c)}
</code></pre>

<p>接下來就可以透過 <a href="http://yet-another-rest-client.com/">YARC</a> or <a href="https://www.getpostman.com/">Postman</a> 來測試有沒有成功!</p>

<pre><code class="ruby">POST https://autheg-backend-demo.herokuapp.com/api/users/sign_in

{
   "user":{
      "email":"test@example.com",
      "password":"password"
   }
}
</code></pre>

<h1>Frontend</h1>

<p><a href="https://github.com/nuxt/docs/blob/master/en/faq/heroku-deployment.md">nuxt heroku-deployment</a></p>

<p>create frontend 的 heroku 專案</p>

<pre><code class="ruby"># 先到最上層的資料夾
cd autheg
# 如果看到這個 "Name is already taken"，就換一個名字即可
heroku apps:create autheg-frontend-demo
</code></pre>

<p>rename remote name</p>

<pre><code class="ruby">git remote rename heroku frontend
</code></pre>

<p>設定環境變數，要跑在 production 模式，因此要將之前安裝在 dev 環境中的套件，安裝上去</p>

<blockquote><p>The following command tells your app to run in production mode and on all interfaces (0.0.0.0) but tells yarn/npm to run in development mode, so that all the dev packages are installed as part of the build process.</p></blockquote>

<pre><code class="ruby">heroku config:set -a autheg-frontend-demo NODE_ENV=production HOST=0.0.0.0 NPM_CONFIG_PRODUCTION=false
</code></pre>

<p>改一下 <code>package.json</code>，讓 heroku deploy 之後可以 build 檔案出來</p>

<pre><code class="ruby">"heroku-postbuild": "npm run build"
</code></pre>

<p>設定 backend 的 API 路徑</p>

<pre><code class="ruby">heroku config:set -a autheg-frontend-demo API_URL=https://autheg-backend-demo.herokuapp.com/api
</code></pre>

<p>接著就可以到首頁上去測試了</p>

<pre><code class="ruby">https://autheg-frontend-demo.herokuapp.com/
# email: test@example.com
# password: password
</code></pre>

<h1>Heroku</h1>

<p>其他 heroku 功能</p>

<pre><code class="ruby"># create new heroku project
heroku create

# push heroku
git push heroku master

# env config remove
heroku config:remove TOKEN

# log
heroku logs --tail

# scale
heroku ps:scale web=2

# ssh
heroku run -a autheg-backend bash

# run 指令
heroku run -a autheg-backend-demo rails console
</code></pre>

<h1>git subtree</h1>

<p>git subtree 本身不支援 force push，因此要透過其他方式來達成</p>

<ul>
<li><a href="https://gist.github.com/tduarte/eac064b4778711b116bb827f8c9bef7b">publish-ghpages.md</a></li>
</ul>


<pre><code class="ruby">git checkout master # you can avoid this line if you are in master...
git subtree split --prefix dist -b gh-pages # create a local gh-pages branch containing the splitted output folder
git push -f origin gh-pages:gh-pages # force the push of the gh-pages branch to the remote gh-pages branch at origin
git branch -D gh-pages # delete the local gh-pages because you will need it: ref
</code></pre>

<p>參考文件</p>

<ul>
<li><a href="https://medium.com/@fishpercolator/deploying-your-nuxt-rails-api-app-to-production-with-heroku-54efd09eec22">Deploying your Nuxt+Rails API app to production with Heroku</a></li>
<li><a href="https://hexo.crboy.net/2016/09/amazing-git-subtree/">神奇的 Git Subtree</a></li>
<li><a href="http://yutin.logdown.com/posts/188306-git-subtree-total-addendum-library">Git SubTree 共編 Library</a></li>
<li><a href="http://erning.net/blog/2012/05/09/the-twelve-factor-app/">The Twelve-Factor App</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Rails API + Nuxt.js + Devise-JWT]]></title>
    <link href="http://mgleon08.github.com/blog/2018/07/17/rails-nuxt-jwt/"/>
    <updated>2018-07-17T17:39:32+08:00</updated>
    <id>http://mgleon08.github.com/blog/2018/07/17/rails-nuxt-jwt</id>
    <content type="html"><![CDATA[<p>在網路上發現這篇文章，覺得寫得很不錯，所以這次就跟著這篇一起做一遍~</p>

<!-- more-->


<p><a href="https://medium.com/@fishpercolator/how-to-separate-frontend-backend-with-rails-api-nuxt-js-and-devise-jwt-cf7dd9da9d16">How to separate frontend + backend with Rails API, Nuxt.js and Devise-JWT</a></p>

<p>來學習，<code>Rails API / Nuxt.js / JWT / Docker</code></p>

<ul>
<li><a href="#part1">Part 1: Creating a development environment</a></li>
<li><a href="#part2">Part 2: Getting them talking to each other</a></li>
<li><a href="#part3">Part 3: Authentication with Devise-JWT</a></li>
</ul>


<h1><span id="part1">Part 1: Creating a development environment</span></h1>

<pre><code class="ruby"># backend
mkdir autheg
cd autheg
rails new autheg-backend -T --skip-spring -C -B -d postgresql --api
# -T = skip test
# -C = skip action cable
# -B = skip bundle 主要是作者要跑在 docker 裡面
# --api = 沒有任何 view 純 API server

#frontend
vue init nuxt-community/starter-template autheg-frontend
cd autheg-frontend
yarn generate-lock-entry &gt; yarn.lock
# 跟 -B 類似，為了不 install
</code></pre>

<h3>backend</h3>

<pre><code class="ruby"># autheg/autheg-backend/Dockerfile
FROM ruby:2.5

ARG UID 
RUN adduser rails --uid $UID --disabled-password --gecos ""
# 可以透過 $UID 給予不同的 user ID，並且進到任何的 container 都可以用相同的 user ID
# --disabled-password - 讓 rails 無法用密碼登入

ENV APP /usr/src/app
RUN mkdir $APP
WORKDIR $APP

COPY Gemfile* $APP/
RUN bundle install -j3 --path vendor/bundle
# Gems and yarn packages are installed into the mounted volumes. 
# This will stop you from needing to rebuild the whole Docker image every time you change the Gemfile or package.json.

COPY . $APP/

CMD ["bin/rails", "server", "-p", "8080", "-b", "0.0.0.0"]
# 這裡原本是 rails，但實際在 run 的時候會有 error，因此改為 bin/rails
</code></pre>

<p><code>.dockerignore</code> 避免 Docker 在 build 的時候，一併複製過去</p>

<pre><code class="ruby"># autheg/autheg-backend/.dockerignore
/vendor/bundle
/log
/tmp
</code></pre>

<pre><code class="ruby"># autheg/autheg-backend/.gitignore
/vendor/bundle/
</code></pre>

<h3>frontend</h3>

<pre><code class="ruby"># autheg/autheg-frontend/Dockerfile

FROM node:9

ARG UID
RUN adduser frontend --uid $UID --disabled-password --gecos ""

ENV APP /usr/src/app
RUN mkdir $APP
WORKDIR $APP

COPY package.json yarn.lock $APP/
RUN yarn
# Gems and yarn packages are installed into the mounted volumes. 
# This will stop you from needing to rebuild the whole Docker image every time you change the Gemfile or package.json.

COPY . $APP/

CMD ["yarn", "run", "dev"]
</code></pre>

<p><code>.dockerignore</code> 避免 Docker 在 build 的時候，一併複製過去</p>

<pre><code class="ruby"># autheg/autheg-frontend/.dockerignore
/node_modules/
</code></pre>

<h3>all</h3>

<pre><code class="ruby"># autheg/docker-compose.yml

version: '3' # dockerfile 版本 
services:
  db: # 對應 rails database.yml 的 host
    image: postgres
    ports:
      - "5432"
  backend: # 會變成 REPOSITORY name autheg_backend
    build:
      context: autheg-backend # 要 build 的資料夾位置
      args:
        UID: ${UID:-1001}
    volumes:
      - ./autheg-backend:/usr/src/app
      # 放哪裡沒有一定 /var/www/html,  /usr/src/app,  /home 都有人放
    ports:
      - "8080:8080"
    depends_on:
      - db
    user: rails # 對應到 adduser 的名稱
  frontend: # 會變成 REPOSITORY name autheg_frontend
    build:
      context: autheg-frontend
      args:
        UID: ${UID:-1001}
    volumes:
      - ./autheg-frontend:/usr/src/app
    ports:
      - "3000:3000"
    user: frontend # 對應到 adduser 的名稱
</code></pre>

<p>接下來執行</p>

<pre><code>docker-compose build
</code></pre>

<pre><code class="ruby"># docker images
REPOSITORY          TAG                 IMAGE ID            CREATED              SIZE
autheg_frontend     latest              18b1178326a7        About a minute ago   890MB
autheg_backend      latest              528bfe5bf6d6        2 minutes ago        1.03GB
</code></pre>

<pre><code>docker-compose run -u root backend bundle
</code></pre>

<pre><code class="ruby"># docker ps -a
CONTAINER ID        IMAGE               COMMAND                  CREATED              STATUS                          PORTS                     NAMES
a11609898c96        autheg_backend      "bundle"                 About a minute ago   Exited (0) About a minute ago                             autheg_backend_run_1
f088297e9b9b        postgres            "docker-entrypoint.s…"   About a minute ago   Up About a minute               0.0.0.0:32783-&gt;5432/tcp   autheg_db_1

docker volume ls
# DRIVER              VOLUME NAME
# local               64117d4ab46a1d0575cc7136e745cc70bf568cfb3e200c80c69ae035cde89085
</code></pre>

<pre><code>docker-compose run frontend yarn
</code></pre>

<pre><code class="ruby"># docker ps -a
CONTAINER ID        IMAGE               COMMAND                  CREATED                  STATUS                     PORTS                     NAMES
d51e53bd1370        autheg_frontend     "yarn"                   Less than a second ago   Exited (0) 3 seconds ago                             autheg_frontend_run_1
a11609898c96        autheg_backend      "bundle"                 3 minutes ago            Exited (0) 3 minutes ago                             autheg_backend_run_1
f088297e9b9b        postgres            "docker-entrypoint.s…"   3 minutes ago            Up 3 minutes               0.0.0.0:32783-&gt;5432/tcp   autheg_db_1
</code></pre>

<p>要再跑 bundle &amp; yarn 是因為有做 volumes，因此利用 docker 所建立的環境，跑 host 的 bundle &amp; yarn，讓兩邊一致</p>

<blockquote><p>The reason you need to run bundle and yarn after building is because your docker-compose file mounts your host volumes into the containers so you need to install the packages into the host volumes as well as the images that are used to create the containers</p></blockquote>

<h3>編輯 database.yml &amp; package.json</h3>

<pre><code class="diff"> default: &amp;default
   adapter: postgresql
   encoding: unicode
+  host: db
+  username: postgres
</code></pre>

<pre><code class="diff">   "private": true,
   "scripts": {
-    "dev": "nuxt",
+    "dev": "HOST=0.0.0.0 nuxt",
     "build": "nuxt build",
     "start": "nuxt start",
     "generate": "nuxt generate",
</code></pre>

<p><code>HOST=0.0.0.0 nuxt</code> so it’s visible on your host machine</p>

<p>再啟動一個 container 用來建立新資料庫</p>

<pre><code>docker-compose run backend bin/rails db:create
</code></pre>

<p>此時 db 會 create 在，一開始設定的 db container <code>autheg_db_1</code> 裡面，可以</p>

<pre><code class="ruby">docker exec -it autheg_db_1 bash
su - postgres
psql -ls
# 就會看到 create 好的 database
</code></pre>

<p>看一下目前產生的 container</p>

<pre><code class="ruby"># docker ps -a
CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS                     PORTS                     NAMES
85d3ec81e943        autheg_backend      "bin/rails db:create"    6 minutes ago       Exited (0) 6 minutes ago                             autheg_backend_run_2
6e1f7b406a70        autheg_frontend     "yarn"                   7 minutes ago       Exited (0) 7 minutes ago                             autheg_frontend_run_1
55ff63bb46e9        autheg_backend      "bundle"                 25 minutes ago      Exited (0) 8 minutes ago                             autheg_backend_run_1
e889c2e713d0        postgres            "docker-entrypoint.s…"   25 minutes ago      Up 25 minutes              0.0.0.0:32770-&gt;5432/tcp   autheg_db_1
</code></pre>

<p>將所有 container 啟動</p>

<pre><code class="ruby">docker-compose up
# docker-compose stop
# docker-compose down
</code></pre>

<p>就能看到</p>

<ul>
<li>rails : <code>http://localhost:8080/</code></li>
<li>nuxt : <code>http://localhost:3000/</code></li>
</ul>


<p><img src="https://cdn-images-1.medium.com/max/1600/1*hoai7Zion_e9-0uZQGr1Sw.png" alt="" />
<em>from <a href="https://medium.com/@fishpercolator/how-to-separate-frontend-backend-with-rails-api-nuxt-js-and-devise-jwt-cf7dd9da9d16">How to separate frontend + backend with Rails API, Nuxt.js and Devise-JWT</a></em></p>

<h1><span id="part2">Part 2: Getting them talking to each other</span></h1>

<p>新增 table, model, controller</p>

<pre><code class="ruby">docker-compose run backend bash
&gt; bin/rails g resource example name:string colour:string
&gt; bin/rails db:migrate
&gt; bin/rails c
&gt; &gt; {"foo" =&gt; "green", "bar" =&gt; "red", "baz" =&gt; "purple"}.each {|n,c| Example.create!(name: n, colour: c)}
</code></pre>

<p>編輯 controller</p>

<pre><code class="ruby"># autheg-backend/app/controllers/examples_controller.rb
class ExamplesController &lt; ApplicationController
  def index
    examples = Example.all.select(:id, :name, :colour)
    render json: examples
  end
end
</code></pre>

<pre><code class="ruby"># autheg-backend/config/routes.rb
Rails.application.routes.draw do
  scope :api, defaults: { format: :json } do
    resources :examples
  end
end
</code></pre>

<p>這個步驟目前先不做，要等後面安裝 <code>devise</code> 才需要</p>

<pre><code class="ruby"># autheg-backend/app/controllers/application_controller.rb
class ApplicationController &lt; ActionController::API
  include ActionController::MimeResponds
  respond_to :json
end
</code></pre>

<p>現在打 <code>http://localhost:8080/api/examples</code> 就會看到</p>

<p><img src="https://cdn-images-1.medium.com/max/1600/1*76hf6XcYJM_xLdpbd0jZGw.png" alt="" />
<em>from <a href="https://medium.com/@fishpercolator/how-to-separate-frontend-backend-with-rails-api-nuxt-js-and-devise-jwt-cf7dd9da9d16">How to separate frontend + backend with Rails API, Nuxt.js and Devise-JWT</a></em></p>

<p>接著安裝 <a href="https://github.com/axios/axios">axios</a> &amp; <a href="https://vuetifyjs.com/en/">vuetify</a></p>

<pre><code class="ruby">docker-compose run frontend yarn add @nuxtjs/axios @nuxtjs/vuetify
</code></pre>

<p>這邊是 hardcode 在上面，正式機不應該這樣寫</p>

<pre><code class="js">// autheg-frontend/nuxt.config.js
  modules: [
    '@nuxtjs/vuetify',
    '@nuxtjs/axios'
  ],
  axios: {
    host: 'localhost',
    port: 8080,
    prefix: '/api'
  }
</code></pre>

<p>更改畫面</p>

<p>The <code>nuxt</code> option to the link tells it to use Nuxt’s router to handle the link, rather than doing it in the browser.</p>

<pre><code class="js">// autheg-frontend/layouts/default.vue
&lt;template&gt;
  &lt;div id="app"&gt;
    &lt;v-app&gt;
      &lt;v-toolbar app dark&gt;
        &lt;v-toolbar-title&gt;Auth example&lt;/v-toolbar-title&gt;
        &lt;v-spacer /&gt;
        &lt;v-btn icon nuxt href="http://mgleon08.github.com/"&gt;&lt;v-icon&gt;home&lt;/v-icon&gt;&lt;/v-btn&gt;
      &lt;/v-toolbar&gt;
      &lt;v-content&gt;
        &lt;v-container fluid&gt;
          &lt;nuxt/&gt;
        &lt;/v-container&gt;
      &lt;/v-content&gt;
    &lt;/v-app&gt;
  &lt;/div&gt;
&lt;/template&gt;
</code></pre>

<p><code>mounted()</code> 會在 template 初始化的時候呼叫，並且會 call <code>updateExamples()</code> method，去 call <code>/examples</code> API 拿資料回來</p>

<p>```js
// autheg-frontend/pages/index.vue
<template>
  <v-layout>
    <v-flex>
      <v-list>
        <v-list-tile v-for="example in examples" :key="example.id" :class="example.colour">
          <v-list-tile-content></v-list-tile-content>
        </v-list-tile>
      </v-list>
    </v-flex>
  </v-layout>
</template></p>

<script>
export default {
  data () {
    return {
      examples: []
    }
  },
  methods: {
    async updateExamples() {
      this.examples = await this.$axios.$get('/examples')
    }
  },
  mounted () {
    this.updateExamples()
  }
}
</script>


<pre><code>
接著會看到 browser console 會 error，主要是因為 [CROS](https://en.wikipedia.org/wiki/Cross-origin_resource_sharing) 的原因

&gt; JavaScript isn’t allowed to query endpoints on other domains unless those domains set the CORS headers appropriately

![](https://cdn-images-1.medium.com/max/1600/1*5PhACGlQd7cfjiA-DqksuA.png)
*from [How to separate frontend + backend with Rails API, Nuxt.js and Devise-JWT](https://medium.com/@fishpercolator/how-to-separate-frontend-backend-with-rails-api-nuxt-js-and-devise-jwt-cf7dd9da9d16)*

接著要去 `backend` 新增 `cros` 的設定，讓 `frontend` 可以 call

先將 Gemfile 的 comment 打開
</code></pre>

<h1>autheg-backend/Gemfile</h1>

<p>gem &lsquo;rack-cors&rsquo;</p>

<h1>autheg-backend/config/initializers/cors.rb</h1>

<p>Rails.application.config.middleware.insert_before 0, Rack::Cors do
  allow do
    origins &lsquo;localhost:3000&rsquo; # 也可以 * 就是所有 domain 都可以打進來</p>

<pre><code>resource '*',
  headers: :any,
  methods: [:get, :post, :put, :patch, :delete, :options, :head]
</code></pre>

<p>  end
end
```</p>

<p>接著跑</p>

<pre><code>docker-compose run -u root backend bundle
</code></pre>

<p>然後重新起動 container</p>

<pre><code>ctrl + c
docker-compose up
</code></pre>

<p><img src="https://cdn-images-1.medium.com/max/1600/1*LUreZEc1i0c5WfhoDCLxSQ.png" alt="" />
<em>from <a href="https://medium.com/@fishpercolator/how-to-separate-frontend-backend-with-rails-api-nuxt-js-and-devise-jwt-cf7dd9da9d16">How to separate frontend + backend with Rails API, Nuxt.js and Devise-JWT</a></em></p>

<h1><span id="part3">Part 3: Authentication with Devise-JWT</span></h1>

<p>這次要加上 devise 加上 JWT</p>

<ul>
<li><a href="https://jwt.io/">JWT</a></li>
<li><a href="https://github.com/plataformatec/devise">devise</a></li>
<li><a href="https://github.com/waiting-for-dev/devise-jwt">devise-jwt</a></li>
</ul>


<p>先在 Gemfile 新增</p>

<pre><code class="ruby"># autheg-backend/Gemfile
gem 'devise'
gem 'devise-jwt'
</code></pre>

<p>bundle</p>

<pre><code class="ruby">docker-compose run -u root backend bundle
</code></pre>

<p>接著先安裝 devise 參考 <a href="https://github.com/plataformatec/devise#getting-started">getting-started</a></p>

<pre><code class="ruby"># 開新的 container 安裝 devise
docker-compose run backend bash
bin/rails g devise:install
bin/rails g devise user
bin/rails db:migrate
</code></pre>

<p>到這個步驟都還沒用到 <a href="https://jwt.io/">JWT</a>，接下來要要決定如何使令牌無效，原文選擇用 <code>黑名單</code> 的方式</p>

<pre><code class="ruby">bin/rails g model jwt_blacklist jti:string:index exp:datetime
</code></pre>

<p>並將欄位加上 <code>null: false</code> 和移除 <code>t.timestamps</code></p>

<pre><code class="ruby">def change
  create_table :jwt_blacklists do |t|
    t.string :jti, null: false
    t.datetime :exp, null: false
  end
  add_index :jwt_blacklists, :jti
end
</code></pre>

<p>在 model 加上 <code>include Devise::JWT::RevocationStrategies::Blacklist</code></p>

<pre><code class="ruby"># autheg-backend/app/models/jwt_blacklist.rb
class JwtBlacklist &lt; ApplicationRecord
  include Devise::JWT::RevocationStrategies::Blacklist
end
</code></pre>

<h3>secret setting</h3>

<blockquote><p>在這裡遇到個問題 <a href="https://github.com/waiting-for-dev/devise-jwt/issues/56">No implicit conversion of nil into String</a>，主要是用的 rails 版本，與原文章的 ralis(5.1) 不同，導致遇到在 5.2 版本時已經沒有 <code>secrets.yml</code>&hellip; 轉而改用 <code>credentials.yml.enc</code>，所以在這裡記錄一下兩個版本的設定</p></blockquote>

<h3>Before rails 5.2</h3>

<p>接著產生一組 secret，做設定</p>

<pre><code class="ruby">bin/rails secret
# 9dd044df628a496e83c668f..
</code></pre>

<pre><code class="ruby"># autheg-backend/config/secrets.yml
development:
  secret_key_base: xxx
  jwt_secret: 9dd044df628a496e83c668f..

test:
  secret_key_base: xxx
  jwt_secret: 9dd044df628a496e83c668f..

production:
  secret_key_base: &lt;%= ENV["SECRET_KEY_BASE"] %&gt;
  jwt_secret: &lt;%= ENV["JWT_SECRET"] %&gt;
</code></pre>

<pre><code class="ruby"># autheg-backend/config/initializers/devise.rb
config.jwt do |jwt|
  jwt.secret = Rails.application.secrets.jwt_secret
end
</code></pre>

<h3>After rails 5.2</h3>

<ul>
<li><a href="https://medium.com/cedarcode/rails-5-2-credentials-9b3324851336">Rails 5.2 credentials</a></li>
<li><a href="https://www.viget.com/articles/storing-secret-credentials-in-rails-5-2-and-up/">Storing Secret Credentials in Rails 5.2 and Up</a></li>
<li><a href="https://keithpblog.org/post/encrypted-secrets/">Rails 5.2: encrypted secrets</a></li>
</ul>


<pre><code class="ruby">bin/rails secret
# 9dd044df628a496e83c668f..
</code></pre>

<p>這時必須在 console執行 <code>EDITOR="vim" rails credentials:edit</code>，但是在 container 並沒有 <code>vim</code> 和 <code>sudo</code> 這個指令，因此要先切換成 root 去安裝 <code>vim</code> 才有辦法執行</p>

<pre><code class="ruby">docker-compose run -u root backend bash
apt-get update
apt-get install vim -y # 安裝 vim 
EDITOR="vim" bin/rails credentials:edit

# 接著編輯
secret_key_base: xxx
jwt_secret: 9dd044df628a496e83c668f..
</code></pre>

<pre><code class="ruby"># autheg-backend/config/initializers/devise.rb
config.jwt do |jwt|
  jwt.secret = Rails.application.credentials[:jwt_secret]
end
</code></pre>

<p>上面 secret 設定好就可以繼續</p>

<p>設定 <code>response format</code></p>

<pre><code class="ruby"># autheg-backend/app/controllers/application_controller.rb
class ApplicationController &lt; ActionController::API
  include ActionController::MimeResponds
  respond_to :json
end
</code></pre>

<pre><code class="ruby"># autheg-backend/app/models/user.rb
class User &lt; ApplicationRecord
  # Include default devise modules. Others available are:
  # :confirmable, :lockable, :timeoutable and :omniauthable
  devise :database_authenticatable, :registerable,
         :recoverable, :rememberable, :trackable, :validatable,
         :jwt_authenticatable, jwt_revocation_strategy: JwtBlacklist
end
</code></pre>

<p>設定好跑</p>

<pre><code class="ruby">bin/rails db:migrate
</code></pre>

<p>將 router 的 <code>devise_scope :user</code> 移到 api scope 裡面</p>

<pre><code class="ruby">Rails.application.routes.draw do
  # For details on the DSL available within this file, see http://guides.rubyonrails.org/routing.html
  scope :api, defaults: { format: :json } do
    resources :examples
    devise_for :users
  end
end
</code></pre>

<p>restart containers</p>

<pre><code>ctrl + c
docker-compose up
</code></pre>

<p>console 新增一個 User</p>

<pre><code class="ruby">bin/rails c
User.create!(email: 'test@example.com', password: 'password')
</code></pre>

<p>接下來就可以來測試 <code>user login</code> 原文推薦使用 <a href="http://yet-another-rest-client.com/">YARC</a> 不過個人偏好 <a href="https://www.getpostman.com/">Postman</a>，都可以</p>

<pre><code class="ruby">POST /api/users/sign_in

{  
   "user":{  
      "email":"test@example.com",
      "password":"password"
   }
}
</code></pre>

<p><img src="https://cdn-images-1.medium.com/max/1600/1*2cTvgN1s2-6VkCLknzuwXQ.png" alt="" />
<em>from <a href="https://medium.com/@fishpercolator/how-to-separate-frontend-backend-with-rails-api-nuxt-js-and-devise-jwt-cf7dd9da9d16">How to separate frontend + backend with Rails API, Nuxt.js and Devise-JWT</a></em></p>

<p>這裡可以看到 Response Headers 多了一個欄位</p>

<pre><code class="ruby"># 原本

{
  "x-runtime": "0.496080",
  "etag": "W/\"9a9c93785c7d5e5890c3189efa33ca10\"",
  "vary": "Origin",
  "content-type": "application/json; charset=utf-8",
  "location": "/",
  "cache-control": "max-age=0, private, must-revalidate",
  "transfer-encoding": "chunked",
  "x-request-id": "c6a59d67-2551-496f-8f99-f69c5b79bd75",
  "status": 201
}

# 加上 jwt

{
  "x-runtime": "0.998534",
  "etag": "W/\"d2403cf91d814bea7a094efecd1e0ae9\"",
  "authorization": "Bearer eyJhbGciOiJIUzI1NiJ9.eyJzdWIiOiIxIiwic2NwIjoidXNlciIsImF1ZCI6bnVsbCwiaWF0IjoxNTMxNjY2NjA0LCJleHAiOjE1MzE2NzAyMDQsImp0aSI6ImYzMjkxMWViLTY0ZDEtNDU0NS1iNGJjLTQ5MjE2NjQwMDc1OCJ9.nP5vGhbiPfC5acnQOusY_bEZCAWF2TZ29vq28SMUX2U",
  "vary": "Origin",
  "content-type": "application/json; charset=utf-8",
  "location": "/",
  "cache-control": "max-age=0, private, must-revalidate",
  "transfer-encoding": "chunked",
  "x-request-id": "4eec0e2f-5cb5-4c4d-9ed9-be9385c79a5d",
  "status": 201
}
</code></pre>

<p>接著要來覆蓋掉 devise 原本的 session controller，讓我們可以將 jwt 加進去</p>

<p>先 generate devise 內建的 sessino controller</p>

<pre><code class="ruby">bin/rails generate devise:controllers users -c=sessions
</code></pre>

<p>並且新增一個 router，已便可以拿到 user 的 detail 資訊</p>

<blockquote><p>這裡跟原文章不太一樣，這邊是藉由 devise 內建的 generate 產生 session controller file，是放在 app/controller/users/sessions_controller.rb，原文章應該是自行建立的檔案放在 app/controller/sessions_controller.rb，因此底下的 router 設定也會有稍微不同</p></blockquote>

<pre><code class="ruby"># autheg-backend/config/routes.rb
Rails.application.routes.draw do
  scope :api, defaults: { format: :json } do
    resources :examples
    devise_for :users, controllers: { sessions: 'users/sessions' }
    devise_scope :user do
      get 'users/current', to: 'users/sessions#show'
    end
  end
end
</code></pre>

<p>將 Gemfile 裡的 <code>jbuilder</code> gem 打開</p>

<pre><code class="ruby"># Gemfile
gem 'jbuilder', '~&gt; 2.5'
</code></pre>

<pre><code class="ruby">docker-compose run -u root backend bundle
# restart containers
docker-compose up
</code></pre>

<pre><code class="ruby"># autheg-backend/app/controllers/users/sessions_controller.rb
class Users::SessionsController &lt; Devise::SessionsController
  def create
    super { @token = current_token }
  end

  def show
  end

  private

  def current_token
    request.env['warden-jwt_auth.token']
  end
end
</code></pre>

<pre><code class="ruby"># autheg-backend/app/views/users/create.json.jbuilder
json.token @token
</code></pre>

<pre><code class="ruby"># autheg-backend/app/views/users/show.json.jbuilder
if user_signed_in?
  json.user do
    json.(current_user, :id, :email)
  end
end
</code></pre>

<p>接下來可以測試 login 了</p>

<pre><code class="ruby"># 登入拿 token
POST /api/users/sign_in

{  
   "user":{  
      "email":"test@example.com",
      "password":"password"
   }
}

# 在 Header 加上剛剛登入拿到的 token
# "authorization": "Bearer eyJhbGciOiJIUzI1NiJ9.eyJzdW ..."
GET /api/users/current

# 登出，記得也要帶 token 才知道誰要登出
# "authorization": "Bearer eyJhbGciOiJIUzI1NiJ9.eyJzdW ..."
DELETE /api/users/sign_out
</code></pre>

<p>測試 ok 後，接下來在 <code>ExamplesController</code> 加上 <code>authentication</code></p>

<pre><code class="ruby"># autheg-backend/app/controllers/examples_controller.rb
class ExamplesController &lt; ApplicationController
  before_action :authenticate_user!

  def index
    examples = Example.all.select(:id, :name, :colour)
    render json: examples
  end
end
</code></pre>

<p>這時 <code>GET /api/examples</code> 就必須帶 <code>token</code> 否則會 <code>error</code></p>

<pre><code class="ruby">GET /api/examples

{
  "error": "You need to sign in or sign up before continuing."
}
</code></pre>

<p>接下來回到 frontend，會發現 <code>401 Unauthorized error</code> 所以要在 frontend 加上 <code>authentication</code></p>

<p>新增後端 <code>sign_in</code> <code>sign_out</code> <code>detail</code> API &amp; <code>@nuxtjs/auth</code></p>

<pre><code>docker-compose run frontend yarn add @nuxtjs/auth
</code></pre>

<pre><code class="js">// autheg-frontend/nuxt.config.js
modules: [
  '@nuxtjs/vuetify',
  '@nuxtjs/axios',
  '@nuxtjs/auth'
],
auth: {
  endpoints: {
    login:  { url: '/users/sign_in' },
    logout: { url: '/users/sign_out', method: 'delete' },
    user:   { url: '/users/current' }
  }
}
</code></pre>

<pre><code class="js">// autheg-frontend/store/index.js
export default {
  state: () =&gt; ({
  })
}
</code></pre>

<p>restart container 讓 frontend 吃到剛剛的設定</p>

<p>```js
// autheg-frontend/pages/login.vue</p>

<p><template>
  <v-layout>
    <v-flex>
      <v-card v-if="$auth.state.loggedIn">
        <v-alert type="error" :value="error"></v-alert>
        <v-card-text>
          Logged in as 
        </v-card-text>
        <v-card-actions>
          <v-btn @click="logout">Log out</v-btn>
        </v-card-actions>
      </v-card>
      <v-card v-else>
        <v-alert type="error" :value="error"></v-alert>
        <v-card-text>
          <v-form>
            <v-text-field v-model="email" label="Email" />
            <v-text-field v-model="password" label="Password" type="password" />
          </v-form>
          <v-card-actions>
            <v-btn @click="login">Log in</v-btn>
          </v-card-actions>
        </v-card-text>
      </v-card>
    </v-flex>
  </v-layout>
</template></p>

<script>
export default {
  data () {
    return {
      email: '',
      password: '',
      error: null
    }
  },
  methods: {
    login: function () {
      this.$auth.login({
        data: {
          user: {
            email: this.email,
            password: this.password
          }
        }
      }).catch(e => {this.error = e + ''})
    },
    logout: function () {
      this.$auth.logout().catch(e => {this.error = e + ''})
    }
  }
}
</script>


<pre><code>
現在可以到 `/login` 試試看登入了

如果想要讓 user 沒有 login 的狀態下都 redirect 到 `login page` 就加上
</code></pre>

<p>// autheg-frontend/pages/index.vue
<template>
  <v-layout>
    <v-flex>
      <v-list>
        <v-list-tile v-for="example in examples" :key="example.id" :class="example.colour">
          <v-list-tile-content></v-list-tile-content>
        </v-list-tile>
      </v-list>
    </v-flex>
  </v-layout>
</template></p>

<script>
export default {
  middleware: ['auth'],
  data () {
    return {
      examples: []
    }
  },
  methods: {
    async updateExamples() {
      this.examples = await this.$axios.$get('/examples')
    }
  },
  mounted () {
    this.updateExamples()
  }
}
</script>


<p>```</p>

<p>現在可以 try 一下</p>

<p><img src="https://cdn-images-1.medium.com/max/1600/1*012-LUDxJttnF6Jtn0Cm7A.png" alt="" />
<em>from <a href="https://medium.com/@fishpercolator/how-to-separate-frontend-backend-with-rails-api-nuxt-js-and-devise-jwt-cf7dd9da9d16">How to separate frontend + backend with Rails API, Nuxt.js and Devise-JWT</a></em></p>

<p><img src="https://cdn-images-1.medium.com/max/1600/1*X7EYUzlYqfSEDGUlTaK7vQ.png" alt="" />
<em>from <a href="https://medium.com/@fishpercolator/how-to-separate-frontend-backend-with-rails-api-nuxt-js-and-devise-jwt-cf7dd9da9d16">How to separate frontend + backend with Rails API, Nuxt.js and Devise-JWT</a></em></p>

<p>參考文件</p>

<ul>
<li><a href="https://medium.com/@fishpercolator/how-to-separate-frontend-backend-with-rails-api-nuxt-js-and-devise-jwt-cf7dd9da9d16">How to separate frontend + backend with Rails API, Nuxt.js and Devise-JWT</a></li>
<li><a href="https://medium.com/@fishpercolator/deploying-your-nuxt-rails-api-app-to-production-with-heroku-54efd09eec22">Deploying your Nuxt+Rails API app to production with Heroku</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
