<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Rails | Leon's Blogging]]></title>
  <link href="http://mgleon08.github.com/blog/categories/rails/atom.xml" rel="self"/>
  <link href="http://mgleon08.github.com/"/>
  <updated>2016-05-29T20:37:29+08:00</updated>
  <id>http://mgleon08.github.com/</id>
  <author>
    <name><![CDATA[LeonJi]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Includes Preload Joins Eager_load References]]></title>
    <link href="http://mgleon08.github.com/blog/2016/04/21/includes-preload-joins-eager-load-references/"/>
    <updated>2016-04-21T00:41:09+08:00</updated>
    <id>http://mgleon08.github.com/blog/2016/04/21/includes-preload-joins-eager-load-references</id>
    <content type="html"><![CDATA[<p>rails 當中有很多方便可以做資料查詢的功能，可以好好研究一下。</p>

<!-- more -->


<h1>modle</h1>

<pre><code class="ruby">class Blog &lt; ActiveRecord::Base
  has_many :posts

  # t.string   "name"
  # t.string   "author"
end

class Post &lt; ActiveRecord::Base
  belongs_to :blog

  # t.string   "title"
end
</code></pre>

<h1>includes</h1>

<ul>
<li><code>includes</code> 主要用於可以直接將相關連的資料，在同一筆查詢，一起撈出來</li>
<li>two separate queries</li>
<li>跟 preload 類似，加上 <code>reference</code> 則和 <code>eager_load</code> 類似</li>
</ul>


<pre><code class="ruby">Blog.includes(:posts)
Blog Load (0.1ms)  SELECT "blogs".* FROM "blogs"
Post Load (0.2ms)  SELECT "posts".* FROM "posts" WHERE "posts"."blog_id" IN (1, 2, 3)
 =&gt; #&lt;ActiveRecord::Relation [#&lt;Blog id: 1, name: "Blog 1", author: "someone", created_at: "2016-04-20 14:26:01", updated_at: "2016-04-20 14:26:01"&gt;, #&lt;Blog id: 2, name: "Blog 2", author: "someone", created_at: "2016-04-20 14:26:01", updated_at: "2016-04-20 14:26:01"&gt;, #&lt;Blog id: 3, name: "Blog 3", author: "someone", created_at: "2016-04-20 14:26:01", updated_at: "2016-04-20 14:26:01"&gt;]&gt;

# 回傳所有 User 和 關聯的 posts
</code></pre>

<p>可以看到後面有 <code>IN (1, 2, 3)</code>，就是將上面一筆一筆查詢，變成這種方式一次撈出來。這樣在 <code>view</code> 中執行 <code>user.posts</code> 就不會再去資料庫查詢，因為已經都先撈出來了。</p>

<pre><code class="ruby">#也可以一次 includes 多個關聯

Blog.includes(posts: :profile)
Blog.includes(posts: [:foo, :bar])
#blog 關聯到 posts，posts 關聯到 foo, bar

Blog.includes(:user, comments: [:user, { replies: [:user] }])
#更複雜的關聯
</code></pre>

<h1>preload</h1>

<ul>
<li>跟 includes 類似，主要差別在於無法用 where 條件去查關聯到的 table 欄位</li>
<li>two separate queries</li>
</ul>


<pre><code class="ruby">Blog.preload(:posts)
  Blog Load (0.1ms)  SELECT "blogs".* FROM "blogs"
  Post Load (0.3ms)  SELECT "posts".* FROM "posts" WHERE "posts"."blog_id" IN (1, 2, 3)
 =&gt; #&lt;ActiveRecord::Relation [#&lt;Blog id: 1, name: "Blog 1", author: "someone", created_at: "2016-04-20 14:26:01", updated_at: "2016-04-20 14:26:01"&gt;, #&lt;Blog id: 2, name: "Blog 2", author: "someone", created_at: "2016-04-20 14:26:01", updated_at: "2016-04-20 14:26:01"&gt;, #&lt;Blog id: 3, name: "Blog 3", author: "someone", created_at: "2016-04-20 14:26:01", updated_at: "2016-04-20 14:26:01"&gt;]&gt;
</code></pre>

<pre><code class="ruby">#無法透過關聯的欄位做搜尋
Blog.preload(:posts).where(posts: { title:"Post 1-1" } )
  Blog Load (0.4ms)  SELECT "blogs".* FROM "blogs" WHERE "posts"."title" = ?  [["title", "Post 1-1"]]
=&gt;# ActiveRecord::StatementInvalid: SQLite3::SQLException: no such column: posts.title: SELECT "blogs".* FROM "blogs" WHERE "posts"."title" = ?

Blog.preload(:posts).where("posts.title = 'Post 1-1'").references(:post)
  Blog Load (0.4ms)  SELECT "blogs".* FROM "blogs" WHERE (posts.title = 'Post 1-1')
=&gt;# ActiveRecord::StatementInvalid: SQLite3::SQLException: no such column: posts.title: SELECT "blogs".* FROM "blogs" WHERE (posts.title = 'Post 1-1')

#用 includes 就沒問題，不過這就是 eager_load
Blog.includes(:posts).where(posts: { title:"Post 1-1" } )
  SQL (0.2ms)  SELECT "blogs"."id" AS t0_r0, "blogs"."name" AS t0_r1, "blogs"."author" AS t0_r2, "blogs"."created_at" AS t0_r3, "blogs"."updated_at" AS t0_r4, "posts"."id" AS t1_r0, "posts"."title" AS t1_r1, "posts"."blog_id" AS t1_r2, "posts"."user_id" AS t1_r3, "posts"."created_at" AS t1_r4, "posts"."updated_at" AS t1_r5 FROM "blogs" LEFT OUTER JOIN "posts" ON "posts"."blog_id" = "blogs"."id" WHERE "posts"."title" = ?  [["title", "Post 1-1"]]
 =&gt; #&lt;ActiveRecord::Relation [#&lt;Blog id: 1, name: "Blog 1", author: "someone", created_at: "2016-04-20 14:26:01", updated_at: "2016-04-20 14:26:01"&gt;]&gt;

#另一種寫法 
 Blog.includes(:posts).where("posts.title = 'Post 1-1'").references(:post)
  SQL (0.3ms)  SELECT "blogs"."id" AS t0_r0, "blogs"."name" AS t0_r1, "blogs"."author" AS t0_r2, "blogs"."created_at" AS t0_r3, "blogs"."updated_at" AS t0_r4, "posts"."id" AS t1_r0, "posts"."title" AS t1_r1, "posts"."blog_id" AS t1_r2, "posts"."user_id" AS t1_r3, "posts"."created_at" AS t1_r4, "posts"."updated_at" AS t1_r5 FROM "blogs" LEFT OUTER JOIN "posts" ON "posts"."blog_id" = "blogs"."id" WHERE (posts.title = 'Post 1-1')
 =&gt; #&lt;ActiveRecord::Relation [#&lt;Blog id: 1, name: "Blog 1", author: "someone", created_at: "2016-04-20 14:26:01", updated_at: "2016-04-20 14:26:01"&gt;]&gt;
</code></pre>

<h1>joins (inner join)</h1>

<p><code>joins</code> 則是關聯其他資料庫，可以進行查詢，但並不會將關聯的資料拉出來。</p>

<pre><code class="ruby">Blog.joins(:posts)
  Blog Load (0.2ms)  SELECT "blogs".* FROM "blogs" INNER JOIN "posts" ON "posts"."blog_id" = "blogs"."id"
 =&gt; #&lt;ActiveRecord::Relation [#&lt;Blog id: 1, name: "Blog 1", author: "someone", created_at: "2016-04-20 14:26:01", updated_at: "2016-04-20 14:26:01"&gt;, #&lt;Blog id: 1, name: "Blog 1", author: "someone", created_at: "2016-04-20 14:26:01", updated_at: "2016-04-20 14:26:01"&gt;, #&lt;Blog id: 1, name: "Blog 1", author: "someone", created_at: "2016-04-20 14:26:01", updated_at: "2016-04-20 14:26:01"&gt;, #&lt;Blog id: 1, name: "Blog 1", author: "someone", created_at: "2016-04-20 14:26:01", updated_at: "2016-04-20 14:26:01"&gt;, #&lt;Blog id: 1, name: "Blog 1", author: "someone", created_at: "2016-04-20 14:26:01", updated_at: "2016-04-20 14:26:01"&gt;, #&lt;Blog id: 2, name: "Blog 2", author: "someone", created_at: "2016-04-20 14:26:01", updated_at: "2016-04-20 14:26:01"&gt;, #&lt;Blog id: 2, name: "Blog 2", author: "someone", created_at: "2016-04-20 14:26:01", updated_at: "2016-04-20 14:26:01"&gt;, #&lt;Blog id: 2, name: "Blog 2", author: "someone", created_at: "2016-04-20 14:26:01", updated_at: "2016-04-20 14:26:01"&gt;, #&lt;Blog id: 2, name: "Blog 2", author: "someone", created_at: "2016-04-20 14:26:01", updated_at: "2016-04-20 14:26:01"&gt;, #&lt;Blog id: 2, name: "Blog 2", author: "someone", created_at: "2016-04-20 14:26:01", updated_at: "2016-04-20 14:26:01"&gt;, ...]&gt;

Blog.joins(:posts).count
   (0.1ms)  SELECT COUNT(*) FROM "blogs" INNER JOIN "posts" ON "posts"."blog_id" = "blogs"."id"
 =&gt; 15

#因為資料庫裡面總共有四個，但只有三個室有關聯到 posts，因此 joins 會回傳有關聯的，blog
Blog.joins(:posts).uniq.size
   (0.3ms)  SELECT DISTINCT COUNT(DISTINCT "blogs"."id") FROM "blogs" INNER JOIN "posts" ON "posts"."blog_id" = "blogs"."id"
 =&gt; 3

#回傳所有，有 post 的 blog
#因為同一個 blog 可能有多個 post ，這樣就會撈出重複的 blog 出來 ， 一個 post 一個 blog，因此可以用 .uniq 來去除重複的資料。
#如果是一對一就不會有這個問題了

#eager_load 則是透過 rails filter 後的
Blog.eager_load(:posts)
  SQL (0.3ms)  SELECT "blogs"."id" AS t0_r0, "blogs"."name" AS t0_r1, "blogs"."author" AS t0_r2, "blogs"."created_at" AS t0_r3, "blogs"."updated_at" AS t0_r4, "posts"."id" AS t1_r0, "posts"."title" AS t1_r1, "posts"."blog_id" AS t1_r2, "posts"."user_id" AS t1_r3, "posts"."created_at" AS t1_r4, "posts"."updated_at" AS t1_r5 FROM "blogs" LEFT OUTER JOIN "posts" ON "posts"."blog_id" = "blogs"."id"
 =&gt; #&lt;ActiveRecord::Relation [#&lt;Blog id: 1, name: "Blog 1", author: "someone", created_at: "2016-04-20 14:26:01", updated_at: "2016-04-20 14:26:01"&gt;, #&lt;Blog id: 2, name: "Blog 2", author: "someone", created_at: "2016-04-20 14:26:01", updated_at: "2016-04-20 14:26:01"&gt;, #&lt;Blog id: 3, name: "Blog 3", author: "someone", created_at: "2016-04-20 14:26:01", updated_at: "2016-04-20 14:26:01"&gt;, #&lt;Blog id: 4, name: "Blog 2", author: nil, created_at: "2016-04-20 16:01:54", updated_at: "2016-04-20 16:01:54"&gt;]&gt;

#因為是 LEFT OUTER JOINed 所以沒有關聯的也會抓進來
 Blog.eager_load(:posts).count
   (0.2ms)  SELECT COUNT(DISTINCT "blogs"."id") FROM "blogs" LEFT OUTER JOIN "posts" ON "posts"."blog_id" = "blogs"."id"
 =&gt; 4
</code></pre>

<p>回傳的是所有有 <code>post</code> 的 <code>blog</code>，但並不會將 <code>post</code> 資料撈出來，只是去做比對，因此再用 <code>blog.posts</code> ，一樣會去資料庫中撈出資料。</p>

<h1>joins和include的區別</h1>

<ul>
<li>include 主要是將其他關聯的 table 一起拉進來，後續查詢時，就不會再去查</li>
<li>joins 則是將兩張表合成一張（必須id有對到），再透過欄位去做塞選</li>
</ul>


<pre><code class="ruby">Blog.includes(:posts)
#回傳所有的 Blog，並將相關聯的 post 一併做查詢
#後續再去關聯的話就不會去 query

Blog.joins(:posts)
#查詢所有包含 user_id 的 posts ，並回傳該 post 所屬的 blog
#因此 has_many 若有很多 posts 屬於同一個 blog 就會回傳很多次重複的( 或是用 `distinct` User.joins(:posts).select('distinct users.*'))，可用 uniq 去掉，belong_to &amp; has_one 則不會
#後續再去關聯的話，還是會去 query
</code></pre>

<h1>eager_load</h1>

<ul>
<li>One query, LEFT OUTER JOINed in any query rather than loaded separately.</li>
<li>Works just the same as <code>includes</code> + <code>references</code></li>
<li>因此要小心，includers 後在接上 references 就會變成 eager_load</li>
</ul>


<pre><code class="ruby">Blog.eager_load(:posts)
  SQL (0.3ms)  SELECT "blogs"."id" AS t0_r0, "blogs"."name" AS t0_r1, "blogs"."author" AS t0_r2, "blogs"."created_at" AS t0_r3, "blogs"."updated_at" AS t0_r4, "posts"."id" AS t1_r0, "posts"."title" AS t1_r1, "posts"."blog_id" AS t1_r2, "posts"."user_id" AS t1_r3, "posts"."created_at" AS t1_r4, "posts"."updated_at" AS t1_r5 FROM "blogs" LEFT OUTER JOIN "posts" ON "posts"."blog_id" = "blogs"."id"
 =&gt; #&lt;ActiveRecord::Relation [#&lt;Blog id: 1, name: "Blog 1", author: "someone", created_at: "2016-04-20 14:26:01", updated_at: "2016-04-20 14:26:01"&gt;, #&lt;Blog id: 2, name: "Blog 2", author: "someone", created_at: "2016-04-20 14:26:01", updated_at: "2016-04-20 14:26:01"&gt;, #&lt;Blog id: 3, name: "Blog 3", author: "someone", created_at: "2016-04-20 14:26:01", updated_at: "2016-04-20 14:26:01"&gt;, #&lt;Blog id: 4, name: "Blog 2", author: nil, created_at: "2016-04-20 16:01:54", updated_at: "2016-04-20 16:01:54"&gt;]&gt;

Blog.eager_load(:posts).where(name: 'Blog 1')
  SQL (0.3ms)  SELECT "blogs"."id" AS t0_r0, "blogs"."name" AS t0_r1, "blogs"."author" AS t0_r2, "blogs"."created_at" AS t0_r3, "blogs"."updated_at" AS t0_r4, "posts"."id" AS t1_r0, "posts"."title" AS t1_r1, "posts"."blog_id" AS t1_r2, "posts"."user_id" AS t1_r3, "posts"."created_at" AS t1_r4, "posts"."updated_at" AS t1_r5 FROM "blogs" LEFT OUTER JOIN "posts" ON "posts"."blog_id" = "blogs"."id" WHERE "blogs"."name" = ?  [["name", "Blog 1"]]
 =&gt; #&lt;ActiveRecord::Relation [#&lt;Blog id: 1, name: "Blog 1", author: "someone", created_at: "2016-04-20 14:26:01", updated_at: "2016-04-20 14:26:01"&gt;]&gt;

Blog.eager_load(:posts).where(name: 'Blog 1').where(posts: {title: 'Post 1-1'})
  SQL (0.3ms)  SELECT "blogs"."id" AS t0_r0, "blogs"."name" AS t0_r1, "blogs"."author" AS t0_r2, "blogs"."created_at" AS t0_r3, "blogs"."updated_at" AS t0_r4, "posts"."id" AS t1_r0, "posts"."title" AS t1_r1, "posts"."blog_id" AS t1_r2, "posts"."user_id" AS t1_r3, "posts"."created_at" AS t1_r4, "posts"."updated_at" AS t1_r5 FROM "blogs" LEFT OUTER JOIN "posts" ON "posts"."blog_id" = "blogs"."id" WHERE "blogs"."name" = ? AND "posts"."title" = ?  [["name", "Blog 1"], ["title", "Post 1-1"]]
 =&gt; #&lt;ActiveRecord::Relation [#&lt;Blog id: 1, name: "Blog 1", author: "someone", created_at: "2016-04-20 14:26:01", updated_at: "2016-04-20 14:26:01"&gt;]&gt;

# includes + references 
Blog.includes(:posts).where(name: 'Blog 1').where(posts: {title: 'Post 1-1'})
  SQL (0.2ms)  SELECT "blogs"."id" AS t0_r0, "blogs"."name" AS t0_r1, "blogs"."author" AS t0_r2, "blogs"."created_at" AS t0_r3, "blogs"."updated_at" AS t0_r4, "posts"."id" AS t1_r0, "posts"."title" AS t1_r1, "posts"."blog_id" AS t1_r2, "posts"."user_id" AS t1_r3, "posts"."created_at" AS t1_r4, "posts"."updated_at" AS t1_r5 FROM "blogs" LEFT OUTER JOIN "posts" ON "posts"."blog_id" = "blogs"."id" WHERE "blogs"."name" = ? AND "posts"."title" = ?  [["name", "Blog 1"], ["title", "Post 1-1"]]
 =&gt; #&lt;ActiveRecord::Relation [#&lt;Blog id: 1, name: "Blog 1", author: "someone", created_at: "2016-04-20 14:26:01", updated_at: "2016-04-20 14:26:01"&gt;]&gt;
</code></pre>

<h1>references</h1>

<ul>
<li>只有在 includes 可以使用，主要是讓 includes 像 eager_load</li>
</ul>


<pre><code class="ruby">Blog.includes(:posts).where(name: 'Blog 1').references(:posts)
  SQL (0.2ms)  SELECT "blogs"."id" AS t0_r0, "blogs"."name" AS t0_r1, "blogs"."author" AS t0_r2, "blogs"."created_at" AS t0_r3, "blogs"."updated_at" AS t0_r4, "posts"."id" AS t1_r0, "posts"."title" AS t1_r1, "posts"."blog_id" AS t1_r2, "posts"."user_id" AS t1_r3, "posts"."created_at" AS t1_r4, "posts"."updated_at" AS t1_r5 FROM "blogs" LEFT OUTER JOIN "posts" ON "posts"."blog_id" = "blogs"."id" WHERE "blogs"."name" = ?  [["name", "Blog 1"]]
 =&gt; #&lt;ActiveRecord::Relation [#&lt;Blog id: 1, name: "Blog 1", author: "someone", created_at: "2016-04-20 14:26:01", updated_at: "2016-04-20 14:26:01"&gt;]&gt;
</code></pre>

<p><img src="http://jbcdn2.b0.upaiyun.com/2013/05/SQL-Joins.jpg" alt="" /></p>

<p>官方資料：<br/>
<a href="http://guides.rubyonrails.org/active_record_querying.html">Active Record Query Interface</a><br/>
<a href="http://rails.ruby.tw/active_record_querying.html">Active Record 查詢</a></p>

<p>參考資料：<br/>
<a href="https://ihower.tw/rails4/performance.html">網站效能</a><br/>
<a href="https://ihower.tw/rails4/activerecord-relationships.html">ActiveRecord - 資料表關聯</a><br/>
<a href="http://motion-express.com/blog/20141028-rails-include-join-avoid-n-1-query">Rails使用 include 和 join 避免 N+1 query</a><br/>
<a href="http://blog.ifyouseewendy.com/blog/2015/11/11/preload-eager_load-includes-references-joins/">preload, eager_load, includes, references, and joins in Rails</a><br/>
<a href="http://blog.bigbinary.com/2013/07/01/preload-vs-eager-load-vs-joins-vs-includes.html">Preload, Eagerload, Includes and Joins</a><br/>
<a href="http://blog.arkency.com/2013/12/rails4-preloading/">3 ways to do eager loading (preloading) in Rails 3 &amp; 4</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[HTTP HEADER]]></title>
    <link href="http://mgleon08.github.com/blog/2016/04/19/http-header/"/>
    <updated>2016-04-19T22:22:30+08:00</updated>
    <id>http://mgleon08.github.com/blog/2016/04/19/http-header</id>
    <content type="html"><![CDATA[<p>透過 HTTP HEADER 有很多資訊可以做傳遞</p>

<!-- more -->


<h1>mime_types</h1>

<p>MIME(Multipurpose Internet Mail Extensions) 格式</p>

<p>主要用在 HTTP 通訊協定中的請求標頭 Accept 和回應標頭 Content-Type 中，來說明此文件的格式。</p>

<p>Rails 會在 Controller 的 respond_to 方法中辨識並回應所請求的格式樣板，例如瀏覽器請求 application/json 就會回應 json 格式</p>

<pre><code class="ruby">Mime::SET.collect(&amp;:to_s)
=&gt; ["text/html",
 "text/plain",
 "text/javascript",
 "text/css",
 "text/calendar",
 "text/csv",
 "text/vcard",
 "image/png",
 "image/jpeg",
 "image/gif",
 "image/bmp",
 "image/tiff",
 "video/mpeg",
 "application/xml",
 "application/rss+xml",
 "application/atom+xml",
 "application/x-yaml",
 "multipart/form-data",
 "application/x-www-form-urlencoded",
 "application/json",
 "application/pdf",
 "application/zip"]
</code></pre>

<h1>Accept-Language</h1>

<p>可以根據瀏覽器的語言，來切換網站的語言</p>

<pre><code class="ruby">￼class ApplicationController &lt; ActionController::Base￼  protect_from_forgery with: :exception  before_action :set_locale￼  
  protected
  def set_locale    I18n.locale = request.headers['Accept-Language']  endend
</code></pre>

<p>搭配 <code>http_accept_language</code> gem</p>

<pre><code class="ruby">class ApplicationController &lt; ActionController::Base  protect_from_forgery with: :exception  before_action :set_locale

  ￼protected  def set_locale￼￼￼    locales = I18n.available_locales    I18n.locale = http_accept_language.compatible_language_from(locales)  end
end
</code></pre>

<h1>USING THE ACCEPT HEADER</h1>

<pre><code class="ruby">#config/routes.rb
require 'api_version'

scope defaults: { format: 'json' } do  scope module: :v1, constraints: ApiVersion.new('v1') do￼￼￼    resources :zombies  end￼￼￼￼  scope module: :v2, constraints: ApiVersion.new('v2', true) do    resources :zombies￼￼￼  end 
end
</code></pre>

<pre><code class="ruby">#lib/api_version.rb
class ApiVersion  def initialize(version, default=false)    @version, @default = version, default￼￼￼￼￼￼  end
  private  def check_headers(headers)    accept = headers['Accept']  end￼  def matches?(request)    @default || check_headers(request.headers)    accept &amp;&amp; accept.include?("application/vnd.apocalypse.#{@version}+json")  endend

application
#payload is application-specificvnd.apocalypse#media type is vendor-specific[.version]
#API version+json#response format should be JSON
</code></pre>

<h1>Token</h1>

<pre><code class="ruby">#app/models/user.rb
class User &lt; ActiveRecord::Base
  before_create :set_auth_token

  private
  ￼def set_auth_token    return if auth_token.present?    self.auth_token = generate_auth_token
  end

  def generate_auth_token
    loop do      token = SecureRandom.hex
      break token unless self.class.exists?(auth_token: token)    end
￼  end
end
</code></pre>

<pre><code class="ruby">#app/controllers/posts_controller.rb
class EpisodesController &lt; ApplicationController   before_action :authenticate

   ￼protected
   def authenticate     authenticate_token || render_unauthorized
   end

   ￼def authenticate_token     authenticate_with_http_token do |token, options|
       User.find_by(auth_token: token)     end
   end
end
</code></pre>

<p>gem：<br/>
<a href="https://github.com/iain/http_accept_language">http_accept_language</a></p>

<p>參考文件：<br/>
<a href="https://ihower.tw/rails4/environments-and-bundler.html">mime types</a><br/>
<a href="http://www.rails365.net/articles/gem-jie-shao-yuan-ma-fen-xi-http-accept-language-si">gem介紹及源碼分析之http_accept_language(四)</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Rails Routes設定]]></title>
    <link href="http://mgleon08.github.com/blog/2016/03/26/rails-routes/"/>
    <updated>2016-03-26T09:37:30+08:00</updated>
    <id>http://mgleon08.github.com/blog/2016/03/26/rails-routes</id>
    <content type="html"><![CDATA[<p>要如何設計網站的 router 是非常重要的一件事。<br/>
在 rails 當中也有許多方法可以做設定。</p>

<!-- more -->


<pre><code class="ruby">#直接設定
get '/patients/:id', to: 'patients#show'

#REST
#設定 scope 有點像資料夾的概念，可用來區分後台可控制範圍
namespace do 
  #也可用單數 resource (會少了 index，然後不用帶id)
  resources :articles, only: [:index, :show] do 
    member do #Acts on a single resource
      post :follow
    end
    collection do #Acts on a collection of resources
      get :follow
    end
  end
end
</code></pre>

<h1>scope</h1>

<pre><code class="ruby">get 'foo/meetings/:id', :to =&gt; 'events#show'
post 'foo/meetings', :to =&gt; 'events#create'

可以改寫成

scope :controller =&gt; "events", :path =&gt; "/foo", :as =&gt; "bar" do
  get 'meetings/:id' =&gt; :show, :as =&gt; "meeting"
  post 'meetings' =&gt; ':create   , :as =&gt; "meetings"
end

scope :path =&gt; '/api/v1/', :module =&gt; "api_v1", :as =&gt; 'v1' do
  resources :projects
end
</code></pre>

<p><code>:as</code> 增加 vi_path(相對路徑) 和 v1_url(絕對路徑)<br/>
<code>: path</code>網址 <code>/api/v1/projects</code> <br/>
<code>:controller</code> 指定 controller 是哪個<br/>
<code>:module</code> 指定 controller 對應到 ApiV1::ProjectsController</p>

<h1>導向</h1>

<pre><code class="ruby">#靜態
get "/welcome" to: redirect("/hello")

#動態
get '/stories/:name', to: redirect('/articles/%{name}')
</code></pre>

<p><code>redirect</code> 將網址導向到另一個網址</p>

<h1>設定沒有指定的 path 都導向同一個頁面</h1>

<pre><code class="ruby">get "*path", to: "welcome#welcome", :defaults =&gt; { :format =&gt; :json }
</code></pre>

<p><code>defaults</code> 設定此 routes 輸出都是 json 格式</p>

<h1>特殊條件限定</h1>

<pre><code class="ruby">#過濾id
get 'photos/:id', to: 'photos#show', id: /[A-Z]\d{5}/

#黑名單
class BlacklistConstraint
  def initialize
    @ips = Blacklist.retrieve_ips
  end

  def matches?(request)
    @ips.include?(request.remote_ip)
  end
end

Rails.application.routes.draw do
  get '*path', to: 'blacklist#index',
    constraints: BlacklistConstraint.new
end

or

Rails.application.routes.draw do
  get '*path', to: 'blacklist#index',
    constraints: lambda { |request| Blacklist.retrieve_ips.include?(request.remote_ip) }
end
</code></pre>

<h3>子網域</h3>

<p><code>rubyresources :posts, constraints: { subdomain: 'api' }
</code></p>

<p><code>ruby￼constraints subdomain: 'api' do  resources :posts  #http://api.mgleon08.com/posts￼end
</code></p>

<pre><code class="ruby">namespace :api do
  constraints subdomain: 'api' do
    resources :posts
  end
end

#產生兩個 api
#http://api.mgleon08.com/api/posts

constraints subdomain: 'api' do 
    namespace :api, path: '/' do #加上 path 就可以消去後面的     resources :zombies   endend
#上下一樣
namespace :api, path: '/', constraints: { subdomain: 'api' } do
  resources :zombiesend

#http://api.mgleon08.com/posts
</code></pre>

<h1>DRY</h1>

<h3>concern</h3>

<pre><code class="ruby">concern :sociable do |options| 
  resources :comments, options
  resources :categories, options 
  resources :tags, optionsend
resources :messages, concerns: :sociableresources :posts,    concerns: :sociable￼resources :items do  concerns :sociable, only: :createend
</code></pre>

<h3>or</h3>

<pre><code class="ruby">concern :sociable, Sociable
resources :messages, concerns: :sociable 
resources :posts, concerns: :sociable 
resources :items do  concerns :sociable, only: :createend
</code></pre>

<pre><code class="ruby">#app/concerns/sociable.rbclass Sociable  def self.call(mapper, options)    mapper.resources :comments, options 
    mapper.resources :categories, options 
    mapper.resources :tags, options  end 
end
</code></pre>

<h3>合併</h3>

<pre><code class="ruby">resources :zombies, only: :index 
resources :humans, only: :inde
</code></pre>

<pre><code class="ruby">￼with_options only: :index do |list_only|   list_only.resources :zombies   list_only.resources :humans   list_only.resources :medical_kits￼￼￼￼end
</code></pre>

<h1>將 module 名稱改為大寫</h1>

<pre><code class="ruby">#app/controllers/api/posts_controller.rb
￼module Api #通常是camelcase   class PostController &lt; ApplicationController   end
end
</code></pre>

<pre><code class="ruby">#config/initializers/inflections.rb
￼ActiveSupport::Inflector.inflections(:en) do |inflect|￼  inflect.acronym 'API'￼end
</code></pre>

<h1>CURL</h1>

<p>可以用 command line 來測試 get</p>

<pre><code class="ruby">curl -i localhost:3000/posts
#-i 詳細資訊

curl -IH "Accept: application/json" localhost:3000/posts
curl -IH "Accept: application/xml" localhost:3000/posts
#H HEAD

curl -i -X POST -d 'episode[title]=ZombieApocalypseNow' http://localhost:3000/posts

#-X the -X option specifies the method
#-d use -d to send data on the request

curl -Iu 'carlos:secret' http://localhost:3000/posts
#上下一樣
curl -I http://carlos:secret@localhost:3000/episodes
#send Basic Auth credentials with the -u option

curl -IH "Accept: application/json" -u 'carlos:fakesecret' http://localhost:3000/posts
#client asks for JSON

curl -IH "Authorization: Token token=16d7d6089b8fe0c5e19bfe10bb156832" http://localhost:3000/posts
#Set token on Authorization header
</code></pre>

<p>官方文件：<br/>
<a href="http://guides.rubyonrails.org/routing.html">Rails Routing from the Outside In</a><br/>
<a href="http://rails.ruby.tw/routing.html">Rails 路由：深入淺出</a></p>

<p>參考文件：<br/>
<a href="https://ihower.tw/rails4/routing.html">路由(Routing)</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Email 寄信通知]]></title>
    <link href="http://mgleon08.github.com/blog/2016/03/26/rails-email/"/>
    <updated>2016-03-26T09:35:21+08:00</updated>
    <id>http://mgleon08.github.com/blog/2016/03/26/rails-email</id>
    <content type="html"><![CDATA[<p>網站中經常會使用寄信來通知用戶，像是註冊信件，確認更改密碼等等之類的。</p>

<!--more-->


<h1>指令</h1>

<pre><code class="ruby">rails g mailer TestMailer notify_job_apply
</code></pre>

<h1>產生檔案</h1>

<pre><code class="ruby"># app/mailers/application_mailer.rb
class ApplicationMailer &lt; ActionMailer::Base
  default from: "from@example.com"
  layout 'mailer'

 #寄信給多個收件者
 #default to: Proc.new { Admin.pluck(:email) }, from: 'notification@example.com'
end

#app/mailer/test_mailer.rb
class TestMailer &lt; ApplicationMailer
  # Subject can be set in your I18n file at config/locales/en.yml
  # with the following lookup:
  #
  #   en.test_mailer.notify_job_apply.subject
  #
  def notify_job_apply
    @greeting = "Hi"

    #附件檔案
    attachments['filename.jpg'] = File.read('/path/to/filename.jpg')
    mail to: "to@example.org"
    mail to: ["email"], bcc:["sub-email"], subject: "Title"

  end
end
</code></pre>

<h1>信件內容</h1>

<p>因為不是每個人都可以顯示 html 檔案，因此要有兩份</p>

<p>```ruby</p>

<h1>app/views/test_mailer/notify_job_apply.html.erb</h1>

<h1>TestMailer#notify_job_apply</h1>


<p><p>
  &lt;%= @greeting %>, find me in app/views/test_mailer/notify_job_apply.html.erb
</p>
&lt;%= image_tag attachments[&lsquo;image.jpg&rsquo;].url, alt: &lsquo;My Photo&rsquo;, class: &lsquo;photos&rsquo; %>
```</p>

<p>純文字檔</p>

<pre><code class="ruby">#app/views/test_mailer/notify_job_apply.text.erb 
TestMailer#notify_job_apply
&lt;%= @greeting %&gt;, find me in app/views/test_mailer/notify_job_apply.text.erb
</code></pre>

<pre><code class="ruby">#app/model/user.rb
class User &lt; ActiveRecord::Base
  after_save : notify_job_apply_notification, if: : notify_job_apply?
    private    def notify_job_apply_notification
      UserMailer.notify_job_apply(self).deliver 
      #deliver_now! 立即送出
      #deliver_later! 非同步去處理 ex: sidekiq
    end
  edn
</code></pre>

<h1>設定</h1>

<pre><code class="ruby">#config/environments

#忽略任何寄信錯誤
config.action_mailer.raise_delivery_errors = false
#測試用，不會真的寄信
config.action_mailer.delivery_method = :test
#用什麼方式傳遞
config.action_mailer.delivery_method = :smtp
#網站網址
config.action_mailer.default_url_options = { host: "http://localhost:3000" }
#一定要轉 symbol 不然會吃不到
config.action_mailer.smtp_settings = config_for(:email).symbolize_keys
#使用 sidekiq 做背景處理
config.active_job.queue_adapter = :sidekiq 
</code></pre>

<p>設定擋</p>

<pre><code class="ruby">#config/email.yml
development:
  address: "smtp.mailgun.org"
  port: 587
  domain: "google.com"
  authentication: "plain"
  user_name: "postmaster@leon.tw"
  password: "1234567890"
  enable_starttls_auto: true
</code></pre>

<h1>預覽測試</h1>

<p><a href="https://github.com/ryanb/letter_opener">letter_opener</a> 這個 gem 可以不用真的寄信，而是直接在畫面上顯示寄信內容，就可以拿來做測試</p>

<pre><code class="ruby">#config/environments
config.action_mailer.delivery_method = :letter_opener
</code></pre>

<p>官方文件：<br/>
<a href="http://guides.rubyonrails.org/action_mailer_basics.html">Action Mailer</a>  <br/>
<a href="http://rails.ruby.tw/action_mailer_basics.html">Action Mailer 中文</a></p>

<p>參考文件：<br/>
<a href="https://ihower.tw/rails4/actionmailer.html">ActionMailer - E-mail 發送</a><br/>
<a href="https://ihower.tw/blog/archives/3481">如何正確發送(大量) Email 信件</a></p>

<p>gem：<br/>
<a href="https://github.com/madmimi/madmimi-gem">madmimi-gem</a><br/>
<a href="https://github.com/mailgun/mailgun-ruby">mailgun-ruby</a><br/>
<a href="https://github.com/ryanb/letter_opener">letter_opener</a></p>

<p>email:<br/>
<a href="https://madmimi.com/">madmimi.com</a><br/>
<a href="https://www.mailgun.com/">mailgun</a><br/>
<a href="http://aws.amazon.com/tw/ses/">aws</a><br/>
<a href="http://mailchimp.com/">mailchimp</a><br/>
<a href="http://sendgrid.com/">SendGrid</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Lib vs Service Object]]></title>
    <link href="http://mgleon08.github.com/blog/2016/03/26/lib-and-service-object/"/>
    <updated>2016-03-26T09:31:32+08:00</updated>
    <id>http://mgleon08.github.com/blog/2016/03/26/lib-and-service-object</id>
    <content type="html"><![CDATA[<p>大家都知道，fat models, skinny controllers<br/>
但要將 code 放在哪邊，才會比較好維護?這就有很多方式了</p>

<!-- more -->


<h1>/lib:</h1>

<ul>
<li>It is not coupled to my app&rsquo;s domain models.</li>
<li>It can be reused on other projects.</li>
<li>It can potentially become its own gem. Thus, putting it in lib/ is the first step in that direction.</li>
</ul>


<p>簡單的來說，<code>/lib</code> 放的比較像是，很多 project 都可以重複使用，並沒有專屬某個 project，並且可以包成一個 gem 給大家使用。</p>

<p>舉例: <code>FacebookAuth</code> <code>GithubAuth</code></p>

<h1>/app/services:</h1>

<ul>
<li>They tend to know a decent amount about the inner workings of domain models.</li>
<li>Perform work that is specific to business domain in my app.</li>
<li>Tend to be coupled to specific models.</li>
</ul>


<p>而 <code>/app/services</code> 比較像是，專屬於某個 <code>project</code>，並且與 business logic 息息相關，就像是某個服務一樣。</p>

<p>舉例: <code>UserAuthenticator</code> <code>開立發票</code> <code>寄密碼提醒信</code></p>

<h1>Service Object使用時機</h1>

<ul>
<li>The action is complex (e.g. closing the books at the end of an accounting period)</li>
<li>The action reaches across multiple models (e.g. an e-commerce purchase using Order, CreditCard and Customer objects)</li>
<li>The action interacts with an external service (e.g. posting to social networks)</li>
<li>The action is not a core concern of the underlying model (e.g. sweeping up outdated data after a certain time period).</li>
<li>There are multiple ways of performing the action (e.g. authenticating with an access token or password). This is the Gang of Four Strategy pattern.</li>
</ul>


<p>大致上就是</p>

<ol>
<li>邏輯複雜</li>
<li>牽扯到很多 model 關係 (ex: 兩個 model 的資料運算)</li>
<li>與外部服務相關 (ex: slack 通知)</li>
<li>與核心無關 (ex: 定時清理過期數據)</li>
<li>會經常重複使用</li>
</ol>


<h3>約定</h3>

<ul>
<li>一個Service Object 只做一件事。</li>
<li>每個Service Object 一個文件，統一放在app/services 目錄下。</li>
<li>命名採用動作，比如SignEstimate ，而不是EstimateSigner 。</li>
<li>instance級別實現兩個接口，initialize負責傳入所有依賴，call負責調用。</li>
<li>class級別實現一個接口call，用於簡單的實例化Service Object然後調用call 。</li>
<li>call的返回值默認為true/false，也可以有更複雜的形式，比如StatusObject 。</li>
</ul>


<blockquote><p>以上約定主要都是看個人習慣，也有人會放在 <code>app/controller</code> 底下<br/>
<a href="http://vrybas.github.io/blog/2014/08/15/a-way-to-organize-poros-in-rails/">A Way to Organize POROs in Rails</a></p></blockquote>

<h1>concern vs service object</h1>

<ul>
<li>concern</li>
<li>簡單說就是，有許多 model 有共用的邏輯片段，可以拆出來</li>
<li>service object</li>
<li><p>與 concern 不同的地方是，存放的是比較完成的 code，簡單多你丟什麼給它，他就會丟相對應的資料給你。</p></li>
<li><p>兩個搭配使用</p></li>
<li>將許多 service object 搬到 concern</li>
</ul>


<p>參考文件：<br/>
<a href="https://ruby-china.org/topics/18401">什麼時候使用Concerns，什麼時候使用Services？</a><br/>
<a href="https://ruby-china.org/topics/23892">Service Object 整理和小結</a><br/>
<a href="http://brewhouse.io/blog/2014/04/30/gourmet-service-objects.html">Gourmet Service Objects</a><br/>
<a href="http://blog.codeclimate.com/blog/2012/10/17/7-ways-to-decompose-fat-activerecord-models/">7 Patterns to Refactor Fat ActiveRecord Models</a><br/>
<a href="http://motion-express.com/blog/20141007-rails-service-object">Rails code 整理系列- Service Object 初探</a><br/>
<a href="http://stackoverflow.com/questions/16159021/rails-service-objects-vs-lib-classes">Rails service objects vs lib classes</a><br/>
<a href="http://www.johnnyji.me/rails/2015/05/19/lib-folder-vs-services-in-rails.html">Lib Folder vs. Services in Rails</a><br/>
<a href="http://tech.gadii.net/blog/2014/08/25/Service-Objects-%E6%95%B4%E7%90%86%E6%9E%B6%E6%A7%8B/">Service Objects 整理架構</a><br/>
<a href="https://blog.engineyard.com/2014/keeping-your-rails-controllers-dry-with-services">Using Services to Keep Your Rails Controllers Clean and DRY</a> <br/>
<a href="https://www.viget.com/articles/slimming-down-your-models-and-controllers">Slimming Down Your Models and Controllers with Concerns, Service Objects, and Tableless Models</a></p>
]]></content>
  </entry>
  
</feed>
