<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Rails | Leon's Blogging]]></title>
  <link href="http://mgleon08.github.com/blog/categories/rails/atom.xml" rel="self"/>
  <link href="http://mgleon08.github.com/"/>
  <updated>2018-06-23T00:40:50+08:00</updated>
  <id>http://mgleon08.github.com/</id>
  <author>
    <name><![CDATA[LeonJi]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[跟著 DHH 練習 ActionCable]]></title>
    <link href="http://mgleon08.github.com/blog/2018/06/21/rails-action-cable/"/>
    <updated>2018-06-21T23:23:08+08:00</updated>
    <id>http://mgleon08.github.com/blog/2018/06/21/rails-action-cable</id>
    <content type="html"><![CDATA[<p>ActionCable 已經有一陣子了，剛好有時間來玩一下</p>




<!-- more -->




<p>主要跟著 DHH 的影片來練習一下，了解整個 ActionCable 的流程</p>




<ul>
<li><a href="https://www.youtube.com/watch?v=n0WUjGkDFS0">Rails 5: Action Cable demo</a></li>
</ul>




<h1 id="">介紹</h1>




<p>ActionCable 主要是一個 Pub/Sub 模型 + WebSocket 的 Ruby 框架，可以讓 Rails 實現即時通訊的方式</p>




<h3 id="websocket">WebSocket</h3>




<ul>
<li>是一種建立在單一 TCP 連線上的全雙工（full-duplex）通訊管道，可以讓網頁應用程式與伺服器之間做即時性、雙向的資料傳遞。</li>

<li>瀏覽器與伺服器之間若要建立一條 WebSocket 連線，在一開始的交握（handshake）階段中，要先從 HTTP 協定升級為 WebSocket 協定</li>
</ul>




<h3 id="polling">Polling 輪詢</h3>




<ul>
<li>瀏覽器每隔一段時間就自動送出一個 HTTP 請求給 server ，獲取最新的網頁資料</li>

<li>在 server 沒有新資料時，瀏覽器也是會自動送出請求，造成網路資源浪費</li>
</ul>




<h3 id="longpolling">Long-Polling 長時間輪詢</h3>




<ul>
<li>server 在接收到瀏覽器所送出的 HTTP 請求後， server 會等待一段時間，若在這段時間裡 server 有新的資料，它就會把最新的資料傳回給瀏覽器</li>

<li>如果等待的時間到了之後也沒有新資料的話，就會送一個回應給瀏覽器，告知瀏覽器資料沒有更新</li>

<li>如果在資料更新很頻繁的狀況下，長時間輪詢並不會比傳統的輪詢有效率，而且有時候資料量很大時，會造成連續的 polls 不斷產生，反而會更糟糕。</li>
</ul>




<h3 id="streaming">Streaming</h3>




<ul>
<li>讓 server 在接收到瀏覽器所送出 HTTP 請求後，立即產生一個回應瀏覽器的連線，並且讓這個連線持續一段時間不要中斷，而 server 在這段時間內如果有新的資料，就可以透過這個連線將資料馬上傳送給瀏覽器。</li>

<li>由於是建立在 HTTP 協定上的一種傳輸機制，所以有可能會因為代理 server（proxy）或防火牆（firewall）將其中的資料存放在緩衝區中，造成資料回應上的延遲，因此許多使用串流的 Comet 實作會在偵測到有代理 server 的狀況時，改用 Long-Polling 的方式處理。</li>
</ul>




<h3 id="pubsubpublishsubscribepattern">Pub/Sub 發佈/訂閱模式 (Publish/Subscribe Pattern)</h3>




<ul>
<li>發佈/訂閱設計模式是一種在即時通訊上很常用的架構，可以將通訊拆成發佈方和訂閱方，發佈方非同步地將訊息傳送給不定數量的訂閱方。</li>

<li>Pub/Sub 部分可以從你的主應用 Process 外，獨立出來成為一個單獨的運作元件。</li>
</ul>




<h1 id="actioncable">Actioncable 實作</h1>




<ul>
<li>建立新的專案</li>
</ul>




<pre><code class="ruby">rails new campfire
</code></pre>




<ul>
<li>建立 rooms controller</li>
</ul>




<pre><code class="ruby"># show 可以再產生 controller 自動產生 show action &amp; router
rails g controller rooms show
</code></pre>




<ul>
<li>修改 routes</li>
</ul>




<pre><code class="ruby"># config/routes.rb
Rails.application.routes.draw do
  root to: 'rooms#show'
end
</code></pre>




<ul>
<li>建立 message model</li>
</ul>




<pre><code class="ruby"># content:text 可自動在 migration 產生相對應的欄位
rails g model message content:text
rails db:migrate
</code></pre>




<ul>
<li>修改 rooms controller</li>
</ul>




<pre><code class="ruby"># controllers/rooms_controller.rb
class RoomsController &lt; ApplicationController
  def show
    @messages = Message.all
  end
end
</code></pre>




<pre><code class="ruby"># rails console 建立一筆來測試
Message.create!(content: "Hello World!")
</code></pre>




<ul>
<li>修改 rooms/show.html.erb 讓 messages 顯示</li>
</ul>




<pre><code class="ruby"># views/rooms/show.html.erb
&lt;h1&gt;Chat room&lt;/h1&gt;
&lt;div id="messages"&gt;
  &lt;%= render @messages %&gt;
&lt;/div&gt;
</code></pre>




<p>此時就可以 <code>rails s</code> 看一下首頁有沒有東西</p>




<ul>
<li>建立 channel</li>
</ul>




<p>speak 會自動產生 channel 的 action</p>




<p><code>rails g channel room speak</code></p>




<ul>
<li>Server 端 Mount ActionCable</li>
</ul>




<pre><code class="ruby"># config/routes.rb
Rails.application.routes.draw do
  root to: 'rooms#show'
  mount ActionCable.server =&gt; '/cable'
end
</code></pre>




<ul>
<li>修改 room.coffee</li>
</ul>




<p>請注意這邊是 coffee js 因此空格會有差別</p>




<pre><code class="ruby"># assets/javascripts/channels/room.coffee
App.room = App.cable.subscriptions.create "RoomChannel",
  connected: -&gt;
    # Called when the subscription is ready for use on the server

  disconnected: -&gt;
    # Called when the subscription has been terminated by the server

  received: (data) -&gt;
    # Called when there's incoming data on the websocket for this channel
    # 接到 data 後要做什麼處理，目前設定是將 message alert 彈出
    alert data['message']

  speak: (message)-&gt;
  # 傳 message 到 RoomChannel 的 speak action
    @perform 'speak', message: message
</code></pre>




<ul>
<li>修改 room channel 的 speak action</li>
</ul>




<pre><code class="ruby"># channels/room_channel.rb
class RoomChannel &lt; ApplicationCable::Channel
  def subscribed
    # 訂閱的頻道名稱
    stream_from "room_channel"
  end

  def unsubscribed
    # Any cleanup needed when channel is unsubscribed
  end

  def speak(data)
    # 將 message 廣播到 room_channel 的 received function
    ActionCable.server.broadcast("room_channel", message: data['message'])
  end
end
</code></pre>




<p>重新啟動 server，在瀏覽器的 <code>console</code> 執行 </p>




<pre><code class="ruby"># 這個指令會 call client side 的 speak function，也就是 @perform 'speak', message: message
App.room.speak("Hello, World!") 
</code></pre>




<p>就會看到彈出視窗，表示伺服器端已經接受到訊息。</p>




<ul>
<li>新增 text input，讓 client 可以直接輸入 data</li>
</ul>




<pre><code class="ruby"># views/rooms/show.html.erb
&lt;h1&gt;Chat room&lt;/h1&gt;
&lt;div id="messages"&gt;
 &lt;%= render @messages %&gt;
&lt;/div&gt;
&lt;form&gt;
  &lt;label&gt;Say something:&lt;/label&gt;
  &lt;input type="text" data-behavior="room_speaker"&gt;
&lt;/form&gt;
</code></pre>




<ul>
<li>設定輸入後執行的動作</li>
</ul>




<p>記得先安裝 <code>jquery</code>，因為後面會利用 <code>jquery</code> 來操作 <code>dom</code> 和 <code>event</code></p>




<pre><code class="ruby"># Gemfile
gem 'jquery-rails'
</code></pre>




<pre><code class="ruby"># assets/javascripts/application.js
//= require jquery
</code></pre>




<p>請注意這邊是 coffee js 因此空格會有差別</p>




<pre><code class="ruby"># assets/javascripts/channels/room.coffee
App.room = App.cable.subscriptions.create "RoomChannel",
  connected: -&gt;
    # Called when the subscription is ready for use on the server

  disconnected: -&gt;
    # Called when the subscription has been terminated by the server

  received: (data) -&gt;
    # Called when there's incoming data on the websocket for this channel
    # 接到 data 後要做什麼處理，目前設定是將 message alert 彈出
    alert data['message']

  speak: (message)-&gt;
    @perform 'speak', message: message

# 設定在按下鍵盤 Enter 按鍵後，要執行 App.room.speak，就不用透過 console 去輸入
$(document).on 'keypress', '[data-behavior~=room_speaker]', (event) -&gt;
  if event.keyCode is 13 #return
    App.room.speak event.target.value
    event.target.value = ''
    event.preventDefault()
</code></pre>




<p>基本上現在就可以透過輸入框，讓 <code>alert</code> 跳出來了</p>




<h3 id="jobactioncable">透過 job 來執行 ActionCable</h3>




<ul>
<li>實際存取到 db</li>
</ul>




<pre><code class="ruby"># channels/room_channel.rb
class RoomChannel &lt; ApplicationCable::Channel
  def subscribed
    stream_from "room_channel"
  end

  def unsubscribed
    # Any cleanup needed when channel is unsubscribed
  end

  def speak(data)
    # 改成直接 create record 在 db 裡面
    Message.create(content: data['message'])
  end
end
</code></pre>




<ul>
<li>create 後 callback 執行 Job</li>
</ul>




<pre><code class="ruby"># models/message.rb
class Message &lt; ApplicationRecord
  after_create_commit { MessageBroadcastJob.perform_later self }
end
</code></pre>




<ul>
<li>建立 job</li>
</ul>




<pre><code class="ruby">rails g job MessageBroadcast
</code></pre>




<pre><code class="ruby"># jobs/message_broadcast_job.rb
class MessageBroadcastJob &lt; ApplicationJob
  queue_as :default

  def perform(message)
     # perform_later 後會執行的動作
    ActionCable.server.broadcast("room_channel", message: render_message(message))
  end

  private

  def render_message(message)
     # 透過 ApplicationController 將 html code render 回來當一個參數做傳遞
    ApplicationController.renderer.render(partial: 'messages/message', locals: { message: message })
  end
end
</code></pre>




<p>此時 <code>rails s</code> 測試是否正常，因該會有 <code>alert</code> 跳出一段 <code>html code</code></p>




<ul>
<li>修改 received function</li>
</ul>




<pre><code class="ruby"># assets/javascripts/channels/room.coffee
App.room = App.cable.subscriptions.create "RoomChannel",
  connected: -&gt;
    # Called when the subscription is ready for use on the server

  disconnected: -&gt;
    # Called when the subscription has been terminated by the server

  received: (data) -&gt;
    # Called when there's incoming data on the websocket for this channel
    # alert 改成透過 jquery 找到 id='messages' 的 dom，並把回傳來的 html code append 上去
    $('#messages').append data['message']

  speak: (message)-&gt;
    @perform 'speak', message: message

$(document).on 'keypress', '[data-behavior~=room_speaker]', (event) -&gt;
  if event.keyCode is 13 #return
    App.room.speak event.target.value
    event.target.value = ''
    event.preventDefault()
</code></pre>




<p>再重啟一次，這時輸入資料後，畫面會立即新增，可以開雙畫面去做測試，另一邊的畫面是否也是立即新增</p>




<ul>
<li><a href="https://github.com/mgleon08/pratice_action_cable">完成範例程式碼</a></li>

<li><a href="http://mgleon08.github.io/blog/2017/10/06/http-websocket-bot/">之前玩過的 Http Websocket Bot</a></li>
</ul>




<p>參考文件:</p>




<ul>
<li><a href="https://www.youtube.com/watch?v=n0WUjGkDFS0">Rails 5: Action Cable demo</a></li>

<li><a href="https://ihower.tw/rails/actioncable.html">Action Cable 即時通訊</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[樂觀鎖 與 悲觀鎖 Optimistic Locking & Pessimistic Locking]]></title>
    <link href="http://mgleon08.github.com/blog/2017/11/01/optimistic-locking-and-pessimistic-locking/"/>
    <updated>2017-11-01T12:16:10+08:00</updated>
    <id>http://mgleon08.github.com/blog/2017/11/01/optimistic-locking-and-pessimistic-locking</id>
    <content type="html"><![CDATA[<p>有時候在 db 中會發現重複的值，在交易頻繁的網站更是如此，那就需要 lock，rails 也提供方便的方法來鎖!</p>

<!-- more -->


<h2>樂觀鎖</h2>

<ul>
<li>每次去拿數據的時候，都認為別人不會修改數據，所以不會對數據上鎖，這樣在你拿數據的時候別人也能拿和你屬於同一條的數據。</li>
<li>在更新數據時，會判斷在這期間是否有人更新過數據，如果有，則本次更新失敗；否則成功。</li>
<li>由於多個用戶可以同時對同一條數據進行訪問，增加了數據庫的吞吐量。</li>
<li>適合在資源爭用不激烈的時候使用。</li>
</ul>


<blockquote><p>使用樂觀鎖之前需要給數據庫增加一列 :lock_version，Rails 會自動識別這一列，像數據庫提交數據的時候自動帶上。</p></blockquote>

<pre><code class="ruby">retry_times = 3

begin
    @order.with_lock do
        @order.set_paid!
    end
rescue ActiveRecord::StaleObjectError =&gt; e
    retry_times -= 1
    if retry_times &gt; 0
        retry
    else
        raise e
    end
rescue =&gt; e
    raise e
end
</code></pre>

<h2>悲觀鎖</h2>

<ul>
<li>每次去拿數據的時候，都認為別人會修改數據，因此會對數據上鎖，這樣在自己讀寫數據的過程中，別人不能讀寫這條數據，只能等待本次處理結束，才能訪問。</li>
<li>嚴謹、有效的保證了數據的有效行</li>
<li>不能同時對數據庫中同一條數據進行訪問，大大減少了數據庫的吞吐量。</li>
<li>需要持續的與數據庫保持連接，因此不適合web應用</li>
<li>實現起來，比較麻煩。</li>
<li>在資源爭用比較嚴重的時候比較合適</li>
</ul>


<pre><code class="ruby"># rails
account = Account.find(1)
Account.transaction do
    account.lock!
    account.balance -= 100
    account.save! 
end

# 和下面是等價的

account.with_lock do
    account.balance -= 100
    account.save!
end
</code></pre>

<p>參考文件:</p>

<ul>
<li><a href="https://rails.ruby.tw/active_record_querying.html#%E6%9B%B4%E6%96%B0%E6%99%82%E9%8E%96%E5%AE%9A%E8%A8%98%E9%8C%84">更新時鎖定記錄</a></li>
<li><a href="https://ruby-china.org/topics/28963">Rails 中樂觀鎖與悲觀鎖的使用</a></li>
<li><a href="https://openhome.cc/Gossip/HibernateGossip/IsolationLevel.html">簡介隔離層級</a></li>
<li><a href="https://ruby-china.org/topics/28963">Rails 中樂觀鎖與悲觀鎖的使用</a></li>
<li><a href="http://api.rubyonrails.org/classes/ActiveRecord/Locking/Pessimistic.html">ActiveRecord::Locking::Pessimistic</a></li>
<li><a href="http://api.rubyonrails.org/classes/ActiveRecord/Locking/Optimistic.html">ActiveRecord::Locking::Optimistic</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Rails 5 初探]]></title>
    <link href="http://mgleon08.github.com/blog/2017/09/17/rails5/"/>
    <updated>2017-09-17T10:09:39+08:00</updated>
    <id>http://mgleon08.github.com/blog/2017/09/17/rails5</id>
    <content type="html"><![CDATA[<p>Rails5.x.x 已經出來一段時間了，聽說增加了不少東西，來研究順便記錄一下~</p>

<!-- more -->


<h1>後端</h1>

<ul>
<li>rake 有些相關指令可改用 rails (<code>rake db:migrate</code> to <code>rails db:migrate</code>原來的 rake 指令還是可以用)</li>
</ul>


<h1>前端</h1>

<ul>
<li>Yarn 成為預設套件 (<a href="https://github.com/pnpm/node-package-manager-benchmark">yarn 和 npm 效能比較表</a>)</li>
<li><code>jquery-rails</code> 移出 Gemfile (需要的話，可用 yarn 來安裝)</li>
<li>Support webpack</li>
</ul>


<pre><code class="ruby"># Webpack
1.將許多javascript的檔案包在一起，減少request的次數
2.利用 Loader將ES6編譯成ES5的語法，讓瀏覽器能順利讀取
3.整合ES Modules、CommonJS和AMD，等等的模組
</code></pre>

<h1>建立專案 with Webpack &amp; Vue</h1>

<h3>新的專案</h3>

<pre><code class="ruby"># 可改成 react or angular
rails new myapp --webpack=vue
</code></pre>

<h3>原本的專案</h3>

<blockquote><p>記得先 brew install yarn (預設會用 yarn 來安裝)</p></blockquote>

<pre><code class="ruby"># Gemfile
gem 'webpack'

# command
rails webpack:install
rails webpack:install:vue
</code></pre>

<h3>新增檔案</h3>

<p>在 <code>app/javascript/pack</code> 的所有檔案會自動被 webpack compiled</p>

<pre><code class="ruby">app/javascript:
  ├── packs:
  │   # only webpack entry files here
  │   ├── app.vue
  │   ├── application.js
  │   └── hello_vue.js
  └── src:
  │   └── application.css
  └── images:
      └── logo.svg
</code></pre>

<p>Rails 會自動產生 vue component 的 sample</p>

<p>```ruby</p>

<h1>app.vue</h1>

<p><template>
  <div id="app">
    <p></p>
  </div>
</template></p>

<script>
export default {
  data: function () {
    return {
      message: "Hello Vue!"
    }
  }
}
</script>






<h1>hello_vue.js</h1>

<p>import Vue from &lsquo;vue&rsquo;
import App from &lsquo;./app.vue&rsquo;</p>

<p>document.addEventListener(&lsquo;DOMContentLoaded&rsquo;, () => {
  document.body.appendChild(document.createElement(&lsquo;hello&rsquo;))
  const app = new Vue(App).$mount(&lsquo;hello&rsquo;)</p>

<p>  console.log(app)
})
```</p>

<h3>建立 controller</h3>

<pre><code class="ruby">bundle exec rails g controller pages index
</code></pre>

<p>更改 page index 內容 &amp; router</p>

<pre><code class="ruby"># app/views/pages/index.html.erb
&lt;%= javascript_pack_tag 'hello_vue' %&gt;s
&lt;%= stylesheet_pack_tag 'application' %&gt;

# router
root 'pages/index'
</code></pre>

<h3>啟動</h3>

<ul>
<li>啟動後，Webpacker 會自動 Compiling</li>
<li>若是有修改 vue 裡面的內容，頁面重新整理會在自動 Compiling</li>
</ul>


<pre><code class="ruby">rails s

Started GET "/" for 127.0.0.1 at 2017-09-17 11:58:29 +0800
Processing by PagesController#index as HTML
  Rendering pages/index.html.erb within layouts/application
[Webpacker] Compiling…
[Webpacker] Compiled all packs in /Users/leon/Code/practice/rails5/myapp/public/packs
  Rendered pages/index.html.erb within layouts/application (4828.5ms)
Completed 200 OK in 6547ms (Views: 6249.7ms)
</code></pre>

<ul>
<li>也可以手動啟動 Webpack Dev Servers</li>
<li>這樣修改 vue 的內容，只要檔案 save 就會自動 Compiling，不需要面重新整理 (vue-hot-reload)</li>
</ul>


<blockquote><p>開兩個 terminal</p></blockquote>

<pre><code class="ruby"># 啟動
rails s
bin/webpack-dev-server
</code></pre>

<blockquote><p>forman gem</p></blockquote>

<pre><code class="ruby"># Gemfile
gem 'foreman'

# Procfile
backend: bin/rails s -p 3000
frontend: bin/webpack-dev-server

# 啟動
foreman start
</code></pre>

<p>教學文件:</p>

<ul>
<li><a href="http://railsbook.tw/table-of-content">為你自己學 Ruby on Rails</a></li>
<li><a href="https://railstutorial-china.org/book/">Ruby on Rails 課程</a></li>
</ul>


<p>參考文件:</p>

<ul>
<li><a href="http://mgleon08.github.io/blog/2016/11/29/front-end-tools">前端工具整理</a></li>
<li><a href="https://medium.com/@hpux/rails-5-1-loves-javascript-a1d84d5318b">Rails 5.1 loves Javascript</a></li>
<li><a href="https://mkdev.me/en/posts/rails-5-vue-js-how-to-stop-worrying-and-love-the-frontend">Rails 5 &amp; Vue.js: how to stop worrying and love the frontend</a></li>
<li><a href="https://ruby-china.org/topics/32904">Rails 5.1 使用 yarn 和 webpack 實戰 (vue, 建構等)</a></li>
</ul>


<p>webpack</p>

<ul>
<li><a href="https://github.com/rails/webpacker">webpack gem</a></li>
<li><a href="https://webpack.github.io/docs/webpack-dev-server.html">webpack-dev-server</a></li>
<li><a href="https://gorails.com/episodes/using-webpack-in-rails-with-webpacker-gem">Using Webpack gem in rails (video)</a></li>
</ul>


<p>Vue</p>

<ul>
<li><a href="https://gorails.com/episodes/how-to-use-vuejs-and-turbolinks-together">How to use Vue.js and Turbolinks together</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Import CSV Into Rails]]></title>
    <link href="http://mgleon08.github.com/blog/2017/02/14/import-csv-into-rails/"/>
    <updated>2017-02-14T17:39:16+08:00</updated>
    <id>http://mgleon08.github.com/blog/2017/02/14/import-csv-into-rails</id>
    <content type="html"><![CDATA[<p>有時候會需要匯入 csv 的檔案, 就可以用 seed 的方式來處理</p>

<!-- more -->


<pre><code class="ruby">#db/seeds/import_csv.rb
require 'csv'

imprt_csv = "#{Rails.root}/lib/seeds/import.csv"

CSV.foreach(csv_text, headers: true) do |row|
  Item.new(name: row[:name])
end
</code></pre>

<p>檔案可以放在 <code>lib/csv/xx.csv</code></p>

<p>最後用 task 方式去跑 seed 來匯入 <a href="http://mgleon08.github.io/blog/2016/07/04/custom-seed-file/">Custom Seed File</a></p>

<p>參考文件：</p>

<ul>
<li><a href="https://www.mattboldt.com/importing-massive-data-into-rails/">Importing Massive CSV Data Into Rails</a></li>
<li><a href="http://stackoverflow.com/questions/4410794/ruby-on-rails-import-data-from-a-csv-file">Ruby on Rails - Import Data from a CSV file</a></li>
<li><a href="https://gist.github.com/arjunvenkat/1115bc41bf395a162084">How to seed a Rails database with a CSV file</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Rails With GraphQL API]]></title>
    <link href="http://mgleon08.github.com/blog/2016/12/16/graphql/"/>
    <updated>2016-12-16T17:31:16+08:00</updated>
    <id>http://mgleon08.github.com/blog/2016/12/16/graphql</id>
    <content type="html"><![CDATA[<p>GraphQL 是 facebook 所開放的查詢語言</p>

<!-- more -->


<blockquote><p>GraphQl is a query language for your API</p></blockquote>

<ul>
<li>GraphQL 是 facebook 所開放的查詢語言，可以透過定義的schema系統將複雜的邏輯拆分成細粒度的資料結構，讓前端能夠透過GraphQL提供的類型查詢系統，自由定製請求數據的能力。</li>
<li>GraphQL 本身適合對數據力度小，需求變更頻繁的場景，與 RESTful 相反</li>
</ul>


<h3>GraphQL Look Like</h3>

<pre><code class="ruby">{
  user(id: 1) {
    id,
    name,
    friends {
      name
    }
  }
}
</code></pre>

<h3>Response</h3>

<pre><code class="ruby">{
  "user" : {
    "id": 1,
    "name": "Marc-Andre Giroux",
    "friends": [
      {
        "name": "Joe Bro"
      },
      {
        "name": "Johny Yolo"
      }
    ]
  }
}
</code></pre>

<h1>Rails with GraphQL API</h1>

<p><a href="https://github.com/rmosolgo/graphql-ruby">graphql-ruby</a></p>

<p>主要有五個步驟</p>

<ul>
<li>新增 ruby gem <a href="https://github.com/rmosolgo/graphql-ruby">graphql-ruby</a></li>
<li>Declare Query Type</li>
<li>Build a Schema</li>
<li>Add GraphQL end_point</li>
</ul>


<h3>Ruby gem</h3>

<pre><code class="ruby">gem 'graphql'
</code></pre>

<pre><code class="ruby">$ bundle install
</code></pre>

<h3>Declare Query Type</h3>

<p>All Types (<code>!</code> marks a field as &ldquo;non-null&rdquo;)</p>

<ul>
<li>string</li>
<li>int</li>
<li>float</li>
<li>boolean</li>
<li>ID</li>
</ul>


<pre><code class="ruby"># app/graph/types/post_type.rb
PostType = GraphQL::ObjectType.define do
  name "Post"
  description "A blog post"
  # `!` marks a field as "non-null"
  field :id, !types.ID
  field :title, !types.String
  field :body, !types.String
  field :comments, types[!CommentType]
end
</code></pre>

<pre><code class="ruby"># app/graph/types/comment_type.rb
CommentType = GraphQL::ObjectType.define do
  name "Comment"
  field :id, !types.ID
  field :body, !types.String
  field :created_at, !types.String
end
</code></pre>

<p>Make sure you add this line to your application.rb for rails to autoload the types</p>

<pre><code class="ruby">#config/application.rb
config.autoload_paths &lt;&lt; Rails.root.join('app', 'graph')
config.autoload_paths &lt;&lt; Rails.root.join('app', 'graph', 'types')
</code></pre>

<h3>Build a Schema</h3>

<pre><code class="ruby">#app/graph/types/query_type.rb
#query root

QueryType = GraphQL::ObjectType.define do
  name "Query"
  description "The query root of this schema"

  field :post do
    type PostType
    argument :id, !types.ID #argument 可以根據哪些欄位去查詢
    description "Find a Post by ID"
    resolve -&gt;(obj, args, ctx) { Post.find(args["id"]) }
  end
end
</code></pre>

<pre><code class="ruby"># app/graph/schema.rb
Schema = GraphQL::Schema.define do
  query QueryType
end
</code></pre>

<h3>Router</h3>

<pre><code class="ruby">#config/routes.rb
resources :queries, via: [:post, :options]
</code></pre>

<pre><code class="ruby"># app/controller/queries_controller.rb
class QueriesController &lt; ApplicationController
  def create
    query_string = params[:query]
    query_variables = params[:variables] || {}
    result = BlogSchema.execute(query_string, variables: query_variables)
    render json: result
  end
end
</code></pre>

<h3>Execute queries</h3>

<pre><code class="ruby">curl -XPOST -d 'query={ blog(id: 1) { title content }}' http://localhost:3000/queries
</code></pre>

<ul>
<li><a href="http://graphql.org/">graphql.org</a></li>
<li><a href="http://graphql-swapi.parseapp.com/">GraphiQL</a></li>
<li><a href="https://github.com/rmosolgo/graphql-ruby">graphql-ruby gem</a></li>
<li><a href="https://www.youtube.com/watch?v=tmy4oZ_sVmk">15 - 夏俊晨 - GraphQL on Rails (video)</a></li>
<li><a href="https://speakerdeck.com/onlimii/graphql-on-rails">GraphQL on Rails</a></li>
<li><a href="http://mgiroux.me/2015/getting-started-with-rails-graphql-relay/">Getting started with Rails and GraphQL</a></li>
<li><a href="http://www.jianshu.com/p/4355bd92c216">GraphQL on Rails(一) GraphQL介紹</a></li>
<li><a href="http://www.jianshu.com/p/f7e435a17960">GraphQL on Rails(二) GraphQL介紹</a></li>
<li><a href="http://www.jianshu.com/p/f9f20602af5a">GraphQL on Rails(三) GraphQL介紹</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
