<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Rails | Leon's Blogging]]></title>
  <link href="http://mgleon08.github.com/blog/categories/rails/atom.xml" rel="self"/>
  <link href="http://mgleon08.github.com/"/>
  <updated>2016-03-08T11:40:38+08:00</updated>
  <id>http://mgleon08.github.com/</id>
  <author>
    <name><![CDATA[LeonJi]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[例外處理 Rescue Exception]]></title>
    <link href="http://mgleon08.github.com/blog/2016/02/04/rescue-exception/"/>
    <updated>2016-02-04T21:51:38+08:00</updated>
    <id>http://mgleon08.github.com/blog/2016/02/04/rescue-exception</id>
    <content type="html"><![CDATA[<p>在 rails 當中，當發生例外時就會爆錯，畫面就會不見。<br/>
但有時我們並不希望讓它這樣，因此可以用 rescue 才處理掉這些例外發生時，該執行的動作。</p>

<!-- more -->


<h1>例外處理</h1>

<pre><code class="ruby">begin
  # 有可能發生例外的處理動作
rescue =&gt; e
  # 例外發生時的處理措施
ensure
  # 無論有沒有發生例外，這一段都一定會執行
end
</code></pre>

<h1>分開處理例外</h1>

<p>可以給予不同例外，執行不同動作</p>

<p>順序應為最特殊為第一位，以此類推<br/>
若要在最後包含所有例外，可以使用rescue Exception</p>

<pre><code class="ruby">begin
  # 有可能發生例外的處理動作
rescue ArgumentError =&gt; e
  # 例外發生時的處理措施
rescue TypeError =&gt; e
  # 例外發生時的處理措施
rescue Exception =&gt; e
  # 例外發生時的處理措施
end
</code></pre>

<p>如果沒有指定變數，例外物件會自動存放在：<code>$!</code>及<code>$@</code>變數中<br/>
<code>$!</code>：最後發生例外的物件<br/>
<code>$@</code>：呈現最後例外所發生的位置和資計</p>

<h1>重來</h1>

<p>例外發生後，再重新執行一次</p>

<pre><code class="ruby">begin
  # 有可能發生例外的處理動作
rescue =&gt; e
  retry #重新再跑
end
</code></pre>

<h1>例外語法的簡化</h1>

<p>如果例外 begin &amp; end 的範圍剛好就是整個方法的範圍，就可以省略。</p>

<pre><code class="ruby">def rescue
  #有可能發生例外的處理動作
rescue
  #例外發生時的處理措施
ensure
  #無論是否發生例外都會執行
end
</code></pre>

<h1>自行產生例外</h1>

<pre><code class="ruby">def test
  raise StandardError, "test error"
  #丟例外出來 raise(例外名稱, 例外訊息)
rescue =&gt; e
  binding.pry
end
</code></pre>

<p>參考文件：<br/>
<a href="http://blog.xuite.net/yschu/wretch/104912690-Ruby+-+Chapter+09+%E4%BE%8B%E5%A4%96%E8%99%95%E7%90%86(exception">Ruby - Chapter 09 例外處理(exception)</a>)<br/>
<a href="http://blog.tonycube.com/2011/07/ruby8.html">Ruby學習筆記(8) – 錯誤與例外處理</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[自定 Module 和 Class 檔案]]></title>
    <link href="http://mgleon08.github.com/blog/2016/02/01/customer-module-class/"/>
    <updated>2016-02-01T22:19:13+08:00</updated>
    <id>http://mgleon08.github.com/blog/2016/02/01/customer-module-class</id>
    <content type="html"><![CDATA[<p>在 rails 當中，可以自訂一些好用方便的檔案，在適當的時機來使用。</p>

<!-- more -->


<h1>method</h1>

<p>在 <code>lib/require/object.rb</code>，可以自行新增 class</p>

<pre><code class="ruby">class Object
  def is?(*objects)
    for object in objects
      return true if self == object
    end
    false
  end
end
</code></pre>

<h1>require</h1>

<p>但要記得要在使用的檔案，先 require 才能夠使用</p>

<p>也可以直接在 <code>config/initializer</code> 新增 <code>require.rb</code> 檔案，將檔案 require 進來，就不用每個檔案上面都 require 了。</p>

<blockquote><p><code>initializer</code> 裡面的檔案，程式一執行就會全部都執行了</p></blockquote>

<pre><code class="ruby">#單個檔案
require "#{Rails.root}/lib/require/object.rb"

#多個檔案
Dir["#{Rails.root}/lib/require/object.rb"].each do |file|
  require file
end

#lib 底下所有檔案
Dir["#{Rails.root}/lib/**/*.rb"].each do |file|
  require file
end

# 檔案 &amp;&amp; 資料夾名稱可自訂 ex: monkey_patches
</code></pre>

<h1>使用</h1>

<pre><code class="ruby">"hello".is?("yes", "no", "hello)
#=&gt; true

"hello".is?("yes", "no")
#=&gt; false
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[如何測試上傳檔案 Rspec Upload File]]></title>
    <link href="http://mgleon08.github.com/blog/2016/02/01/rspec-upload-file/"/>
    <updated>2016-02-01T21:32:55+08:00</updated>
    <id>http://mgleon08.github.com/blog/2016/02/01/rspec-upload-file</id>
    <content type="html"><![CDATA[<p>rails 本身就有內建的 helper 可以很快的建造假的檔案，然後就可以測試上傳的功能了。</p>

<!-- more -->


<h1>建立資料夾</h1>

<p><code>spec/fixtures/files</code></p>

<p>在資料夾裡放入用來測試的檔案</p>

<h1>Rack::Test::UploadedFile.new</h1>

<p><code>Rack::Test::UploadedFile.new('path','mime-type')</code></p>

<pre><code class="ruby">Rack::Test::UploadedFile.new('test.jpg', "image/jpeg")
Rack::Test::UploadedFile.new(File.open(File.join(Rails.root, '/spec/fixtures/files/1.jpg')), "image/jpeg")
</code></pre>

<h1>fixture_file_upload</h1>

<p>上面的簡短版本 <code>fixture_file_upload('path','mime-type')</code></p>

<pre><code class="ruby">@file1 = fixture_file_upload('files/1.jpg', 'image/jpg')
@file2 = fixture_file_upload('files/2.pdf', 'application/pdf')
</code></pre>

<p>以上兩個擇一，這樣就可以在 <code>create</code> 將 <code>@file</code> 帶入到 params</p>

<p>官方文件：<br/>
<a href="http://www.rubydoc.info/github/brynary/rack-test/Rack/Test/UploadedFile">Class: Rack::Test::UploadedFile</a><br/>
<a href="http://apidock.com/rails/ActionDispatch/TestProcess/fixture_file_upload">fixture_file_upload</a></p>

<p>參考文件：<br/>
<a href="http://stackoverflow.com/questions/1178587/how-do-i-test-a-file-upload-in-rails">How do I test a file upload in rails?</a><br/>
<a href="https://ruby-china.org/topics/21057">[求助] 文件上传的测试代码怎么写</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[自訂 Validation]]></title>
    <link href="http://mgleon08.github.com/blog/2016/01/31/custom-validation/"/>
    <updated>2016-01-31T12:29:33+08:00</updated>
    <id>http://mgleon08.github.com/blog/2016/01/31/custom-validation</id>
    <content type="html"><![CDATA[<p>當內建的驗證沒有自己的需求時，可以自訂驗證的 method 來使用。</p>

<!-- more -->


<pre><code class="ruby">class Picture &lt; ActiveRecord::Base
  belongs_to :user
  validate  :picture_size  #注意沒有加 's'

  private

  # 驗證圖片的大小
  def picture_size
    if picture.size &gt; 5.megabytes
      errors.add(:picture, "should be less than 5MB")
      #errors[:picture] &lt;&lt; "should be less than 5MB"
    end
  end
end
</code></pre>

<h1>Performing Custom Validations</h1>

<p>也可以將 <code>validator</code> 拉出來，比較乾淨。</p>

<p><code>app/validators/photo_size_validator.rb</code></p>

<pre><code class="ruby">class PhotoSizeValidator &lt; ActiveModel::Validator
  def validate record
    unless validated? record
      record.errors[:file_size] &lt;&lt; 'must be less than 1 MB'
    end
  end

  private

  def validated? record
    record.file.size &lt; 1.megabytes
  end
end
</code></pre>

<p><code>models/photo.rb</code></p>

<pre><code class="ruby">class Material::Banner &lt; ActiveRecord::Base
  include ActiveModel::Validations
  validates_with PhotoSizeValidator
end
</code></pre>

<p>官方文件：<br/>
<a href="http://guides.rubyonrails.org/active_record_validations.html">Active Record 驗證</a><br/>
<a href="http://rails.ruby.tw/active_record_validations.html">Active Record 驗證 中文</a></p>

<p>參考文件：<br/>
<a href="https://ihower.tw/rails4/activerecord-lifecycle.html">ActiveRecord - 資料驗證及回呼</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Association Supports 方法]]></title>
    <link href="http://mgleon08.github.com/blog/2016/01/31/association-supports/"/>
    <updated>2016-01-31T11:54:15+08:00</updated>
    <id>http://mgleon08.github.com/blog/2016/01/31/association-supports</id>
    <content type="html"><![CDATA[<p>在 model 和 model 之間，經常要建立對應的關聯，rails 也提供很多 Supports 的 helper</p>

<!-- more -->


<pre><code class="ruby">class User &lt; ActiveRecord::Base
    has_many :microposts, dependent: :destroy
    has_many :active_relationships,  class_name:  "Relationship", foreign_key: "follower_id", dependent: :destroy
    has_many :passive_relationships, class_name:  "Relationship", foreign_key: "followed_id", dependent: :destroy
    has_many :following, through: :active_relationships,  source: :followed
    has_many :followers, through: :passive_relationships, source: :follower
end
</code></pre>

<ul>
<li><p><code>through</code> 透過關聯來建立另一個關聯集合，用於建立多對多的關係</p></li>
<li><p><code>class_name</code> 變更關聯的類別名稱</p></li>
</ul>


<p>可以用這個方式，自己關聯自己，像是要上面，User 可以 follower 很多個 User</p>

<blockquote><p>rails 慣例是 model 名稱，所以不用另外加 class_name</p></blockquote>

<ul>
<li><code>foreign_key</code> 可以修改外鍵名稱</li>
</ul>


<blockquote><p>rails 外鍵慣例是關聯的 Model 名稱加上 _id 後綴</p></blockquote>

<ul>
<li><code>dependent</code></li>
</ul>


<p>設定當物件刪除時，如何處理依賴它的資料</p>

<pre><code class="ruby">class Event &lt; ActiveRecord::Base
  has_many :attendees, :dependent =&gt; :destroy
end

#:destroy 把依賴的attendees也一併刪除，並且執行Attendee的destroy回呼
#:delete 把依賴的attendees也一併刪除，但不執行Attendee的destroy回呼
#:nullify 這是預設值，不會幫忙刪除attendees，但會把attendees的外部鍵event_id都設成NULL
#:restrict_with_exception 如果有任何依賴的attendees資料，則連event都不允許刪除。執行刪除時會丟出錯誤例外ActiveRecord::DeleteRestrictionError。
#:restrict_with_error 不允許刪除。執行刪除時會回傳false，在@event.errors中會留有錯誤訊息。
</code></pre>

<ul>
<li><code>source</code></li>
</ul>


<p>搭配through設定使用，當關聯的名稱不一致的時候，需要加上source指名是哪一種物件。</p>

<ul>
<li><code>counter_cache</code> 參考之前文章 <a href="http://mgleon08.github.io/blog/2015/12/20/counter-cache/">counter-cache</a></li>
</ul>


<pre><code class="ruby">class Book &lt; ActiveRecord::Base
  has_many :pages
end

class Page &lt; ActiveRecord::Base
  belongs_to :book, :counter_cache =&gt; true
end

#設定成 ture，就會自動去找 pages_count 欄位，若要指定欄位則是 counter_cache: :count_of_pages
</code></pre>

<ul>
<li><code>inverse_of</code></li>
</ul>


<p>關聯另一端的關聯名稱。</p>

<blockquote><p>belongs_to 無法與 :polymorphic 同時使用。
has_one 無法與 :through 或 :as 同時使用。</p></blockquote>

<ul>
<li><code>polymorphic</code> &amp; <code>as</code> 參考之前文章 <a href="http://mgleon08.github.io/blog/2015/12/20/ruby-on-rails-polymorphic-associations-and-sti/">polymorphic</a></li>
</ul>


<pre><code class="ruby">class Comment &lt; ActiveRecord::Base
  belongs_to :commentable, :polymorphic =&gt; true
end

class Article &lt; ActiveRecord::Base
  has_many :comments, :as =&gt; :commentable
end

class Photo &lt; ActiveRecord::Base
  has_many :comments, :as =&gt; :commentable
end
</code></pre>

<ul>
<li><code>touch</code>
touch 為 true 時，儲存或刪除關聯物件時，關聯物件的 updated_at 或 updated_on 的時間戳會自動設成當前時間</li>
</ul>


<pre><code class="ruby">class Order &lt; ActiveRecord::Base
  belongs_to :customer, touch: true
  #更改欄位 touch: :orders_updated_at
end
</code></pre>

<ul>
<li><p><code>validate</code> 預設為 false，儲存物件時不會驗證關聯物件</p></li>
<li><p><code>primary_key</code> 可以修改主鍵名稱</p></li>
</ul>


<h1>Scope</h1>

<ul>
<li><code>where</code></li>
</ul>


<pre><code class="ruby">class Order &lt; ActiveRecord::Base
  belongs_to :customer, -&gt; { where active: true }
end
</code></pre>

<ul>
<li><code>includes</code></li>
</ul>


<p>經常性使用 <code>@line_item.order.customer</code> 就可以加上</p>

<pre><code class="ruby">class LineItem &lt; ActiveRecord::Base
  belongs_to :order, -&gt; { includes :customer }
end

class Order &lt; ActiveRecord::Base
  belongs_to :customer
  has_many :line_items
end

class Customer &lt; ActiveRecord::Base
  has_many :orders
end
</code></pre>

<ul>
<li><code>readonly</code></li>
</ul>


<p>如果設定了 readonly 選項，則關聯物件取出時為唯讀。</p>

<ul>
<li><code>select</code></li>
</ul>


<p>select 方法可以覆寫用來取出關聯的 SELECT 子句。預設會取出所有欄位</p>

<h3>has_many 額外方式</h3>

<p>條件也可透過 Hash 指定</p>

<pre><code class="ruby">class Customer &lt; ActiveRecord::Base
  has_many :confirmed_orders, -&gt; { where confirmed: true },
                              class_name: "Order"
end
</code></pre>

<p>用 Hash 的 where，產生出來的記錄會自動使用 Hash 的作用域。</p>

<p>上例中，使用 <code>@customer.confirmed_orders.create</code> 或 <code>@customer.confirmed_orders.build</code> 會建立出 confirmed 欄位為 true 的訂單</p>

<ul>
<li><code>group</code> 對結果做分組</li>
</ul>


<pre><code class="ruby">has_many :line_items, -&gt; { group 'orders.id' }
</code></pre>

<ul>
<li><code>limit</code> 限制透過關聯取出物件的數量</li>
</ul>


<pre><code class="ruby"> has_many :recent_orders, -&gt; { order('order_date desc').limit(100) }
</code></pre>

<ul>
<li><code>offset</code> 指定開始從關聯取出物件的偏移量</li>
</ul>


<pre><code class="ruby">has_many :orders, -&gt; { offset(11) }
</code></pre>

<ul>
<li><code>order</code> 指定關聯物件取出後的排序方式</li>
</ul>


<pre><code class="ruby">has_many :orders, -&gt; { order "date_confirmed DESC" }
</code></pre>

<ul>
<li><code>distinct</code> 確保集合中沒有重複的物件</li>
</ul>


<pre><code class="ruby">has_many :articles, -&gt; { distinct }, through: :readings
</code></pre>

<p>若想確保不插入重複的資料到資料庫（這樣取出來就確定是不重複的記錄了），應該要在資料表上新增一個唯一性的索引。</p>

<p>舉例來說，如果有 person_articles 資料表，想確保所有文章不重複，可加入下面這個遷移</p>

<pre><code class="ruby">add_index :person_articles, :article, unique: true
</code></pre>

<p>不要使用 include? 來確保唯一性，因為多個使用者可能同時加入文章，可能會導致競態條件（Race Condition）</p>

<pre><code class="ruby">person.articles &lt;&lt; article unless person.articles.include?(article)
</code></pre>

<ul>
<li><code>extending</code> 指定一個模組名稱，用來擴充關聯代理（association proxy）</li>
</ul>


<pre><code class="ruby">module FindRecentExtension
  def find_recent
    where("created_at &gt; ?", 5.days.ago)
  end
end

class Customer &lt; ActiveRecord::Base
  has_many :orders, -&gt; { extending FindRecentExtension }
end

class Supplier &lt; ActiveRecord::Base
  has_many :deliveries, -&gt; { extending FindRecentExtension }
end
</code></pre>

<p>官方文件：
<a href="http://guides.rubyonrails.org/association_basics.html#has-many-association-reference">has_many Association Reference</a>
<a href="http://rails.ruby.tw/association_basics.html#has-many-%E9%97%9C%E8%81%AF%E5%8F%83%E8%80%83%E6%89%8B%E5%86%8A">has_many Association Reference 中文</a>
<a href="http://rails.ruby.tw/association_basics.html#belongs-to-%E9%97%9C%E8%81%AF%E5%8F%83%E8%80%83%E6%89%8B%E5%86%8A">belongs_to 關聯手冊</a>
<a href="http://rails.ruby.tw/association_basics.html#has-one-%E9%97%9C%E8%81%AF%E5%8F%83%E8%80%83%E6%89%8B%E5%86%8A">has_one 關聯手冊</a>
<a href="http://rails.ruby.tw/association_basics.html#has-many-%E9%97%9C%E8%81%AF%E5%8F%83%E8%80%83%E6%89%8B%E5%86%8A">has_many 關聯</a></p>

<p>參考文件：
<a href="https://ihower.tw/rails4/activerecord-relationships.html">ActiveRecord - 資料表關聯</a></p>
]]></content>
  </entry>
  
</feed>
