<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Rails | Leon's Blogging]]></title>
  <link href="http://mgleon08.github.com/blog/categories/rails/atom.xml" rel="self"/>
  <link href="http://mgleon08.github.com/"/>
  <updated>2019-02-11T01:31:05+08:00</updated>
  <id>http://mgleon08.github.com/</id>
  <author>
    <name><![CDATA[LeonJi]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Rails + Puma + Nginx + MySQL With Docker]]></title>
    <link href="http://mgleon08.github.com/blog/2019/01/13/rails-puma-nginx-mysql-with-docker/"/>
    <updated>2019-01-13T23:57:34+08:00</updated>
    <id>http://mgleon08.github.com/blog/2019/01/13/rails-puma-nginx-mysql-with-docker</id>
    <content type="html"><![CDATA[<!-- more -->


<p>將 Rails + Puma,  Nginx,  MySQL 都拆開成各自的 container，並透過 docker-compose 將多個 container 串起來，各司其職，協同服務。</p>

<ul>
<li>Nginx 在最前面解析請求並處理靜態資源</li>
<li>Puma 位於 Nginx 於 Rails 程序之間，用於處理動態的請求；最後面還有一個數據存儲的 MySQL</li>
</ul>


<p>container 分配</p>

<ul>
<li>app - 用來啟動 Rails + Puma</li>
<li>web - 存放 nginx，負責解析各種外部請求，處理靜態的資源
(靜態資源就是運行 rake assets:precompile 生成在 public/assets 中的內容)</li>
<li>db - MySQL</li>
</ul>


<p>在現有的 rails project 加上 docker 所需的 file</p>

<pre><code class="ruby">rails_project
├── docker
│   └── app
│       └── Dockerfile
│   └── db
│       └── grant_user.sql
│   └── web
│       ├── Dockerfile
│       └── nginx.conf
├── docker-compose.yml
└── .env
</code></pre>

<h3>docker/app/Dockerfile</h3>

<pre><code class="ruby"># Base image
FROM ruby:2.5.1

# Install plugin
RUN apt-get update -qq &amp;&amp; apt-get install -y build-essential vim

# Install mysql
RUN apt-get install -y default-libmysqlclient-dev

# Install nodejs
RUN curl -sL https://deb.nodesource.com/setup_11.x | bash - &amp;&amp;\
    apt-get install -y nodejs

# Clears out the local repository of retrieved package files
RUN apt-get -q clean

# Set an environment variable where the Rails app is installed to inside of Docker image
ENV APP_PATH /usr/src/app
RUN mkdir -p $APP_PATH

# Set working directory
WORKDIR $APP_PATH

# Setting env up
ENV RAILS_ENV production
ENV RACK_ENV production
# Setting local
ENV LC_ALL C.UTF-8
# Setting timezone
ENV TZ Asia/Taipei
RUN cp /usr/share/zoneinfo/$TZ /etc/localtime &amp;&amp; echo $TZ &gt; /etc/timezone

# COPY Gemfile &amp; Gemfil.lock
COPY Gemfile* $APP_PATH/

# Run bundle
RUN bundle install --jobs 20 --retry 5 --without development test --path vendor/bundle

# Adding project files
COPY . $APP_PATH/

# Build Frond-End
RUN RAILS_ENV=$RAILS_ENV bundle exec rake assets:precompile

EXPOSE 3000

CMD ["bundle", "exec", "puma", "-C", "config/puma.rb"]
</code></pre>

<h3>docker/web/Dockerfile</h3>

<pre><code class="ruby"># Base image
FROM nginx:1.15.8

# Install dependencies
RUN apt-get update -qq &amp;&amp; apt-get -y install apache2-utils vim

# Establish where Nginx should look for files
ENV RAILS_ROOT /usr/src/app
# Setting local
ENV LC_ALL C.UTF-8
# Setting timezone
ENV TZ Asia/Taipei
RUN cp /usr/share/zoneinfo/$TZ /etc/localtime &amp;&amp; echo $TZ &gt; /etc/timezone

# Set our working directory inside the image
WORKDIR $RAILS_ROOT

# create log directory
RUN mkdir log

# copy over static assets
COPY public public/

# Copy Nginx config template
COPY docker/web/nginx.conf /tmp/docker.nginx

# substitute variable references in the Nginx config template for real values from the environment
# put the final config in its place
RUN envsubst '$RAILS_ROOT' &lt; /tmp/docker.nginx &gt; /etc/nginx/conf.d/default.conf
EXPOSE 80

# Use the "exec" form of CMD so Nginx shuts down gracefully on SIGTERM (i.e. `docker stop`)
CMD [ "nginx", "-g", "daemon off;" ]
</code></pre>

<h3>docker/web/nginx.conf</h3>

<pre><code class="ruby"># define our application server

upstream rails_app {
  # The app service 3000 port that points to the docker-compose definition
   server app:3000;
}

server {
   listen 80;
   # define your domain or IP
   server_name localhost;

   # define the public application root
   root   $RAILS_ROOT/public;
   index  index.html;

   # define where Nginx should write its logs
   access_log $RAILS_ROOT/log/nginx.access.log;
   error_log $RAILS_ROOT/log/nginx.error.log;

   # deny requests for files that should never be accessed
   # ~ regular 區分大小寫, .env / .git
   location ~ /\. {
      deny all;
   }

   # ~* regular 不分大小寫, .rb / .log
   location ~* ^.+\.(rb|log)$ {
      deny all;
   }

   # serve static (compiled) assets directly if they exist (for rails production)
   location ~ ^/(assets|images|javascripts|stylesheets|swfs|system)/   {
      # $uri: localhost/404.html，則 $uri 為 `/404.html`
      # @rails: 後面定義的 location @rails
      # 如果 url 匹配進來，則先按 $uri 處理，若沒有找到，則交給 @rails 處理
      try_files $uri @rails;
      # close access log
      access_log off;
      # to serve pre-gzipped version
      # 設定為 `on` ，在處理壓縮之前，先查找已經預壓縮的文件（.gz）
      # 避免每次對同一個文件進行重複的壓縮處理
      gzip_static on;

      expires max;
      # public 對每個用戶有效; private 對當前用戶有效
      add_header Cache-Control public;

      add_header Last-Modified "";
      add_header ETag "";
      break;
   }

   # send non-static file requests to the app server
   location / {
      try_files $uri @rails;
   }

   location @rails {
      internal; # 只能被內部的請求呼叫，外部的呼叫請求會返回 'Not found'
      proxy_set_header  X-Real-IP  $remote_addr;
      proxy_set_header  X-Forwarded-For $proxy_add_x_forwarded_for;
      proxy_set_header Host $http_host;
      proxy_redirect off;
      proxy_pass http://rails_app; # 導向到 upstream rails_app
   }
}
</code></pre>

<h3>database.yml</h3>

<p><code>host name</code> 必須對應到 docker-compose 所定義的 <code>service name</code>，並且透過環境變數所設定的 user 來登入</p>

<pre><code class="ruby">default: &amp;default
  adapter: mysql2
  encoding: utf8
  pool: &lt;%= ENV.fetch("RAILS_MAX_THREADS") { 5 } %&gt;
  host: db
  port: 3306
  username: &lt;%= ENV.fetch('MYSQL_USER') { 'root' } %&gt;
  password: &lt;%= ENV.fetch('MYSQL_PASSWORD') { 'password' } %&gt;
  socket: /tmp/mysql.sock
</code></pre>

<h3>docker/db/grant_user.sql</h3>

<p>因為在 mysql 有另外建立一個 user，並且在 database.yml 也是透過這個 user 來登入，因此必須授權給此 user 權限，才能夠操作</p>

<pre><code class="ruby">GRANT ALL PRIVILEGES ON *.* TO 'user_name'@'%';
FLUSH PRIVILEGES;
</code></pre>

<h3>docker-compose.yml</h3>

<pre><code class="ruby">version: '3'
services:
  app:
    build:
      context: .
      dockerfile: ./docker/app/Dockerfile
    env_file:
      - .env
    volumes:
      - .:/usr/src/app
    depends_on:
      - db
  db:
    image: mysql:5.7.23
    command: --default-authentication-plugin=mysql_native_password
    restart: always
    env_file:
      - .env
    ports:
      - "3306:3306"
    volumes:
      - db-data:/var/lib/mysql
  web:
    build:
      context: .
      dockerfile: ./docker/web/Dockerfile
    ports:
      - 80:80
    depends_on:
      - app
volumes:
  db-data:
    external: false
</code></pre>

<h3>.env</h3>

<p>docker-compose 所需要用到的環境變數，app &amp; web 都會用到</p>

<pre><code class="ruby">MYSQL_ROOT_PASSWORD=password
MYSQL_USER=user_name
MYSQL_PASSWORD=user_password
</code></pre>

<h3>Example project</h3>

<p><a href="https://github.com/mgleon08/product_system_production">product_system_production</a></p>

<pre><code class="ruby">git clone https://github.com/mgleon08/product_system_production
# 建立 image
docker-compose build
# 啟動
docker-compose up -d
# 因為是建立新的 user 來造訪 mysql，因此必須先授權此 user 權限
p# 確認是否授權成功
docker-compose exec db mysql -u user_name -p -e"show grants;"
# 建立資料庫
docker-compose run --rm app bundle exec rails db:create
# 跑 migrate
docker-compose run --rm app bundle exec rails db:migrate
# 建立假資料
docker-compose run --rm app bundle exec rails db:seed
# 查看畫面, 記得是 http
http://localhost
</code></pre>

<h3>Production</h3>

<p>Rails5.2 之後，secret_key_base 的設定改了，在 production 上要在 config 裡面加上 master.key file，並將 local 的亂碼貼上去</p>

<ul>
<li><a href="https://mgleon08.github.io/blog/2018/07/14/rails-credentials/">Rails 5.2 Credentials</a></li>
<li><a href="https://keithpblog.org/post/encrypted-secrets/">Rails 5.2: encrypted secrets</a></li>
</ul>


<h1>最後另外附上 develop 的 docker</h1>

<pre><code class="ruby"># docker-compose
version: '3'
services:
  db:
    image: mysql:5.7.23
    command: --default-authentication-plugin=mysql_native_password
    restart: always
    environment:
      MYSQL_ROOT_PASSWORD: password
    ports:
      - "3306:3306"
    volumes:
      - ./opt/data:/var/lib/mysql
  backend:
    container_name: product_system
    build:
      context: .
      args:
        UID: ${UID:-1001}
    volumes:
      - .:/usr/src/app
    ports:
      - "3000:3000"
    depends_on:
      - db
    user: deploy
</code></pre>

<pre><code class="ruby"># Dockerfile
FROM ruby:2.5.1

RUN apt-get update -qq &amp;&amp;\
    curl -sL https://deb.nodesource.com/setup_11.x | bash - &amp;&amp;\
    apt-get install -y nodejs cmake &amp;&amp;\
    apt-get clean

ARG UID
RUN adduser deploy --uid $UID --disabled-password --gecos ""

ENV APP /usr/src/app
RUN mkdir $APP
WORKDIR $APP

COPY Gemfile* $APP/
RUN bundle install -j3 --path vendor/bundle

COPY . $APP/

CMD ["bundle", "exec", "rails", "server", "-p", "3000", "-b", "0.0.0.0"]
</code></pre>

<p>參考文件:</p>

<ul>
<li><a href="https://qiita.com/eighty8/items/0288ab9c127ddb683315#db%E6%8E%A5%E7%B6%9A%E7%94%A8%E3%81%AE%E6%83%85%E5%A0%B1%E3%83%95%E3%82%A1%E3%82%A4%E3%83%AB">Docker + Rails + Puma + Nginx + MySQL</a></li>
<li><a href="https://itnext.io/docker-rails-puma-nginx-postgres-999cd8866b18">Docker + Rails + Puma + Nginx + Postgres</a></li>
<li><a href="https://stackoverflow.com/questions/8821864/config-assets-compile-true-in-rails-production-why-not/8827757#8827757">config.assets.compile=true in Rails production, why not?</a></li>
<li><a href="http://chrisstump.online/2016/02/20/docker-existing-rails-application/">Docker for an Existing Rails Application</a></li>
<li><a href="https://stackoverflow.com/questions/5877929/what-does-upstream-mean-in-nginx">What does upstream mean in nginx?</a></li>
<li><a href="https://www.fooish.com/sql/grant-privileges.html">SQL GRANT 授與資料庫使用權限</a></li>
<li><a href="https://blog.hellojcc.tw/2015/12/07/nginx-beginner-tutorial/">nginx 基礎設定教學</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Nothing Is Something by Sandi Metz]]></title>
    <link href="http://mgleon08.github.com/blog/2018/07/26/nothing-is-something-by-sandi-metz/"/>
    <updated>2018-07-26T21:36:02+08:00</updated>
    <id>http://mgleon08.github.com/blog/2018/07/26/nothing-is-something-by-sandi-metz</id>
    <content type="html"><![CDATA[<p>這是 Sandi Metz 2015 的演講，雖然有點舊，但還是很不錯，來紀錄一下</p>

<!-- more -->


<h3>Smalltalk Infected</h3>

<p>一開始先介紹 <code>if</code> 可以改寫為自己的 method</p>

<pre><code class="ruby">true.class # TrueClass
false.class # FalseClass
</code></pre>

<pre><code class="ruby">class TrueClass
 def if_true
    yield
    self
 end

 def if_false
    self
 end
end

class FalseClass
 def if_true
    self
 end

 def if_false
    yield
    self
 end
end
</code></pre>

<pre><code class="ruby">(1 == 1).if_true{ puts "evaluated block" }
evaluated block
# =&gt; true
</code></pre>

<p>接下來改寫為 <code>Object</code> <code>FalseClass</code> <code>NilClass</code> 因為在 ruby 的世界中，除了 <code>false</code> 和 <code>nil</code> 是 &ldquo;Falsy"，其他都是 "truthy&rdquo;</p>

<pre><code class="ruby">class Object
 def if_true
    yield
    self
 end

 def if_false
    self
 end
end

class FalseClass
 def if_true
    self
 end

 def if_false
    yield
    self
 end
end

class NilClass
 def if_true
    self
 end

 def NilClass
    yield
    self
 end
end
</code></pre>

<pre><code class="ruby">(1==1).if_true{ puts 'a' }.if_false{ puts'b' }
a
# true
</code></pre>

<p>但我們並不想改寫 ruby 原本就有的 method，而是將上面的技巧應用在需要的地方</p>

<h3>Condition Averse</h3>

<p>Sometimes nil is nothing</p>

<pre><code class="ruby">ids = ['pig', '', 'sheep']
animals = ids.map {|id| Animal.find(id)}
# =&gt; [#&lt;Animal:0x007f94b290ae90 @name="pig"&gt;, nil,
     #&lt;Animal:0x007f94b290ae18 @name="sheep"&gt;]

animals.each { |animal| puts animal.name }
# =&gt; 'pig'
# NoMethodError: undefined method `name' for nil:NilClass

animals.each { |animal| puts animal.nil? ? 'no animal' : animal.name }
# =&gt; 'pig'
#    'no animal'
#    'sheep'

animals.each { |animal| puts animal &amp;&amp; animal.name }
animals.each { |animal| puts animal.try(:name) }
animals.each { |animal| puts animal.nil? ? '' : animal.name }
animals.each { |animal| puts animal == nil ? '' : animal.name }
animals.each { |animal| puts animal.is_a?(NilClass) ? '' : animal.name }
# =&gt; 'pig'
#    empty string
#    'sheep'
</code></pre>

<h3>Message Centric</h3>

<p>新增 <code>MissingAnimal</code> class</p>

<pre><code class="ruby">class Animal
  def name
    ...
  end 
end

class MissingAnimal 
  def name
    'no animal'
  end 
end

ids = ['pig', '', 'sheep']
animals = ids.map {|id| Animal.find(id) || MissingAnimal.new}
# =&gt; [#&lt;Animal: @name="pig"&gt;, #&lt;MissingAnimal:&gt;, #&lt;Animal: @name="sheep"&gt;]

animals.each { |animal| puts animal.name } 
# =&gt; 'pig'
#    'no animal'
#    'sheep'
</code></pre>

<p>但是這樣反而對 <code>MissingAnimal</code> 會有 dependency，接著在外面再包一層，將 dependency 封裝起來</p>

<pre><code class="ruby">class GuaranteedAnimal 
  def self.find(id)
    Animal.find(id) || MissingAnimal.new 
  end
end

animals = ids.map { |id|GuaranteedAnimal.find(id) }
# =&gt; [#&lt;Animal: @name="pig"&gt;, 
      #&lt;MissingAnimal:&gt;,
      #&lt;Animal: @name="sheep"&gt;]

animals.each {|animal| puts animal.name }
# =&gt; 'pig'
#    'no animal'
#    'sheep'
</code></pre>

<h3>Abstraction Seeking</h3>

<pre><code class="ruby">class House
  def recite
    (1..data.length).map { |i| line(i) }.join("\n")
  end

  def line(number)
    "This is #{phrase(number)}.\n"
  end

  def phrase(number) 
    parts(number).join(" ")
  end

  def parts(number) 
    data.last(number)
  end

  def data
    [ 'the horse and the hound and the horn that belonged to',
    # ...
    'the malt that lay in',
    'the house that Jack built']
  end
end
</code></pre>

<p>接著 Implement <code>RandomHouse</code> <code>EchoHouse</code> without &lsquo;if&rsquo; statements</p>

<p>用繼承 Inheritance?</p>

<pre><code class="ruby">class RandomHouse &lt; House 
  def data
    @data ||= super.shuffle 
  end
end

class EchoHouse &lt; House 
  def parts(number)
    super.zip(super).flatten 
  end
end
</code></pre>

<p>但這樣一個要改寫 <code>data</code> 另一個改寫 <code>parts</code>，當有新需求 <code>RandomEchoHouse</code>，那不就要這兩個 method 在寫一次，也不可能只繼承其中一個</p>

<blockquote><p>Inheritance is for specialization is not for sharing code</p></blockquote>

<p>改用組合 Composition 的方式來處理</p>

<pre><code class="ruby">class House 
  attr_reader :formatter, :data

  def initialize(orderer: DefaultOrder.new, formatter: DefaultFormatter.new) 
    @formatter = formatter
    @data = orderer.order(DATA)
  end

  def parts(number) 
    formatter.format(data.last(number))
  end
  # ...
end

class DefaultOrder 
  def order(data)
    data
  end 
end

class RandomOrder 
  def order(data)
    data.shuffle 
  end
end

class DefaultFormatter 
  def format(parts)
    parts
  end 
end

class EchoFormatter 
  def format(parts)
    parts.zip(parts).flatten 
  end
end


House.new(orderer: RandomOrder.new).line(12)
House.new(formatter: EchoFormatter.new).line(12)
</code></pre>

<p>參考文件</p>

<ul>
<li><a href="https://www.youtube.com/watch?v=OMPfEXIlTVE">[Video]RailsConf 2015 - Nothing is Something</a></li>
<li><a href="https://speakerdeck.com/skmetz/nothing-is-something-railsconf">[Silde] RailsConf 2015 - Nothing is Something</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[TaiwanUserID 台灣身分證字號驗證]]></title>
    <link href="http://mgleon08.github.com/blog/2018/07/24/taiwan-user-id/"/>
    <updated>2018-07-24T21:38:14+08:00</updated>
    <id>http://mgleon08.github.com/blog/2018/07/24/taiwan-user-id</id>
    <content type="html"><![CDATA[<p>你知道台灣身分證字號是怎麼算出來的嗎?</p>

<!-- more -->


<p>剛好公司同事有寫到，蠻有趣的來紀錄一下，要快還是要用 <code>while</code> 阿~</p>

<h1>公式</h1>

<pre><code>戶籍代表的字母數字：
Ａ台北市-10 Ｂ台中市-11 Ｃ基隆市-12 Ｄ台南市-13 Ｅ高雄市-14 Ｆ台北縣-15
Ｇ宜蘭縣-16 Ｈ桃園縣-17 Ｉ嘉義市-34 Ｊ新竹縣-18 Ｋ苗栗縣-19 Ｌ台中縣-20
Ｍ南投縣-21 Ｎ彰化縣-22 Ｏ新竹市-35 Ｐ雲林縣-23 Ｑ嘉義縣-24 Ｒ台南縣-25
Ｓ高雄縣-26 Ｔ屏東縣-27 Ｕ花蓮縣-28 Ｖ台東縣-29 Ｗ金門縣-32 Ｘ澎湖縣-30
Ｙ陽明山-31 Ｚ連江縣-33

公式
A123456789 -&gt; 10123456789

1   0   1    2    3    4    5    6    7   8   9 (拆解字母後的數字)
*   *   *    *    *    *    *    *    *   *   *
1   9   8    7    6    5    4    3    2   1   1 (固定係數)
-----------------------------------------------
1 + 0 + 8 + 14 + 18 + 20 + 20 + 18 + 14 + 8 + 9 = 130

130 % 10 == 0
</code></pre>

<h1>Code</h1>

<pre><code class="ruby">require 'benchmark'

LOCATION_CODE = {
  'A' =&gt; [1, 0], 'B' =&gt; [1, 1], 'C' =&gt; [1, 2], 'D' =&gt; [1, 3], 'E' =&gt; [1, 4], 'F' =&gt; [1, 5], 'G' =&gt; [1, 6], 'H' =&gt; [1, 7], 'I' =&gt; [3, 4],
  'J' =&gt; [1, 8], 'K' =&gt; [1, 9], 'L' =&gt; [2, 0], 'M' =&gt; [2, 1], 'N' =&gt; [2, 2], 'O' =&gt; [3, 5], 'P' =&gt; [2, 3], 'Q' =&gt; [2, 4], 'R' =&gt; [2, 5],
  'S' =&gt; [2, 6], 'T' =&gt; [2, 7], 'U' =&gt; [2, 8], 'V' =&gt; [2, 9], 'W' =&gt; [3, 2], 'X' =&gt; [3, 0], 'Y' =&gt; [3, 1], 'Z' =&gt; [3, 3]
}

MULTIPLIER = [1, 9, 8, 7, 6, 5, 4, 3, 2, 1, 1]

def id_card_validate(id)
  return false unless id =~ /\A[A-Z](1|2)\d{8}\z/
  chars = id.chars
  numbers = LOCATION_CODE[chars.shift] + chars.map(&amp;:to_i)
  sum = numbers.zip(MULTIPLIER).map{ |a, b| a * b }.reduce(:+)
  # sum, i = 0, 0
  # while i &lt;= 10
  #   sum += numbers[i] * MULTIPLIER[i]
  #   i += 1
  # end
  (sum % 10).zero?
end

n = 100000
Benchmark.bmbm do |x|
  x.report('leonji'){ n.times{ id_card_validate('A123456789') } }
end

# Rehearsal ------------------------------------------
# leonji   0.770000   0.010000   0.780000 (  0.796012)
# --------------------------------- total: 0.780000sec

#              user     system      total        real
# leonji   0.770000   0.000000   0.770000 (  0.792737)
</code></pre>

<p>參考文件</p>

<ul>
<li><a href="http://tzoyiing.pixnet.net/blog/post/29821245-%5B%E8%BD%89%E8%B2%BC%5D-%E8%BA%AB%E4%BB%BD%E8%A8%BC%E5%AD%97%E8%99%9F%E7%B7%A8%E7%A2%BC%E5%85%AC%E5%BC%8F%E8%AA%AA%E6%98%8E~%E6%95%99%E4%BD%A0%E5%A6%82%E4%BD%95%E9%A9%97">[轉貼] 身份證字號編碼公式說明~教你如何驗證</a></li>
<li><a href="https://tonytonyjan.net/2015/04/15/national-identification-card-validator-of-taiwan/">台灣身份證字號驗證器</a></li>
<li><a href="https://github.com/wayne5540/taiwanese_id_builder">taiwanese_id_builder</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Environment Banner]]></title>
    <link href="http://mgleon08.github.com/blog/2018/07/23/environment-banner/"/>
    <updated>2018-07-23T21:35:24+08:00</updated>
    <id>http://mgleon08.github.com/blog/2018/07/23/environment-banner</id>
    <content type="html"><![CDATA[<p>可以很快速的知道目前環境上的版本是什麼</p>

<!-- more -->


<p>公司因為多台機器不同環境，因此有同事做了一個 <code>Environment banner</code>，可以很方便地知道目前是哪一個 branch 哪一個 版本，這邊就來記錄一下</p>

<pre><code class="ruby"># app/helpers/environment_banner_helper.rb
module EnvironmentBannerHelper
  RELEASE_INFO_PATH = Rails.public_path.join('release_info')

  def current_branch
    if git_available?
      # 讀取當前 HEAD 所在的 branch 名稱
      `git rev-parse --abbrev-ref HEAD`.chomp
    else
      # 當在 deploy 的時候，無法用 git (除非另外裝)，因此可以先將資訊存放在某的檔案，或是環境變數
      git_info[:branch] # 檔案
      # ENV.fetch("CURRENT_BRANCH", "--branch-not-found--") # ENV
    end
  end

  def current_sha
    if git_available?
      # 讀取當前的 log 最新一行
      `git log --oneline -1`
    else
      # 當在 deploy 的時候，無法用 git (除非另外裝)，因此可以先將資訊存放在某的檔案，或是環境變數
      git_info[:sha] # 檔案
      # ENV.fetch("CURRENT_SHA", "--sha-not-found--") # ENV
    end
  end

  # 確認當前環境有沒有 git
  def git_available?
    to_dev_null = "&gt; /dev/null 2&gt;&amp;1"
    system("which git #{to_dev_null} &amp;&amp; git rev-parse --git-dir #{to_dev_null}")
  end

  # 主要是為了 capistrano 上面會有不同的 release 資料夾
  def release_number
    return unless check_release_info &amp;&amp; IO.readlines(RELEASE_INFO_PATH)[0]
    IO.readlines(RELEASE_INFO_PATH)[0].gsub(/\D/, '').prepend('#')
  end

  def git_info
    return { sha: "N/A", branch: "N/A"} unless check_release_info &amp;&amp; IO.readlines(RELEASE_INFO_PATH)[1]
    line = IO.readlines(RELEASE_INFO_PATH)[1].split(/\s+/)
    {
      sha:    line[0][0..6],
      branch: line[1].gsub(/refs\/heads\//, '')
    }
  end

  def check_release_info
    File.exist? RELEASE_INFO_PATH
  end
end
</code></pre>

<pre><code class="ruby"># app/views/layouts/application.html.erb
&lt;% unless Rails.env.production? %&gt;
  &lt;div class="environment-banner &lt;%= Rails.env %&gt;"&gt;
    &lt;%= Rails.env %&gt; | &lt;%= "#{current_branch} @ #{current_sha} #{release_number}" %&gt;
  &lt;/div&gt;
&lt;% end %&gt;
</code></pre>

<pre><code class="css">/* app/assets/stylesheets/application.scss */
.environment-banner.development {
  background: $green;
  color: $white;
}
</code></pre>

<p>capistrano deploy 時新增 <code>release_info</code> 檔案方式</p>

<pre><code class="ruby">set :repo_url, 'git@github.com:xxx/xxx.git'
ask :branch, `git rev-parse --abbrev-ref HEAD`.chomp

# 將所有 git 撞況寫到一個 file 上，再透過該 file 來顯示
# readlink 可以找到實際檔案位置，awk 分析出路徑上最後的 release 資料夾名稱
execute("echo current_release: `readlink -f #{release_path} | awk -F'/' '{print $NF}'` &gt; #{shared_path.join('public/release_info')}")
# header
execute("git ls-remote -h #{fetch(:repo_url)} #{fetch(:branch)} &gt;&gt; #{shared_path.join('public/release_info')}")
# tag
execute("git ls-remote -t #{fetch(:repo_url)} | tail -n 1 &gt;&gt; #{shared_path.join('public/release_info')}")
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Deploying Rails API + Nuxt.js + Devise-JWT API App to Production With Heroku]]></title>
    <link href="http://mgleon08.github.com/blog/2018/07/22/deploying-rails-nuxt-jwt-to-production-with-heroku/"/>
    <updated>2018-07-22T23:12:48+08:00</updated>
    <id>http://mgleon08.github.com/blog/2018/07/22/deploying-rails-nuxt-jwt-to-production-with-heroku</id>
    <content type="html"><![CDATA[<p>接著來把做好的 <code>Rails API + Nuxt.js + Devise-JWT</code> deploy 到 heroku</p>

<!-- more -->


<ul>
<li><a href="https://medium.com/@fishpercolator/deploying-your-nuxt-rails-api-app-to-production-with-heroku-54efd09eec22">Deploying your Nuxt+Rails API app to production with Heroku</a></li>
</ul>


<p>由於一開始我們希望用 docker-compose 來 build 環境，因此將前後端都 commit 在一起，但在部屬的時候希望將兩個分開，這時就可以用到 <code>git subtree</code></p>

<p><a href="https://heroku.com"><img src="https://www.herokucdn.com/deploy/button.svg" alt="Deploy" /></a></p>

<h1>Backend</h1>

<p>Rails5.2 必須先將 <code>production</code> 的 <code>config.require_master_key</code> 打開</p>

<pre><code class="ruby"># autheg-backend/config/environments/production.rb
config.require_master_key = true
</code></pre>

<p>記得要把 <code>cors.rb</code> 設定成 herokuapp 的 domain (根據前端專案的名稱)</p>

<pre><code class="ruby"># autheg-backend/config/initializers/cors.rb
origins 'localhost:3000', 'autheg-frontend-demo.herokuapp.com'
# or
origins '*'
</code></pre>

<p>安裝 <a href="https://devcenter.heroku.com/articles/heroku-cli">heroku-cli</a></p>

<pre><code class="ruby">brew install heroku/brew/heroku
</code></pre>

<p>create backend 的 heroku 專案</p>

<pre><code class="ruby"># 先到最上層的資料夾
cd autheg
# 如果看到這個 "Name is already taken"，就換一個名字即可
heroku apps:create autheg-backend-demo
</code></pre>

<p>預設 remote name 會是 heroku，因為等下要在 create frontend remote，因此先改名</p>

<pre><code class="ruby"># 更改 local 的 remote name
git remote rename heroku backend
</code></pre>

<p>將後端 autheg-backend push 上去</p>

<pre><code class="ruby"># 透過 subtree 先將後端 autheg-backend push 上去
git subtree push --prefix autheg-backend backend master
</code></pre>

<p>建立環境變數</p>

<pre><code class="ruby">heroku config:set -a autheg-backend-demo RAILS_MASTER_KEY=(local 裡面的 config.master.key)

heroku config:set -a autheg-backend-demo JWT_SECRET=$(heroku run -a autheg-backend-demo rails secret)
</code></pre>

<p>建立 table data</p>

<pre><code class="ruby">heroku run -a autheg-backend-demo rails db:schema:load
</code></pre>

<p>新增 db 資料</p>

<pre><code class="ruby">heroku run -a autheg-backend-demo rails console

# user
User.create! email: "test@example.com", password: "password"

# example
{"foo" =&gt; "green", "bar" =&gt; "red", "baz" =&gt; "purple"}.each {|n,c| Example.create!(name: n, colour: c)}
</code></pre>

<p>接下來就可以透過 <a href="http://yet-another-rest-client.com/">YARC</a> or <a href="https://www.getpostman.com/">Postman</a> 來測試有沒有成功!</p>

<pre><code class="ruby">POST https://autheg-backend-demo.herokuapp.com/api/users/sign_in

{
   "user":{
      "email":"test@example.com",
      "password":"password"
   }
}
</code></pre>

<h1>Frontend</h1>

<p><a href="https://github.com/nuxt/docs/blob/master/en/faq/heroku-deployment.md">nuxt heroku-deployment</a></p>

<p>create frontend 的 heroku 專案</p>

<pre><code class="ruby"># 先到最上層的資料夾
cd autheg
# 如果看到這個 "Name is already taken"，就換一個名字即可
heroku apps:create autheg-frontend-demo
</code></pre>

<p>rename remote name</p>

<pre><code class="ruby">git remote rename heroku frontend
</code></pre>

<p>設定環境變數，要跑在 production 模式，因此要將之前安裝在 dev 環境中的套件，安裝上去</p>

<blockquote><p>The following command tells your app to run in production mode and on all interfaces (0.0.0.0) but tells yarn/npm to run in development mode, so that all the dev packages are installed as part of the build process.</p></blockquote>

<pre><code class="ruby">heroku config:set -a autheg-frontend-demo NODE_ENV=production HOST=0.0.0.0 NPM_CONFIG_PRODUCTION=false
</code></pre>

<p>改一下 <code>package.json</code>，讓 heroku deploy 之後可以 build 檔案出來</p>

<pre><code class="ruby">"heroku-postbuild": "npm run build"
</code></pre>

<p>設定 backend 的 API 路徑</p>

<pre><code class="ruby">heroku config:set -a autheg-frontend-demo API_URL=https://autheg-backend-demo.herokuapp.com/api
</code></pre>

<p>接著就可以到首頁上去測試了</p>

<pre><code class="ruby">https://autheg-frontend-demo.herokuapp.com/
# email: test@example.com
# password: password
</code></pre>

<h1>Heroku</h1>

<p>其他 heroku 功能</p>

<pre><code class="ruby"># create new heroku project
heroku create

# push heroku
git push heroku master

# env config remove
heroku config:remove TOKEN

# log
heroku logs --tail

# scale
heroku ps:scale web=2

# ssh
heroku run -a autheg-backend bash

# run 指令
heroku run -a autheg-backend-demo rails console
</code></pre>

<h1>git subtree</h1>

<p>git subtree 本身不支援 force push，因此要透過其他方式來達成</p>

<ul>
<li><a href="https://gist.github.com/tduarte/eac064b4778711b116bb827f8c9bef7b">publish-ghpages.md</a></li>
</ul>


<pre><code class="ruby">git checkout master # you can avoid this line if you are in master...
git subtree split --prefix dist -b gh-pages # create a local gh-pages branch containing the splitted output folder
git push -f origin gh-pages:gh-pages # force the push of the gh-pages branch to the remote gh-pages branch at origin
git branch -D gh-pages # delete the local gh-pages because you will need it: ref
</code></pre>

<p>參考文件</p>

<ul>
<li><a href="https://medium.com/@fishpercolator/deploying-your-nuxt-rails-api-app-to-production-with-heroku-54efd09eec22">Deploying your Nuxt+Rails API app to production with Heroku</a></li>
<li><a href="https://hexo.crboy.net/2016/09/amazing-git-subtree/">神奇的 Git Subtree</a></li>
<li><a href="http://yutin.logdown.com/posts/188306-git-subtree-total-addendum-library">Git SubTree 共編 Library</a></li>
<li><a href="http://erning.net/blog/2012/05/09/the-twelve-factor-app/">The Twelve-Factor App</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
