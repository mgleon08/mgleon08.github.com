<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Rails | Leon's Blogging]]></title>
  <link href="http://mgleon08.github.com/blog/categories/rails/atom.xml" rel="self"/>
  <link href="http://mgleon08.github.com/"/>
  <updated>2016-06-13T23:30:06+08:00</updated>
  <id>http://mgleon08.github.com/</id>
  <author>
    <name><![CDATA[LeonJi]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Cache Etag Memcache]]></title>
    <link href="http://mgleon08.github.com/blog/2016/06/13/cache-etag-memcache/"/>
    <updated>2016-06-13T23:22:01+08:00</updated>
    <id>http://mgleon08.github.com/blog/2016/06/13/cache-etag-memcache</id>
    <content type="html"><![CDATA[<p>當有資料不常去做更動，就能夠用 cache 去讀取增加速度!</p>

<!-- more -->


<ul>
<li>cache 處太多，程式會變複雜，增加維護的難度</li>
<li>cache 會增加除錯難度，資料不再只有唯一的資料庫版本</li>
<li>cache 如果沒寫好，可能會產生資料不一致的Bug、時間顯示相關的Bug(例如顯示資料的時間雖然時間不會變，但是如果是要顯示多少小時以前，就會變動了)等等</li>
<li>cache 增加了寫程式的難度，像是Expire過期資料、資料的安全性(放在cache 層的資料也需要被保護注意安全)</li>
<li>會增加撰寫UI的難度，因為 cache 相關的程式可能會混在樣本中</li>
</ul>


<h1>Cache Store</h1>

<ul>
<li>預設的 memory_store 只適合單機開發，重啟 Rails cache 資料就不見了。</li>
<li>正式上線的網站會推薦使用 <code>Memcached</code></li>
<li>它是一套Name-Value Pair(NVP)分散式記憶體快取系統，當你有多個Rails伺服器的時候，也可以很方便的共用快取資料。</li>
</ul>


<h1>Etag</h1>

<p>ETag 是用來辨識當前的頁面是否有所改變（Rails 預設就有使用了）</p>

<p>第一次</p>

<ol>
<li>Client 發 Request</li>
<li>Rails 流程

<ul>
<li><ol>
<li>Render body</li>
</ol>
</li>
<li><ol>
<li>Create ETag</li>
</ol>
</li>
<li><ol>
<li>Body &amp; ETag included in response(<code>headers['ETag'] = Digest::MD5.hexdigest(body)</code>)</li>
</ol>
</li>
</ul>
</li>
<li>Rails 發 Response

<ul>
<li>200 Success Head 裡包含 ￼headers[&lsquo;ETag&rsquo;]</li>
</ul>
</li>
<li>Client 接收並 caches response</li>
</ol>


<p>第二次</p>

<ol>
<li>Client 發 Request 並帶著 <code>headers['If-None-Match']</code> 就是 Etag 但不知道為什麼要叫這名字</li>
<li>Rails 流程

<ul>
<li><ol>
<li>Render body</li>
</ol>
</li>
<li><ol>
<li>Create ETag</li>
</ol>
</li>
<li><ol>
<li>Compare ETag</li>
</ol>
</li>
<li><ol>
<li>If ETags match then body not included in response</li>
</ol>
</li>
</ul>
</li>
<li>Rails 發 Response

<ul>
<li>304 Not Modified</li>
</ul>
</li>
<li>Client 接收並 reads response from cache</li>
</ol>


<p>以上雖然就不需要再重新 response body，但是每次 request 都必須再把整個 body 去 generate 一次 ETag 這是相當沒有效率的事</p>

<p>所以可以透過 Customer Etag 來改善</p>

<pre><code class="ruby">class ItemsController &lt; ApplicationController
  etag {current_user.id}
    def show    @item = Item.find(params[:id])￼    fresh_when(@item)
    #headers['ETag'] = Digest::MD5.hexdigest(@item.cache_key)
    #加上面的 etag {current_user.id} 等於 fresh_when([@item, current_user.id])，可以有更多參數去判斷是否有改變  endend
</code></pre>

<p>這樣一來就只要 id 和 update_at 兩個就可以知道到底整個頁面有沒有東西變動過</p>

<h1>memcache store uses dalli</h1>

<p>Dalli is a high performance pure Ruby client for accessing memcached servers</p>

<ol>
<li>Approximately 20% faster than memcache-client.</li>
<li>Provides proper failover with recovery and adjustable timeouts.</li>
<li>Easier to integrate with monitoring tools like NewRelic RPM in order to track usage. 4. ThreadSafe.</li>
<li><p>Backwards compatible with the previous memcache-client API.</p></li>
<li><p>安裝Memcached</p></li>
</ol>


<pre><code class="ruby">brew install memcached
</code></pre>

<ul>
<li>加上memcached的函式庫</li>
</ul>


<pre><code class="ruby">gem "dalli"
</code></pre>

<p>編輯<code>config/environments/development.rb</code>和<code>production.rb</code>加上</p>

<pre><code class="ruby">config.action_controller.perform_caching = true
config.cache_store = :dalli_store
</code></pre>

<pre><code class="ruby"># 存入
Rails.cache.write('first', Post.first)
# 取出
Rails.cache.read('first')
# 删除
Rails.cache.delete('first')
# 查看
Rails.cache.exist?('first')
# fetch: 檢查 key 是否存在, 不存在, 把 block 里的结果作為 value, 并返回结果. 如果存在, 就不去執行 block 的内容
Rails.cache.fetch('last_post') { Post.last }
# =&gt; blah
# 还可以设定过期时间
Rails.cache.fetch('time', expires_in: 4.seconds) { Time.now }
</code></pre>

<h3>使用時機</h3>

<p>資料庫裡不常變動的資料，ex:所有國家</p>

<p>使用</p>

<pre><code class="ruby">def cached_skills
  Rails.cache.fetch([self.class.name, id, :skills], expires_in: 240.hours) {
    skills.to_a
  }
end
</code></pre>

<ul>
<li>[self.class.name, id, :skills]這是存儲的關鍵</li>
<li>cache 將會在240小時後過期</li>
<li>如果不轉 array (to_a)直接將 active-record 的 relations 儲存到 cache 的話，每次訪問 cache 這個 relations 還是會查詢資料庫的</li>
</ul>


<p>gem：<br/>
<a href="https://github.com/petergoldstein/dalli">dalli</a></p>

<p>官方文件：<br/>
<a href="http://guides.ruby-china.org/caching_with_rails.html">Rails 缓存简介</a><br/>
<a href="http://guides.rubyonrails.org/caching_with_rails.html">Caching with Rails: An overview</a><br/>
<a href="https://memcached.org/">memcached</a></p>

<p>參考文件：<br/>
<a href="https://ihower.tw/rails4/caching.html">快取</a><br/>
<a href="https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/http-caching">Google Developers: HTTP 快取</a><br/>
<a href="http://grantcss.com/blog/2014/12/04/introduce-dalli/">數據緩存提升性能gem - Dalli介紹</a><br/>
<a href="https://ihower.tw/blog/archives/1768">如何使用 memcached 做快取</a><br/>
<a href="https://danielzhangqinglong.github.io/2015/03/19/rails-caching/">Rails中使用memcached內存緩存技術</a><br/>
<a href="https://danielzhangqinglong.github.io/2015/04/03/intro-http-caching-with-rails/">译 ~ 介绍Rails中的条件HTTP缓存</a><br/>
<a href="https://ruby-china.org/topics/24996">Rails 3 和 Rails 4 中 ETags 工作原理</a><br/>
<a href="http://enginechang.logdown.com/posts/249025-discussion-on-memory-cache">淺談memory cache</a><br/>
<a href="https://ruby-china.org/topics/19389">总结 Web 应用中常用的各种 Cache</a><br/>
<a href="http://rails-everyday.group.iteye.com/group/wiki/1160">Rails Cache</a><br/>
<a href="https://www.nateberkopec.com/2015/07/15/the-complete-guide-to-rails-caching.html">Speed Up Your Rails App by 66% - The Complete Guide to Rails Caching</a><br/>
<a href="https://www.fastly.com/blog/accelerating-rails-part-1-built-caching">Accelerating Rails, Part 1: Built-in Caching</a><br/>
<a href="https://www.fastly.com/blog/accelerating-rails-part-2-dynamic-http-caching">Accelerating Rails, Part 2: Dynamic HTTP Caching</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Cookie & Session]]></title>
    <link href="http://mgleon08.github.com/blog/2016/06/12/cookie-and-session/"/>
    <updated>2016-06-12T20:34:20+08:00</updated>
    <id>http://mgleon08.github.com/blog/2016/06/12/cookie-and-session</id>
    <content type="html"><![CDATA[<p>用於讓 server 記住 client 的行為與資料。</p>

<!-- more -->


<h1>Cookie</h1>

<p>由於 HTTP 協定是無狀態((Stateless)的，server 端無法得知使用者在前端的操作內容，阻礙了前端與後端對話，因此 cookie 就是被設計來解決這個問題的機制。</p>

<ul>
<li>當 server 想要儲存使用者的某些狀態時，就可以發送 cookie 給 client</li>
<li>http header 裡面其中一個欄位</li>
<li>key / value 的形式儲</li>
<li>檔案大小最多 4Kb</li>
<li>以明文的方式在網際網路上傳輸及在 Client 端電腦儲存，所以不建議儲存敏感資料</li>
<li>儲存在 client 的瀏覽器</li>
<li>儲存位置

<ul>
<li>記憶體 cookie：由瀏覽器維護，當瀏覽器關閉，cookie也隨之消失，為非持久性的</li>
<li>硬碟 cookie：存在用戶端硬碟中，有一個過期時間，除非使用者手動清理cookie或是超過過期時間，否則cookie不會消失，為持久性的</li>
</ul>
</li>
</ul>


<h1>Session</h1>

<ul>
<li>儲存在 server 端</li>
<li>session 需要 cookie 的輔助才能產生運作</li>
<li>server 會傳送帶有 session id 的 cookie 給 client，當下一個 request 及cookie 再被送至 server 端時，會用 cookie 中的 session id 來辨認每個使用者所儲存的狀態與 data。</li>
<li>相對於 cookies，session 多用來儲存敏感的資料，也常常成為攻擊的目標 <a href="http://guides.rubyonrails.org/security.html#session-hijacking">Session Hijacking</a></li>
</ul>


<h1>rails 裡的 Session &amp; Cookie</h1>

<h3>session</h3>

<pre><code class="ruby">#設定
session[:current_user_id] = user.id
#移除
session[:current_user_id] = nil
session.delete(: current_user_id)
#整個 session 清掉
reset_session
</code></pre>

<h3>session store</h3>

<p><code>config/initializers/session_store.rb</code> 裡面可以設定</p>

<ul>
<li><code>:cookie_store</code>（預設）</li>
<li><code>:active_record_store</code> 使用資料庫來儲存（安全性較高）

<ul>
<li>需搭配 activerecord-session_store gem，產生sessions資料表</li>
</ul>
</li>
<li><code>:mem_cache_store</code> 使用Memcached快取系統來儲存，適合逾須兼顧效能的高流量網站</li>
</ul>


<blockquote><p>Rails預設採用 Cookies session storage 來儲存 Session 資料，它是將 Session 資料透過 config/secrets.yml 的 secret_key_base 編碼後放到瀏覽器的 Cookie 之中</p></blockquote>

<h3>cookie</h3>

<pre><code class="ruby">#設定
cookies[:commenter_name] = @comment.author
#移除
cookies.delete(:commenter_name)
#保護不能讓使用者亂改 signed
cookies.signed[:user_preference] = @current_user.preferences
#盡可能永遠留在使用者瀏覽器的資料 permanent
cookies.permanent[:remember_me] = [current_user.id, current_user.salt]
#可一起用
cookies.permanent.signed[:remember_me] = [current_user.id, current_user.salt]
</code></pre>

<pre><code class="ruby">#Rails 3 是 digitally signed cookie 可以用這方法 decode
#Rails 4 則改為 Encrypted cookies 就無法
require 'rack'cookie = "BAh7CUkiD3Nlc3Npb25faWQGOgZFRkkiJ(...)"Rack::Session::Cookie::Base64::Marshal.new.decode(cookie)
</code></pre>

<p>官方文件：<br/>
<a href="http://rails.ruby.tw/action_controller_overview.html#session">session</a><br/>
<a href="http://rails.ruby.tw/action_controller_overview.html#cookies">cookie</a><br/>
<a href="http://guides.rubyonrails.org/security.html#sessions">RailsGuide</a></p>

<p>參考文件：<br/>
<a href="http://blog.andikan.me/2012/10/03/cookie-and-session/">Cookie 和 Session 的神秘關係</a><br/>
<a href="https://ihower.tw/rails4/actioncontroller.html">Action Controller - 控制 HTTP 流程</a><br/>
<a href="http://fred-zone.blogspot.tw/2014/01/web-session.html">Web 技術中的 Session 是什麼？</a><br/>
<a href="http://railsfun.tw/t/session-cookie/380">session / cookie 解釋</a><br/>
<a href="http://lucaswu.logdown.com/posts/735841-rails-sessions-cookies-and-flash">Rails - Sessions, Cookies and Flash</a>
<a href="http://grantcss.com/blog/2015/03/23/how-rails-sessions-work/">[译] Rails Sessions 是如何工作的？</a><br/>
<a href="http://www.rails365.net/articles/cookie-yuan-li-yu-shi-xian-rails-pian">cookie原理与实现(rails篇)</a><br/>
<a href="http://www.rails365.net/articles/session-yuan-li-yu-shi-xian-rails-pian">session原理与实现(rails篇)</a><br/>
<a href="https://read01.com/NyARK.html">COOKIE與SESSION比較</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Override Default Primary Key Id]]></title>
    <link href="http://mgleon08.github.com/blog/2016/06/09/override-default-primary-key-id/"/>
    <updated>2016-06-09T22:37:33+08:00</updated>
    <id>http://mgleon08.github.com/blog/2016/06/09/override-default-primary-key-id</id>
    <content type="html"><![CDATA[<p>有時候在處理一些 table 時，會不希望 Primary Key 是一開始預設的 id 流水號</p>

<!-- more -->


<p>像是當 table 會不斷清空又重建，若是流水號，就會一直不斷的壘加上去，這時我們就會希望 table 的 Primary Key 可以自己設定</p>

<p>migration 可以很方便做到這件事，也可以改成複合健(兩個 primary key，預設是無法，可以靠 composite_primary_keys  gem 來達成)</p>

<!-- more -->


<p>先將原本 id 移除</p>

<pre><code class="ruby">def up
  remove_column :products, :id # remove existing primary key
end

def down
  add_column :products, :id, :primary_key
end
</code></pre>

<p>加上新的 primary key id</p>

<ul>
<li>ex1:</li>
</ul>


<pre><code class="ruby">create_table :products, id: false do |t|
  t.string :sku, primary: true

  t.timestamps
end
</code></pre>

<ul>
<li>ex2:</li>
</ul>


<pre><code class="ruby">create_table :products, id: false do |t|
  t.string :sku, primary_key: true

  t.timestamps
end
</code></pre>

<ul>
<li>ex3:</li>
</ul>


<pre><code class="ruby">def change
  create_table :products, id: false do |t|
    t.string :sku, null: false
    t.timestamps   
  end
  add_index :products, :sku, unique: true
  execute %Q{ ALTER TABLE "products" ADD PRIMARY KEY ("sku"); }
end
</code></pre>

<p>參考文件：<br/>
<a href="http://ruby-journal.com/how-to-override-default-primary-key-id-in-rails/">How to Override Default Primary Key Id in Rails</a><br/>
<a href="https://github.com/composite-primary-keys/composite_primary_keys">composite_primary_keys</a><br/>
<a href="http://stackoverflow.com/questions/23848388/change-primary-key-issue-rails-4-0">Change Primary Key Issue Rails 4.0</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Includes Preload Joins Eager_load References]]></title>
    <link href="http://mgleon08.github.com/blog/2016/04/21/includes-preload-joins-eager-load-references/"/>
    <updated>2016-04-21T00:41:09+08:00</updated>
    <id>http://mgleon08.github.com/blog/2016/04/21/includes-preload-joins-eager-load-references</id>
    <content type="html"><![CDATA[<p>rails 當中有很多方便可以做資料查詢的功能，可以好好研究一下。</p>

<!-- more -->


<h1>modle</h1>

<pre><code class="ruby">class Blog &lt; ActiveRecord::Base
  has_many :posts

  # t.string   "name"
  # t.string   "author"
end

class Post &lt; ActiveRecord::Base
  belongs_to :blog

  # t.string   "title"
end
</code></pre>

<h1>includes</h1>

<ul>
<li><code>includes</code> 主要用於可以直接將相關連的資料，在同一筆查詢，一起撈出來</li>
<li>two separate queries</li>
<li>跟 preload 類似，加上 <code>reference</code> 則和 <code>eager_load</code> 類似</li>
</ul>


<pre><code class="ruby">Blog.includes(:posts)
Blog Load (0.1ms)  SELECT "blogs".* FROM "blogs"
Post Load (0.2ms)  SELECT "posts".* FROM "posts" WHERE "posts"."blog_id" IN (1, 2, 3)
 =&gt; #&lt;ActiveRecord::Relation [#&lt;Blog id: 1, name: "Blog 1", author: "someone", created_at: "2016-04-20 14:26:01", updated_at: "2016-04-20 14:26:01"&gt;, #&lt;Blog id: 2, name: "Blog 2", author: "someone", created_at: "2016-04-20 14:26:01", updated_at: "2016-04-20 14:26:01"&gt;, #&lt;Blog id: 3, name: "Blog 3", author: "someone", created_at: "2016-04-20 14:26:01", updated_at: "2016-04-20 14:26:01"&gt;]&gt;

# 回傳所有 User 和 關聯的 posts
</code></pre>

<p>可以看到後面有 <code>IN (1, 2, 3)</code>，就是將上面一筆一筆查詢，變成這種方式一次撈出來。這樣在 <code>view</code> 中執行 <code>user.posts</code> 就不會再去資料庫查詢，因為已經都先撈出來了。</p>

<pre><code class="ruby">#也可以一次 includes 多個關聯

Blog.includes(posts: :profile)
Blog.includes(posts: [:foo, :bar])
#blog 關聯到 posts，posts 關聯到 foo, bar

Blog.includes(:user, comments: [:user, { replies: [:user] }])
#更複雜的關聯
</code></pre>

<h1>preload</h1>

<ul>
<li>跟 includes 類似，主要差別在於無法用 where 條件去查關聯到的 table 欄位</li>
<li>two separate queries</li>
</ul>


<pre><code class="ruby">Blog.preload(:posts)
  Blog Load (0.1ms)  SELECT "blogs".* FROM "blogs"
  Post Load (0.3ms)  SELECT "posts".* FROM "posts" WHERE "posts"."blog_id" IN (1, 2, 3)
 =&gt; #&lt;ActiveRecord::Relation [#&lt;Blog id: 1, name: "Blog 1", author: "someone", created_at: "2016-04-20 14:26:01", updated_at: "2016-04-20 14:26:01"&gt;, #&lt;Blog id: 2, name: "Blog 2", author: "someone", created_at: "2016-04-20 14:26:01", updated_at: "2016-04-20 14:26:01"&gt;, #&lt;Blog id: 3, name: "Blog 3", author: "someone", created_at: "2016-04-20 14:26:01", updated_at: "2016-04-20 14:26:01"&gt;]&gt;
</code></pre>

<pre><code class="ruby">#無法透過關聯的欄位做搜尋
Blog.preload(:posts).where(posts: { title:"Post 1-1" } )
  Blog Load (0.4ms)  SELECT "blogs".* FROM "blogs" WHERE "posts"."title" = ?  [["title", "Post 1-1"]]
=&gt;# ActiveRecord::StatementInvalid: SQLite3::SQLException: no such column: posts.title: SELECT "blogs".* FROM "blogs" WHERE "posts"."title" = ?

Blog.preload(:posts).where("posts.title = 'Post 1-1'").references(:post)
  Blog Load (0.4ms)  SELECT "blogs".* FROM "blogs" WHERE (posts.title = 'Post 1-1')
=&gt;# ActiveRecord::StatementInvalid: SQLite3::SQLException: no such column: posts.title: SELECT "blogs".* FROM "blogs" WHERE (posts.title = 'Post 1-1')

#用 includes 就沒問題，不過這就是 eager_load
Blog.includes(:posts).where(posts: { title:"Post 1-1" } )
  SQL (0.2ms)  SELECT "blogs"."id" AS t0_r0, "blogs"."name" AS t0_r1, "blogs"."author" AS t0_r2, "blogs"."created_at" AS t0_r3, "blogs"."updated_at" AS t0_r4, "posts"."id" AS t1_r0, "posts"."title" AS t1_r1, "posts"."blog_id" AS t1_r2, "posts"."user_id" AS t1_r3, "posts"."created_at" AS t1_r4, "posts"."updated_at" AS t1_r5 FROM "blogs" LEFT OUTER JOIN "posts" ON "posts"."blog_id" = "blogs"."id" WHERE "posts"."title" = ?  [["title", "Post 1-1"]]
 =&gt; #&lt;ActiveRecord::Relation [#&lt;Blog id: 1, name: "Blog 1", author: "someone", created_at: "2016-04-20 14:26:01", updated_at: "2016-04-20 14:26:01"&gt;]&gt;

#另一種寫法 
 Blog.includes(:posts).where("posts.title = 'Post 1-1'").references(:post)
  SQL (0.3ms)  SELECT "blogs"."id" AS t0_r0, "blogs"."name" AS t0_r1, "blogs"."author" AS t0_r2, "blogs"."created_at" AS t0_r3, "blogs"."updated_at" AS t0_r4, "posts"."id" AS t1_r0, "posts"."title" AS t1_r1, "posts"."blog_id" AS t1_r2, "posts"."user_id" AS t1_r3, "posts"."created_at" AS t1_r4, "posts"."updated_at" AS t1_r5 FROM "blogs" LEFT OUTER JOIN "posts" ON "posts"."blog_id" = "blogs"."id" WHERE (posts.title = 'Post 1-1')
 =&gt; #&lt;ActiveRecord::Relation [#&lt;Blog id: 1, name: "Blog 1", author: "someone", created_at: "2016-04-20 14:26:01", updated_at: "2016-04-20 14:26:01"&gt;]&gt;
</code></pre>

<h1>joins (inner join)</h1>

<p><code>joins</code> 則是關聯其他資料庫，可以進行查詢，但並不會將關聯的資料拉出來。</p>

<pre><code class="ruby">Blog.joins(:posts)
  Blog Load (0.2ms)  SELECT "blogs".* FROM "blogs" INNER JOIN "posts" ON "posts"."blog_id" = "blogs"."id"
 =&gt; #&lt;ActiveRecord::Relation [#&lt;Blog id: 1, name: "Blog 1", author: "someone", created_at: "2016-04-20 14:26:01", updated_at: "2016-04-20 14:26:01"&gt;, #&lt;Blog id: 1, name: "Blog 1", author: "someone", created_at: "2016-04-20 14:26:01", updated_at: "2016-04-20 14:26:01"&gt;, #&lt;Blog id: 1, name: "Blog 1", author: "someone", created_at: "2016-04-20 14:26:01", updated_at: "2016-04-20 14:26:01"&gt;, #&lt;Blog id: 1, name: "Blog 1", author: "someone", created_at: "2016-04-20 14:26:01", updated_at: "2016-04-20 14:26:01"&gt;, #&lt;Blog id: 1, name: "Blog 1", author: "someone", created_at: "2016-04-20 14:26:01", updated_at: "2016-04-20 14:26:01"&gt;, #&lt;Blog id: 2, name: "Blog 2", author: "someone", created_at: "2016-04-20 14:26:01", updated_at: "2016-04-20 14:26:01"&gt;, #&lt;Blog id: 2, name: "Blog 2", author: "someone", created_at: "2016-04-20 14:26:01", updated_at: "2016-04-20 14:26:01"&gt;, #&lt;Blog id: 2, name: "Blog 2", author: "someone", created_at: "2016-04-20 14:26:01", updated_at: "2016-04-20 14:26:01"&gt;, #&lt;Blog id: 2, name: "Blog 2", author: "someone", created_at: "2016-04-20 14:26:01", updated_at: "2016-04-20 14:26:01"&gt;, #&lt;Blog id: 2, name: "Blog 2", author: "someone", created_at: "2016-04-20 14:26:01", updated_at: "2016-04-20 14:26:01"&gt;, ...]&gt;

Blog.joins(:posts).count
   (0.1ms)  SELECT COUNT(*) FROM "blogs" INNER JOIN "posts" ON "posts"."blog_id" = "blogs"."id"
 =&gt; 15

#因為資料庫裡面總共有四個，但只有三個室有關聯到 posts，因此 joins 會回傳有關聯的，blog
Blog.joins(:posts).uniq.size
   (0.3ms)  SELECT DISTINCT COUNT(DISTINCT "blogs"."id") FROM "blogs" INNER JOIN "posts" ON "posts"."blog_id" = "blogs"."id"
 =&gt; 3

#回傳所有，有 post 的 blog
#因為同一個 blog 可能有多個 post ，這樣就會撈出重複的 blog 出來 ， 一個 post 一個 blog，因此可以用 .uniq 來去除重複的資料。
#如果是一對一就不會有這個問題了

#eager_load 則是透過 rails filter 後的
Blog.eager_load(:posts)
  SQL (0.3ms)  SELECT "blogs"."id" AS t0_r0, "blogs"."name" AS t0_r1, "blogs"."author" AS t0_r2, "blogs"."created_at" AS t0_r3, "blogs"."updated_at" AS t0_r4, "posts"."id" AS t1_r0, "posts"."title" AS t1_r1, "posts"."blog_id" AS t1_r2, "posts"."user_id" AS t1_r3, "posts"."created_at" AS t1_r4, "posts"."updated_at" AS t1_r5 FROM "blogs" LEFT OUTER JOIN "posts" ON "posts"."blog_id" = "blogs"."id"
 =&gt; #&lt;ActiveRecord::Relation [#&lt;Blog id: 1, name: "Blog 1", author: "someone", created_at: "2016-04-20 14:26:01", updated_at: "2016-04-20 14:26:01"&gt;, #&lt;Blog id: 2, name: "Blog 2", author: "someone", created_at: "2016-04-20 14:26:01", updated_at: "2016-04-20 14:26:01"&gt;, #&lt;Blog id: 3, name: "Blog 3", author: "someone", created_at: "2016-04-20 14:26:01", updated_at: "2016-04-20 14:26:01"&gt;, #&lt;Blog id: 4, name: "Blog 2", author: nil, created_at: "2016-04-20 16:01:54", updated_at: "2016-04-20 16:01:54"&gt;]&gt;

#因為是 LEFT OUTER JOINed 所以沒有關聯的也會抓進來
 Blog.eager_load(:posts).count
   (0.2ms)  SELECT COUNT(DISTINCT "blogs"."id") FROM "blogs" LEFT OUTER JOIN "posts" ON "posts"."blog_id" = "blogs"."id"
 =&gt; 4
</code></pre>

<p>回傳的是所有有 <code>post</code> 的 <code>blog</code>，但並不會將 <code>post</code> 資料撈出來，只是去做比對，因此再用 <code>blog.posts</code> ，一樣會去資料庫中撈出資料。</p>

<h1>joins和include的區別</h1>

<ul>
<li>include 主要是將其他關聯的 table 一起拉進來，後續查詢時，就不會再去查</li>
<li>joins 則是將兩張表合成一張（必須id有對到），再透過欄位去做塞選</li>
</ul>


<pre><code class="ruby">Blog.includes(:posts)
#回傳所有的 Blog，並將相關聯的 post 一併做查詢
#後續再去關聯的話就不會去 query

Blog.joins(:posts)
#查詢所有包含 user_id 的 posts ，並回傳該 post 所屬的 blog
#因此 has_many 若有很多 posts 屬於同一個 blog 就會回傳很多次重複的( 或是用 `distinct` User.joins(:posts).select('distinct users.*'))，可用 uniq 去掉，belong_to &amp; has_one 則不會
#後續再去關聯的話，還是會去 query
</code></pre>

<h1>eager_load</h1>

<ul>
<li>One query, LEFT OUTER JOINed in any query rather than loaded separately.</li>
<li>Works just the same as <code>includes</code> + <code>references</code></li>
<li>因此要小心，includers 後在接上 references 就會變成 eager_load</li>
</ul>


<pre><code class="ruby">Blog.eager_load(:posts)
  SQL (0.3ms)  SELECT "blogs"."id" AS t0_r0, "blogs"."name" AS t0_r1, "blogs"."author" AS t0_r2, "blogs"."created_at" AS t0_r3, "blogs"."updated_at" AS t0_r4, "posts"."id" AS t1_r0, "posts"."title" AS t1_r1, "posts"."blog_id" AS t1_r2, "posts"."user_id" AS t1_r3, "posts"."created_at" AS t1_r4, "posts"."updated_at" AS t1_r5 FROM "blogs" LEFT OUTER JOIN "posts" ON "posts"."blog_id" = "blogs"."id"
 =&gt; #&lt;ActiveRecord::Relation [#&lt;Blog id: 1, name: "Blog 1", author: "someone", created_at: "2016-04-20 14:26:01", updated_at: "2016-04-20 14:26:01"&gt;, #&lt;Blog id: 2, name: "Blog 2", author: "someone", created_at: "2016-04-20 14:26:01", updated_at: "2016-04-20 14:26:01"&gt;, #&lt;Blog id: 3, name: "Blog 3", author: "someone", created_at: "2016-04-20 14:26:01", updated_at: "2016-04-20 14:26:01"&gt;, #&lt;Blog id: 4, name: "Blog 2", author: nil, created_at: "2016-04-20 16:01:54", updated_at: "2016-04-20 16:01:54"&gt;]&gt;

Blog.eager_load(:posts).where(name: 'Blog 1')
  SQL (0.3ms)  SELECT "blogs"."id" AS t0_r0, "blogs"."name" AS t0_r1, "blogs"."author" AS t0_r2, "blogs"."created_at" AS t0_r3, "blogs"."updated_at" AS t0_r4, "posts"."id" AS t1_r0, "posts"."title" AS t1_r1, "posts"."blog_id" AS t1_r2, "posts"."user_id" AS t1_r3, "posts"."created_at" AS t1_r4, "posts"."updated_at" AS t1_r5 FROM "blogs" LEFT OUTER JOIN "posts" ON "posts"."blog_id" = "blogs"."id" WHERE "blogs"."name" = ?  [["name", "Blog 1"]]
 =&gt; #&lt;ActiveRecord::Relation [#&lt;Blog id: 1, name: "Blog 1", author: "someone", created_at: "2016-04-20 14:26:01", updated_at: "2016-04-20 14:26:01"&gt;]&gt;

Blog.eager_load(:posts).where(name: 'Blog 1').where(posts: {title: 'Post 1-1'})
  SQL (0.3ms)  SELECT "blogs"."id" AS t0_r0, "blogs"."name" AS t0_r1, "blogs"."author" AS t0_r2, "blogs"."created_at" AS t0_r3, "blogs"."updated_at" AS t0_r4, "posts"."id" AS t1_r0, "posts"."title" AS t1_r1, "posts"."blog_id" AS t1_r2, "posts"."user_id" AS t1_r3, "posts"."created_at" AS t1_r4, "posts"."updated_at" AS t1_r5 FROM "blogs" LEFT OUTER JOIN "posts" ON "posts"."blog_id" = "blogs"."id" WHERE "blogs"."name" = ? AND "posts"."title" = ?  [["name", "Blog 1"], ["title", "Post 1-1"]]
 =&gt; #&lt;ActiveRecord::Relation [#&lt;Blog id: 1, name: "Blog 1", author: "someone", created_at: "2016-04-20 14:26:01", updated_at: "2016-04-20 14:26:01"&gt;]&gt;

# includes + references 
Blog.includes(:posts).where(name: 'Blog 1').where(posts: {title: 'Post 1-1'})
  SQL (0.2ms)  SELECT "blogs"."id" AS t0_r0, "blogs"."name" AS t0_r1, "blogs"."author" AS t0_r2, "blogs"."created_at" AS t0_r3, "blogs"."updated_at" AS t0_r4, "posts"."id" AS t1_r0, "posts"."title" AS t1_r1, "posts"."blog_id" AS t1_r2, "posts"."user_id" AS t1_r3, "posts"."created_at" AS t1_r4, "posts"."updated_at" AS t1_r5 FROM "blogs" LEFT OUTER JOIN "posts" ON "posts"."blog_id" = "blogs"."id" WHERE "blogs"."name" = ? AND "posts"."title" = ?  [["name", "Blog 1"], ["title", "Post 1-1"]]
 =&gt; #&lt;ActiveRecord::Relation [#&lt;Blog id: 1, name: "Blog 1", author: "someone", created_at: "2016-04-20 14:26:01", updated_at: "2016-04-20 14:26:01"&gt;]&gt;
</code></pre>

<h1>references</h1>

<ul>
<li>只有在 includes 可以使用，主要是讓 includes 像 eager_load</li>
</ul>


<pre><code class="ruby">Blog.includes(:posts).where(name: 'Blog 1').references(:posts)
  SQL (0.2ms)  SELECT "blogs"."id" AS t0_r0, "blogs"."name" AS t0_r1, "blogs"."author" AS t0_r2, "blogs"."created_at" AS t0_r3, "blogs"."updated_at" AS t0_r4, "posts"."id" AS t1_r0, "posts"."title" AS t1_r1, "posts"."blog_id" AS t1_r2, "posts"."user_id" AS t1_r3, "posts"."created_at" AS t1_r4, "posts"."updated_at" AS t1_r5 FROM "blogs" LEFT OUTER JOIN "posts" ON "posts"."blog_id" = "blogs"."id" WHERE "blogs"."name" = ?  [["name", "Blog 1"]]
 =&gt; #&lt;ActiveRecord::Relation [#&lt;Blog id: 1, name: "Blog 1", author: "someone", created_at: "2016-04-20 14:26:01", updated_at: "2016-04-20 14:26:01"&gt;]&gt;
</code></pre>

<p><img src="http://jbcdn2.b0.upaiyun.com/2013/05/SQL-Joins.jpg" alt="" /></p>

<p>官方資料：<br/>
<a href="http://guides.rubyonrails.org/active_record_querying.html">Active Record Query Interface</a><br/>
<a href="http://rails.ruby.tw/active_record_querying.html">Active Record 查詢</a></p>

<p>參考資料：<br/>
<a href="https://ihower.tw/rails4/performance.html">網站效能</a><br/>
<a href="https://ihower.tw/rails4/activerecord-relationships.html">ActiveRecord - 資料表關聯</a><br/>
<a href="http://motion-express.com/blog/20141028-rails-include-join-avoid-n-1-query">Rails使用 include 和 join 避免 N+1 query</a><br/>
<a href="http://blog.ifyouseewendy.com/blog/2015/11/11/preload-eager_load-includes-references-joins/">preload, eager_load, includes, references, and joins in Rails</a><br/>
<a href="http://blog.bigbinary.com/2013/07/01/preload-vs-eager-load-vs-joins-vs-includes.html">Preload, Eagerload, Includes and Joins</a><br/>
<a href="http://blog.arkency.com/2013/12/rails4-preloading/">3 ways to do eager loading (preloading) in Rails 3 &amp; 4</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[HTTP HEADER]]></title>
    <link href="http://mgleon08.github.com/blog/2016/04/19/http-header/"/>
    <updated>2016-04-19T22:22:30+08:00</updated>
    <id>http://mgleon08.github.com/blog/2016/04/19/http-header</id>
    <content type="html"><![CDATA[<p>透過 HTTP HEADER 有很多資訊可以做傳遞</p>

<!-- more -->


<h1>mime_types</h1>

<p>MIME(Multipurpose Internet Mail Extensions) 格式</p>

<p>主要用在 HTTP 通訊協定中的請求標頭 Accept 和回應標頭 Content-Type 中，來說明此文件的格式。</p>

<p>Rails 會在 Controller 的 respond_to 方法中辨識並回應所請求的格式樣板，例如瀏覽器請求 application/json 就會回應 json 格式</p>

<pre><code class="ruby">Mime::SET.collect(&amp;:to_s)
=&gt; ["text/html",
 "text/plain",
 "text/javascript",
 "text/css",
 "text/calendar",
 "text/csv",
 "text/vcard",
 "image/png",
 "image/jpeg",
 "image/gif",
 "image/bmp",
 "image/tiff",
 "video/mpeg",
 "application/xml",
 "application/rss+xml",
 "application/atom+xml",
 "application/x-yaml",
 "multipart/form-data",
 "application/x-www-form-urlencoded",
 "application/json",
 "application/pdf",
 "application/zip"]
</code></pre>

<h1>Accept-Language</h1>

<p>可以根據瀏覽器的語言，來切換網站的語言</p>

<pre><code class="ruby">￼class ApplicationController &lt; ActionController::Base￼  protect_from_forgery with: :exception  before_action :set_locale￼  
  protected
  def set_locale    I18n.locale = request.headers['Accept-Language']  endend
</code></pre>

<p>搭配 <code>http_accept_language</code> gem</p>

<pre><code class="ruby">class ApplicationController &lt; ActionController::Base  protect_from_forgery with: :exception  before_action :set_locale

  ￼protected  def set_locale￼￼￼    locales = I18n.available_locales    I18n.locale = http_accept_language.compatible_language_from(locales)  end
end
</code></pre>

<h1>USING THE ACCEPT HEADER</h1>

<pre><code class="ruby">#config/routes.rb
require 'api_version'

scope defaults: { format: 'json' } do  scope module: :v1, constraints: ApiVersion.new('v1') do￼￼￼    resources :zombies  end￼￼￼￼  scope module: :v2, constraints: ApiVersion.new('v2', true) do    resources :zombies￼￼￼  end 
end
</code></pre>

<pre><code class="ruby">#lib/api_version.rb
class ApiVersion  def initialize(version, default=false)    @version, @default = version, default￼￼￼￼￼￼  end
  private  def check_headers(headers)    accept = headers['Accept']  end￼  def matches?(request)    @default || check_headers(request.headers)    accept &amp;&amp; accept.include?("application/vnd.apocalypse.#{@version}+json")  endend

application
#payload is application-specificvnd.apocalypse#media type is vendor-specific[.version]
#API version+json#response format should be JSON
</code></pre>

<h1>Token</h1>

<pre><code class="ruby">#app/models/user.rb
class User &lt; ActiveRecord::Base
  before_create :set_auth_token

  private
  ￼def set_auth_token    return if auth_token.present?    self.auth_token = generate_auth_token
  end

  def generate_auth_token
    loop do      token = SecureRandom.hex
      break token unless self.class.exists?(auth_token: token)    end
￼  end
end
</code></pre>

<pre><code class="ruby">#app/controllers/posts_controller.rb
class EpisodesController &lt; ApplicationController   before_action :authenticate

   ￼protected
   def authenticate     authenticate_token || render_unauthorized
   end

   ￼def authenticate_token     authenticate_with_http_token do |token, options|
       User.find_by(auth_token: token)     end
   end
end
</code></pre>

<p>gem：<br/>
<a href="https://github.com/iain/http_accept_language">http_accept_language</a></p>

<p>參考文件：<br/>
<a href="https://ihower.tw/rails4/environments-and-bundler.html">mime types</a><br/>
<a href="http://www.rails365.net/articles/gem-jie-shao-yuan-ma-fen-xi-http-accept-language-si">gem介紹及源碼分析之http_accept_language(四)</a></p>
]]></content>
  </entry>
  
</feed>
