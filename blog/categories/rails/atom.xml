<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Rails | Leon's Blogging]]></title>
  <link href="http://mgleon08.github.com/blog/categories/rails/atom.xml" rel="self"/>
  <link href="http://mgleon08.github.com/"/>
  <updated>2016-01-31T12:30:14+08:00</updated>
  <id>http://mgleon08.github.com/</id>
  <author>
    <name><![CDATA[LeonJi]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[自訂 Validation]]></title>
    <link href="http://mgleon08.github.com/blog/2016/01/31/custom-validation/"/>
    <updated>2016-01-31T12:29:33+08:00</updated>
    <id>http://mgleon08.github.com/blog/2016/01/31/custom-validation</id>
    <content type="html"><![CDATA[<p>當內建的驗證沒有自己的需求時，可以自訂驗證的 method 來使用。</p>

<!-- more -->


<pre><code class="ruby">class Picture &lt; ActiveRecord::Base
  belongs_to :user
  validate  :picture_size  #注意沒有加 's'

  private

  # 驗證圖片的大小
  def picture_size
    if picture.size &gt; 5.megabytes
      errors.add(:picture, "should be less than 5MB")
      #errors[:picture] &lt;&lt; "should be less than 5MB"
    end
  end
end
</code></pre>

<p>官方文件：<br/>
<a href="http://guides.rubyonrails.org/active_record_validations.html">Active Record 驗證</a><br/>
<a href="http://rails.ruby.tw/active_record_validations.html">Active Record 驗證 中文</a></p>

<p>參考文件：<br/>
<a href="https://ihower.tw/rails4/activerecord-lifecycle.html">ActiveRecord - 資料驗證及回呼</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Association Supports 方法]]></title>
    <link href="http://mgleon08.github.com/blog/2016/01/31/association-supports/"/>
    <updated>2016-01-31T11:54:15+08:00</updated>
    <id>http://mgleon08.github.com/blog/2016/01/31/association-supports</id>
    <content type="html"><![CDATA[<p>在 model 和 model 之間，經常要建立對應的關聯，rails 也提供很多 Supports 的 helper</p>

<!-- more -->


<pre><code class="ruby">class User &lt; ActiveRecord::Base
    has_many :microposts, dependent: :destroy
    has_many :active_relationships,  class_name:  "Relationship", foreign_key: "follower_id", dependent: :destroy
    has_many :passive_relationships, class_name:  "Relationship", foreign_key: "followed_id", dependent: :destroy
    has_many :following, through: :active_relationships,  source: :followed
    has_many :followers, through: :passive_relationships, source: :follower
end
</code></pre>

<ul>
<li><p><code>through</code> 透過關聯來建立另一個關聯集合，用於建立多對多的關係</p></li>
<li><p><code>class_name</code> 變更關聯的類別名稱</p></li>
</ul>


<p>可以用這個方式，自己關聯自己，像是要上面，User 可以 follower 很多個 User</p>

<blockquote><p>rails 慣例是 model 名稱，所以不用另外加 class_name</p></blockquote>

<ul>
<li><code>foreign_key</code> 可以修改外鍵名稱</li>
</ul>


<blockquote><p>rails 外鍵慣例是關聯的 Model 名稱加上 _id 後綴</p></blockquote>

<ul>
<li><code>dependent</code></li>
</ul>


<p>設定當物件刪除時，如何處理依賴它的資料</p>

<pre><code class="ruby">class Event &lt; ActiveRecord::Base
  has_many :attendees, :dependent =&gt; :destroy
end

#:destroy 把依賴的attendees也一併刪除，並且執行Attendee的destroy回呼
#:delete 把依賴的attendees也一併刪除，但不執行Attendee的destroy回呼
#:nullify 這是預設值，不會幫忙刪除attendees，但會把attendees的外部鍵event_id都設成NULL
#:restrict_with_exception 如果有任何依賴的attendees資料，則連event都不允許刪除。執行刪除時會丟出錯誤例外ActiveRecord::DeleteRestrictionError。
#:restrict_with_error 不允許刪除。執行刪除時會回傳false，在@event.errors中會留有錯誤訊息。
</code></pre>

<ul>
<li><code>source</code></li>
</ul>


<p>搭配through設定使用，當關聯的名稱不一致的時候，需要加上source指名是哪一種物件。</p>

<ul>
<li><code>counter_cache</code> 參考之前文章 <a href="http://mgleon08.github.io/blog/2015/12/20/counter-cache/">counter-cache</a></li>
</ul>


<pre><code class="ruby">class Book &lt; ActiveRecord::Base
  has_many :pages
end

class Page &lt; ActiveRecord::Base
  belongs_to :book, :counter_cache =&gt; true
end

#設定成 ture，就會自動去找 pages_count 欄位，若要指定欄位則是 counter_cache: :count_of_pages
</code></pre>

<ul>
<li><code>inverse_of</code></li>
</ul>


<p>關聯另一端的關聯名稱。</p>

<blockquote><p>belongs_to 無法與 :polymorphic 同時使用。<br/>
has_one 無法與 :through 或 :as 同時使用。</p></blockquote>

<ul>
<li><code>polymorphic</code> &amp; <code>as</code> 參考之前文章 <a href="http://mgleon08.github.io/blog/2015/12/20/ruby-on-rails-polymorphic-associations-and-sti/">polymorphic</a></li>
</ul>


<pre><code class="ruby">class Comment &lt; ActiveRecord::Base
  belongs_to :commentable, :polymorphic =&gt; true
end

class Article &lt; ActiveRecord::Base
  has_many :comments, :as =&gt; :commentable
end

class Photo &lt; ActiveRecord::Base
  has_many :comments, :as =&gt; :commentable
end
</code></pre>

<ul>
<li><code>touch</code><br/>
touch 為 true 時，儲存或刪除關聯物件時，關聯物件的 updated_at 或 updated_on 的時間戳會自動設成當前時間</li>
</ul>


<pre><code class="ruby">class Order &lt; ActiveRecord::Base
  belongs_to :customer, touch: true 
  #更改欄位 touch: :orders_updated_at
end
</code></pre>

<ul>
<li><p><code>validate</code> 預設為 false，儲存物件時不會驗證關聯物件</p></li>
<li><p><code>primary_key</code> 可以修改主鍵名稱</p></li>
</ul>


<h1>Scope</h1>

<ul>
<li><code>where</code></li>
</ul>


<pre><code class="ruby">class Order &lt; ActiveRecord::Base
  belongs_to :customer, -&gt; { where active: true }
end
</code></pre>

<ul>
<li><code>includes</code></li>
</ul>


<p>經常性使用 <code>@line_item.order.customer</code> 就可以加上</p>

<pre><code class="ruby">class LineItem &lt; ActiveRecord::Base
  belongs_to :order, -&gt; { includes :customer }
end

class Order &lt; ActiveRecord::Base
  belongs_to :customer
  has_many :line_items
end

class Customer &lt; ActiveRecord::Base
  has_many :orders
end
</code></pre>

<ul>
<li><code>readonly</code></li>
</ul>


<p>如果設定了 readonly 選項，則關聯物件取出時為唯讀。</p>

<ul>
<li><code>select</code></li>
</ul>


<p>select 方法可以覆寫用來取出關聯的 SELECT 子句。預設會取出所有欄位</p>

<h3>has_many 額外方式</h3>

<p>條件也可透過 Hash 指定</p>

<pre><code class="ruby">class Customer &lt; ActiveRecord::Base
  has_many :confirmed_orders, -&gt; { where confirmed: true },
                              class_name: "Order"
end
</code></pre>

<p>用 Hash 的 where，產生出來的記錄會自動使用 Hash 的作用域。</p>

<p>上例中，使用 <code>@customer.confirmed_orders.create</code> 或 <code>@customer.confirmed_orders.build</code> 會建立出 confirmed 欄位為 true 的訂單</p>

<ul>
<li><code>group</code> 對結果做分組</li>
</ul>


<pre><code class="ruby">has_many :line_items, -&gt; { group 'orders.id' }
</code></pre>

<ul>
<li><code>limit</code> 限制透過關聯取出物件的數量</li>
</ul>


<pre><code class="ruby"> has_many :recent_orders, -&gt; { order('order_date desc').limit(100) }
</code></pre>

<ul>
<li><code>offset</code> 指定開始從關聯取出物件的偏移量</li>
</ul>


<pre><code class="ruby">has_many :orders, -&gt; { offset(11) }
</code></pre>

<ul>
<li><code>order</code> 指定關聯物件取出後的排序方式</li>
</ul>


<pre><code class="ruby">has_many :orders, -&gt; { order "date_confirmed DESC" }
</code></pre>

<ul>
<li><code>distinct</code> 確保集合中沒有重複的物件</li>
</ul>


<pre><code class="ruby">has_many :articles, -&gt; { distinct }, through: :readings
</code></pre>

<p>若想確保不插入重複的資料到資料庫（這樣取出來就確定是不重複的記錄了），應該要在資料表上新增一個唯一性的索引。</p>

<p>舉例來說，如果有 person_articles 資料表，想確保所有文章不重複，可加入下面這個遷移</p>

<pre><code class="ruby">add_index :person_articles, :article, unique: true
</code></pre>

<p>不要使用 include? 來確保唯一性，因為多個使用者可能同時加入文章，可能會導致競態條件（Race Condition）</p>

<pre><code class="ruby">person.articles &lt;&lt; article unless person.articles.include?(article)
</code></pre>

<ul>
<li><code>extending</code> 指定一個模組名稱，用來擴充關聯代理（association proxy）</li>
</ul>


<pre><code class="ruby">module FindRecentExtension
  def find_recent
    where("created_at &gt; ?", 5.days.ago)
  end
end

class Customer &lt; ActiveRecord::Base
  has_many :orders, -&gt; { extending FindRecentExtension }
end

class Supplier &lt; ActiveRecord::Base
  has_many :deliveries, -&gt; { extending FindRecentExtension }
end
</code></pre>

<p>官方文件：<br/>
<a href="http://guides.rubyonrails.org/association_basics.html#has-many-association-reference">has_many Association Reference</a><br/>
<a href="http://rails.ruby.tw/association_basics.html#has-many-%E9%97%9C%E8%81%AF%E5%8F%83%E8%80%83%E6%89%8B%E5%86%8A">has_many Association Reference 中文</a><br/>
<a href="http://rails.ruby.tw/association_basics.html#belongs-to-%E9%97%9C%E8%81%AF%E5%8F%83%E8%80%83%E6%89%8B%E5%86%8A">belongs_to 關聯手冊</a><br/>
<a href="http://rails.ruby.tw/association_basics.html#has-one-%E9%97%9C%E8%81%AF%E5%8F%83%E8%80%83%E6%89%8B%E5%86%8A">has_one 關聯手冊</a><br/>
<a href="http://rails.ruby.tw/association_basics.html#has-many-%E9%97%9C%E8%81%AF%E5%8F%83%E8%80%83%E6%89%8B%E5%86%8A">has_many 關聯</a></p>

<p>參考文件：<br/>
<a href="https://ihower.tw/rails4/activerecord-relationships.html">ActiveRecord - 資料表關聯</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Transactions 交易]]></title>
    <link href="http://mgleon08.github.com/blog/2016/01/31/transactions/"/>
    <updated>2016-01-31T10:58:13+08:00</updated>
    <id>http://mgleon08.github.com/blog/2016/01/31/transactions</id>
    <content type="html"><![CDATA[<p>當兩件事情必須確實執行完畢，才存取到資料庫！</p>

<!-- more -->


<h1>Transactions交易</h1>

<p>像是銀行匯款，必須一方確實扣款，另一方確實有新增款項，這筆交易在算成功!</p>

<pre><code class="ruby">ActiveRecord::Base.transaction do
  User.create!(:name =&gt; 'hello')
  Feed.create!
end
</code></pre>

<p>在 transaction 裡面必須使用加上 <code>!</code> 才會丟例外，讓交易失敗。</p>

<p>另外，資料要在 transaction 完成後，才會存取到資料庫，因此有用 <code>after_save</code> 回呼，可能就會失敗。</p>

<p>因此必須改用 <code>after_commit</code>這個回呼，才能確保讀取到交易完成後的資料。</p>

<p><a href="https://ihower.tw/rails4/activerecord-others.html">ActiveRecord - 進階功能</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[用 Try 來防止 Nil]]></title>
    <link href="http://mgleon08.github.com/blog/2016/01/29/try/"/>
    <updated>2016-01-29T21:35:23+08:00</updated>
    <id>http://mgleon08.github.com/blog/2016/01/29/try</id>
    <content type="html"><![CDATA[<p>在 rails 當中，經常會出現 nil 值，而爆錯，所以經常要去判斷<br/>
這個 try 就是簡化這個判斷產生的，懂得使用的話會非常好用。</p>

<!-- more -->


<p>但缺點就是每個地方都要去設定，即使是同一個值<br/>
因此另外一個解決方式就是用之前介紹的 <a href="http://mgleon08.github.io/blog/2015/12/13/ruby-on-rails-delegate/">delegate</a> 也可以達到同樣的效果。</p>

<h1>try</h1>

<pre><code class="ruby"># without try
unless @number.nil?
  @number.next
end

# with try
@number.try(:next)
</code></pre>

<p>將原本要寫三行簡短成一行。</p>

<pre><code class="ruby">@user = User.create(name: "hello")
@user.try(:name=, "haha")
#@user.name = "haha" unless @user.nil?

@user.name 
#=&gt; "haha"

#若改成@user.try(:name&lt;&lt;, "haha")
#則會變成Operation 的 &lt;&lt; 而爆錯
#@user.name &lt;&lt; "haha" unless @user.nil?
</code></pre>

<p>也可以放入 block</p>

<pre><code class="ruby">#@user.try { |u| "#{u.first_name} #{u.last_name}" }
</code></pre>

<h3>用try 防止例外出現</h3>

<pre><code class="ruby">#假設 @user = nil

@user.age
#=&gt; NoMethodError: undefined method `age' for #&lt;User:0x007f80b74c70e0&gt;
#因為 nil.age

@user.try(:age)
#=&gt; nil
#因為 nil.age unless nil
</code></pre>

<p>參考文件：<br/>
<a href="https://github.com/rails/rails/blob/master/activesupport/lib/active_support/core_ext/object/try.rb">try - rails_github</a><br/>
<a href="http://guides.rubyonrails.org/active_support_core_extensions.html#try">try</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[用 Rspec + Factory Girl 寫測試]]></title>
    <link href="http://mgleon08.github.com/blog/2016/01/29/rspec-plus-factory-girl/"/>
    <updated>2016-01-29T20:36:46+08:00</updated>
    <id>http://mgleon08.github.com/blog/2016/01/29/rspec-plus-factory-girl</id>
    <content type="html"><![CDATA[<p>程式寫久之後，就會發現測試的重要性!<br/>
因此來介紹 rails 中，比內建測試還好用的 rspec 搭配 factory_girl</p>

<!-- more -->


<h1>測試種類</h1>

<ul>
<li><p>單元測試(Unit test)<br/>
針對每個程式各個最小單位進行測試，像是在 controller 就單單只測試 controller 裡面的 action，而裡面產生的 model,method，都用假的方式來取代，已確保有錯誤時，可以很快知道是哪邊有問題 。</p></li>
<li><p>整合測試(Integration test)<br/>
主要是用來測試，每個 class 的互動，像是 controller 裡面會 call 到 model ，也會 call 到 view ，並測試回傳的值是否正確。</p></li>
</ul>


<h1>寫測試的好處</h1>

<ul>
<li>Instant Feedback 即時反饋（寫測試的時間 &lt; debug的時間）</li>
<li>回歸測試及重構 （重構時就不需要再重複的測試）</li>
<li>幫助設計API（TDD = 先測試，在實作）</li>
<li>一種程式文件（可以讓很快就知道之前api怎麼寫的）</li>
</ul>


<h1>慣例</h1>

<ul>
<li>⼀個 rb 檔案配⼀個同名的 _spec.rb 檔案</li>
<li>guard 等⼯具容易設定<br/>
<a href="https://github.com/guard/guard-rspec">guard-rspec</a> 程式⼀修改完存檔，⾃動跑對應的測試（bundle後，輸入 guard init repec 初始化，打guard（bundle exec guard 真正執行））</li>
<li>editor 有⽀援快速鍵</li>
<li>describe “#name” 是 instance method</li>
<li>describe “.name” 是 class method</li>
<li>測試spec盡量比較簡單清楚，可以不用DRY，實作才會要DRY</li>
</ul>


<h1>輸出格式</h1>

<ul>
<li>rspec filename.rb 預設不產⽣⽂件</li>
<li>rspec filename.rb -fd 輸出 specdoc ⽂件</li>
<li>rspec filename.rb -fh 輸出 html ⽂件</li>
</ul>


<h1>安裝</h1>

<pre><code class="ruby">group :development, :test do
  gem 'rspec-rails'
  gem 'factory_girl_rails'
end
</code></pre>

<h1>設定</h1>

<h3>顏色描述</h3>

<pre><code class="ruby">#vi .rspec檔案輸入
--color #顯示顏色
--format #documentation顯示描述
</code></pre>

<h3>將不需要的檔案關閉</h3>

<p>generate 新的 controller 或是 model 時，rails 就會很聰明的順便新增 sepc 檔案，但有時候我們會希望用到的時候再去建立即可，所以需要關閉就輸入以下指令。</p>

<p><code>/config/application.rb</code></p>

<pre><code class="ruby">config.generators do |g|
  g.view_specs false
  g.helper_specs false
  g.request_specs false
  g.controller_specs false
  g.routing_specs false
end
</code></pre>

<h1>Rspec</h1>

<h3>model</h3>

<pre><code class="ruby">require 'rails_helper' #必須載入才能使用裡面的方法

RSpec.describe Post, type: :model do #RSpec 可省略
    it "is accessible" do
        post = Post.create!
        expect(post).to eq(Post.last)
    end

    it "has title and content columns" do
        columns = Post.column_names
        expect(columns).to include("id")
    end
end
</code></pre>

<ul>
<li><code>describe</code>, <code>context</code> 描述要測試的是什麼，可以用nested</li>
<li><code>it</code>, <code>specify</code>, <code>example</code> 就是⼀⼩段測試</li>
<li><code>expect(…).to</code> 或 <code>expect(…).to_not</code> 定義期望</li>
<li><code>eq</code> 預期的是否和自己設定的相等</li>
<li><code>include</code> 預期的是否有包括自己設定的值</li>
<li><code>describe</code> 和 <code>it</code> 前面加上 x 代表 pending，執行 rspec 就會先跳拓</li>
<li><a href="https://www.relishapp.com/rspec/rspec-expectations/v/3-4/docs/built-in-matchers/change-matcher">其他方法</a></li>
</ul>


<h3>Routing spec syntax</h3>

<pre><code class="ruby">expect(:get =&gt; "/events").to route_to("events#index")
expect(:get =&gt; "/widgets/1/edit").not_to be_routable

expect(:get =&gt; "/posts/1").to route_to(
      :controller =&gt; "posts",
      :action =&gt; "show",
      :id =&gt; "1"
      )
</code></pre>

<h3>Controller spec syntax</h3>

<pre><code class="ruby">expect(response).to render_template(:new)
expect(response).to redirect_to(events_url)
expect(response).to have_http_status(200)
expect(assigns(:event)).to be_a_new(Event)
</code></pre>

<h3>View spec syntax</h3>

<pre><code class="ruby">render
expect(rendered).to include("Title")
expect(response).to render_template(partial: "_form")
</code></pre>

<h3>Helper spec syntax</h3>

<pre><code class="ruby">expect(helper.your_method).to eq("")
</code></pre>

<h3>request</h3>

<pre><code class="ruby">RSpec.describe "Users", :type =&gt; :request do
  before do
    @user = User.create(name: "hello")
  end

  it "GET /users" do
    get "/users"
    expect(response).to have_http_status(200)
    expect(response).to render_template(:index)
    expect(response.body).to include("hello")
  end

  it "GET /user/:id" do
    get "/user", id: @user.id
    expect(response).to have_http_status(200)
    expect(response).to render_template(:index)
    expect(response.body).to include("hello")
  end
</code></pre>

<p>request 通常直接從網址進行 Get 或 Post ，接著判斷傳回來的值是否正確。</p>

<pre><code class="ruby">before do  
    @user = User.new(name: "hello")
end

before(:all) do
    @user = User.new(name: "hello")
end

#也有 after(:each)，afte(:all)
</code></pre>

<ul>
<li>before(:each) 每段it之前執行</li>
<li>before(:all) 整段describe前只執行一次</li>
<li>after(:each) 每段it之後執行</li>
<li>after(:all) 整段describe後只執行一次</li>
<li>(:each) 可以不用加，預設為(:each)</li>
</ul>


<pre><code class="ruby">let(:user){User.new(:name =&gt; "hello")}
</code></pre>

<ul>
<li>相較於 before(:each) 可增加執⾏速度</li>
<li>有使⽤到才會運算(lazy)，並且在同⼀個 example 測試中多次呼叫會 Memoized 快取起來。</li>
<li>let! 則是⾮ lazy 版本</li>
</ul>


<h1>Stub</h1>

<pre><code class="ruby">allow_any_instance_of(User).to receive(:follow).and_return(false)
</code></pre>

<p>用stub 假造 method，讓它忽略這個 method，或是指定回傳東西，可以避免在測試時，測試不必要的東西。</p>

<h1>factory_girl</h1>

<p>到 <code>spec/rails_helper.rb</code> 設定</p>

<pre><code class="ruby">RSpec.configure do |config|
  config.include FactoryGirl::Syntax::Methods
end
</code></pre>

<p>在 <code>spec</code> 底下新增 <code>factories</code> 資料夾，接著在裡面新增相對應的物件名稱，像是 <code>user.rb</code></p>

<p><code>spec/factories/user.rb</code></p>

<pre><code class="ruby">FactoryGirl.define do
  factory :user, class: User" do
    name "video1"
    age  18

    trait :child do
      age 6
      #after(:create) {|user| user.add_role(:admin) } 
      #after(:build)  {|user| user.add_role(:admin) } 
      #也可以設定 create 之後的設定
    end
  end
end
</code></pre>

<p>這樣在 spec 裡面就可以直接建立假資料</p>

<pre><code class="ruby">before do  
    @user  = FactoryGirl.create(:user) #FactoryGirl 可省略
    @child = create(:user, :child) #就只替換掉 age
end
</code></pre>

<h3>為什麼要假物件?</h3>

<ul>
<li>無法控制回傳值的外部系統 (例如第三⽅ web service)</li>
<li>建構正確的回傳值很⿇煩 (例如得準備很多假資料)</li>
<li>可能很慢，拖慢測試速度 (例如耗時的運算)</li>
<li>有難以預測的回傳值 (例如亂數⽅法)</li>
<li>還沒開始實作 (特別是採⽤ TDD 流程)</li>
</ul>


<h1>Capybara</h1>

<p>RSpec除了可以拿來寫單元程式，我們也可以把測試的層級拉高做整合性測試，以Web應用程式來說，就是去自動化瀏覽器的操作，實際去向網站伺服器請求，然後驗證出來的HTML是正確的輸出。</p>

<p><a href="https://github.com/jnicklas/capybara">capybara</a>就是一套可以搭配的工具，用來模擬瀏覽器行為</p>

<h1>CI server</h1>

<p>CI(Continuous Integration)
伺服器的用處是每次有人Commit就會自動執行編譯及測試(Ruby不用編譯，所以主要的用處是跑測試)，並回報結果，如果有人送交的程式搞砸了回歸測試，馬上就有回饋可以知道。</p>

<p><a href="https://circleci.com">circleci.com</a></p>

<p>建立 <code>circle.yml</code></p>

<pre><code class="ruby">machine:
  timezone:
    Asia/Taipei
  ruby:
    version: 2.1.2
dependencies:
  pre:
    - rvm use 2.1.2
    - gem install bundler
    - gem install rubocop
  post:
    - gem update rake
database:
  override:
    - cp config/database.yml.example config/database.yml
    - rake db:create db:migrate --trace
test:
  override:
    - bundle exec rspec --color
</code></pre>

<p>建立 <code>config/database.yml.example</code></p>

<pre><code class="ruby">default: &amp;default
  adapter: mysql2
  encoding: utf8
  host: localhost
  username:
  password:

test:
  &lt;&lt;: *default
  database: test_db

development:
  &lt;&lt;: *default
  database: development_db

production:
  &lt;&lt;: *default
  database: production_db
</code></pre>

<p>接著到 <a href="https://circleci.com">circleci.com</a> 和 github 帳號做連結。<br/>
接著將要跑的 project 加進去，之後只要 push 到 github 就會自動跑了！</p>

<h1>大師引言</h1>

<pre><code>大部份都是寫model的測試
controller偶爾會寫

其他的因為後面有驗收測試也會測試到，所以不浪費時間去寫測試
驗收測試多半是測試子路徑，不會測到所有的條件，所以個別的小項測試，就直接在model寫就好了

工程是寫到request就很棒了
feature 比較像是QA在寫的
</code></pre>

<p>官方文件：<br/>
<a href="http://betterspecs.org/">Better Specs</a><br/>
<a href="https://www.relishapp.com/">Relish</a></p>

<p>Gem：<br/>
<a href="https://github.com/rspec/rspec-rails">rspec-rails</a><br/>
<a href="https://github.com/thoughtbot/factory_girl_rails">factory_girl_rails</a>  <br/>
<a href="https://github.com/guard/guard-rspec">guard-rspec</a><br/>
<a href="https://github.com/jnicklas/capybara">capybara</a></p>

<p>參考文件：<br/>
<a href="https://ihower.tw/rails4/testing.html">自動化測試</a><br/>
<a href="http://motion-express.com/trainings/rspec-rails-1">RSpec-Rails (基礎篇)</a><br/>
<a href="http://motion-express.com/blog/20150320-custom-helpers-in-rspec">RSpec-Rails當中自訂methods及helpers</a><br/>
<a href="http://motion-express.com/blog/20150327-rspec-rails-testing-module">RSpec-Rails 針對module進行unit test</a><br/>
<a href="http://www.slideshare.net/ihower/rspec-7394497">RSpec 讓你愛上寫測試</a><br/>
<a href="https://blog.alphacamp.co/2015/03/02/tdd-kata/">程式設計師升級必練內功：TDD Kata</a><br/>
<a href="https://codility.com/programmers/lessons/">codility 練習</a><br/>
<a href="http://www.sportcalculators.com/bowling-score-calculator">保齡球練習</a></p>
]]></content>
  </entry>
  
</feed>
