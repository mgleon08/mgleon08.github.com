<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Rails | Leon's Blogging]]></title>
  <link href="http://mgleon08.github.com/blog/categories/rails/atom.xml" rel="self"/>
  <link href="http://mgleon08.github.com/"/>
  <updated>2016-01-29T21:40:07+08:00</updated>
  <id>http://mgleon08.github.com/</id>
  <author>
    <name><![CDATA[LeonJi]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[用 Try 來防止 Nil]]></title>
    <link href="http://mgleon08.github.com/blog/2016/01/29/try/"/>
    <updated>2016-01-29T21:35:23+08:00</updated>
    <id>http://mgleon08.github.com/blog/2016/01/29/try</id>
    <content type="html"><![CDATA[<p>在 rails 當中，經常會出現 nil 值，而爆錯，所以經常要去判斷<br/>
這個 try 就是簡化這個判斷產生的，懂得使用的話會非常好用。</p>

<!-- more -->


<p>但缺點就是每個地方都要去設定，即使是同一個值<br/>
因此另外一個解決方式就是用之前介紹的 <a href="http://mgleon08.github.io/blog/2015/12/13/ruby-on-rails-delegate/">delegate</a> 也可以達到同樣的效果。</p>

<h1>try</h1>

<pre><code class="ruby"># without try
unless @number.nil?
  @number.next
end

# with try
@number.try(:next)
</code></pre>

<p>將原本要寫三行簡短成一行。</p>

<pre><code class="ruby">@user = User.create(name: "hello")
@user.try(:name=, "haha")
#@user.name = "haha" unless @user.nil?

@user.name 
#=&gt; "haha"

#若改成@user.try(:name&lt;&lt;, "haha")
#則會變成Operation 的 &lt;&lt; 而爆錯
#@user.name &lt;&lt; "haha" unless @user.nil?
</code></pre>

<p>也可以放入 block</p>

<pre><code class="ruby">#@user.try { |u| "#{u.first_name} #{u.last_name}" }
</code></pre>

<h3>用try 防止例外出現</h3>

<pre><code class="ruby">#假設 @user = nil

@user.age
#=&gt; NoMethodError: undefined method `age' for #&lt;User:0x007f80b74c70e0&gt;
#因為 nil.age

@user.try(:age)
#=&gt; nil
#因為 nil.age unless nil
</code></pre>

<p>參考文件：<br/>
<a href="https://github.com/rails/rails/blob/master/activesupport/lib/active_support/core_ext/object/try.rb">try - rails_github</a><br/>
<a href="http://guides.rubyonrails.org/active_support_core_extensions.html#try">try</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Association Reference 建立關聯]]></title>
    <link href="http://mgleon08.github.com/blog/2016/01/29/association-reference/"/>
    <updated>2016-01-29T21:33:02+08:00</updated>
    <id>http://mgleon08.github.com/blog/2016/01/29/association-reference</id>
    <content type="html"><![CDATA[<p>在 model 和 model 之間，經常要建立對應的關聯，而 rails 又有相當多的關聯方式，還有 method</p>

<!-- more -->


<h1>has_many 建立關聯</h1>

<p><code>User</code> has_many <code>Post</code><br/>
可以用下面方法，將兩個 model 關聯起來。</p>

<pre><code class="ruby">class User &lt; ActiveRecord::Base
  has_many :posts
end
</code></pre>

<pre><code class="ruby">@user.posts 
#回傳所有關聯物件的陣列，沒有則回傳空陣列

@user.posts &lt;&lt; Post.find(1) 
#透過將外鍵設為加入物件的主鍵

@user.posts.delete(object, ...) 
#透過將外鍵設為 NULL，從關聯集合中移除一個或多個物件，會回呼 dependent 設定

@user.posts.destroy(object, ...) 
#呼叫 destroy 來移除物件，不管 dependent 設定

@user.posts = (objects) 
#根據提供的物件來決定要刪除還是新增

@user.post_ids 
#回傳所有關聯的 id 陣列

@user.post_ids=([1,2,3])
#更改集合擁有物件的 ID，根據所提供的主鍵值來決定要刪除還是新增

@user.posts.clear
#移除集合中的所有物件。若有設定 dependent: :destroy 選項，則會 destory 關聯物件；若設定的是 dependent: :delete_all 選項，則會直接從資料庫刪除關聯物件；其他情況會將外鍵設為 NULL

@user.posts.empty?
#在集合沒有任何關聯物件時回傳 true

@user.posts.size
#回傳集合中物件的數量

@user.posts.find(...)
#在集合中查詢物件。語法和選項與 ActiveRecord::Base.find 相同

@user.posts.where(...)

@open_orders = @customer.orders.where(open: true) # No query yet
@open_order = @open_orders.first # Now the database will be queried
#根據提供的條件來查找物件，預設是惰性載入，僅在需要用到物件才會去資料庫做查詢。

@user.posts.exists?(...)
#依提供的條件檢查物件存在集合裡。語法和選項與 ActiveRecord::Base.exists? 相同

@user.posts.build(attributes = {}, ...)
#回傳一個或多個新關聯物件。這些物件由傳入的屬性來初始化，同時會自動設定外鍵。但關聯物件仍未儲存至資料庫

@user.posts.create(attributes = {})
#回傳關聯類型的新物件。 這個物件透過傳入的屬性來初始化，同時會自動設定外鍵。一旦通過所有 Model 的驗證規則時，便把此關聯物件存入資料庫

@user.posts.create!(attributes = {})
#驗證失敗時會拋出 ActiveRecord::RecordInvalid 異常
</code></pre>

<p>官方文件：<br/>
<a href="http://guides.rubyonrails.org/association_basics.html#has-many-association-reference">has_many Association Reference</a><br/>
<a href="http://rails.ruby.tw/association_basics.html#has-many-%E9%97%9C%E8%81%AF%E5%8F%83%E8%80%83%E6%89%8B%E5%86%8A">has_many Association Reference 中文</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[用 Rspec + Factory Girl 寫測試]]></title>
    <link href="http://mgleon08.github.com/blog/2016/01/29/rspec-plus-factory-girl/"/>
    <updated>2016-01-29T20:36:46+08:00</updated>
    <id>http://mgleon08.github.com/blog/2016/01/29/rspec-plus-factory-girl</id>
    <content type="html"><![CDATA[<p>程式寫久之後，就會發現測試的重要性!<br/>
因此來介紹 rails 中，比內建測試還好用的 rspec 搭配 factory_girl</p>

<!-- more -->


<h1>測試種類</h1>

<ul>
<li><p>單元測試(Unit test)<br/>
針對每個程式各個最小單位進行測試，像是在 controller 就單單只測試 controller 裡面的 action，而裡面產生的 model,method，都用假的方式來取代，已確保有錯誤時，可以很快知道是哪邊有問題 。</p></li>
<li><p>整合測試(Integration test)<br/>
主要是用來測試，每個 class 的互動，像是 controller 裡面會 call 到 model ，也會 call 到 view ，並測試回傳的值是否正確。</p></li>
</ul>


<h1>寫測試的好處</h1>

<ul>
<li>Instant Feedback 即時反饋（寫測試的時間 &lt; debug的時間）</li>
<li>回歸測試及重構 （重構時就不需要再重複的測試）</li>
<li>幫助設計API（TDD = 先測試，在實作）</li>
<li>一種程式文件（可以讓很快就知道之前api怎麼寫的）</li>
</ul>


<h1>慣例</h1>

<ul>
<li>⼀個 rb 檔案配⼀個同名的 _spec.rb 檔案</li>
<li>guard 等⼯具容易設定<br/>
<a href="https://github.com/guard/guard-rspec">guard-rspec</a> 程式⼀修改完存檔，⾃動跑對應的測試（bundle後，輸入 guard init repec 初始化，打guard（bundle exec guard 真正執行））</li>
<li>editor 有⽀援快速鍵</li>
<li>describe “#name” 是 instance method</li>
<li>describe “.name” 是 class method</li>
<li>測試spec盡量比較簡單清楚，可以不用DRY，實作才會要DRY</li>
</ul>


<h1>輸出格式</h1>

<ul>
<li>rspec filename.rb 預設不產⽣⽂件</li>
<li>rspec filename.rb -fd 輸出 specdoc ⽂件</li>
<li>rspec filename.rb -fh 輸出 html ⽂件</li>
</ul>


<h1>安裝</h1>

<pre><code class="ruby">group :development, :test do
  gem 'rspec-rails'
  gem 'factory_girl_rails'
end
</code></pre>

<h1>設定</h1>

<h3>顏色描述</h3>

<pre><code class="ruby">#vi .rspec檔案輸入
--color #顯示顏色
--format #documentation顯示描述
</code></pre>

<h3>將不需要的檔案關閉</h3>

<p>generate 新的 controller 或是 model 時，rails 就會很聰明的順便新增 sepc 檔案，但有時候我們會希望用到的時候再去建立即可，所以需要關閉就輸入以下指令。</p>

<p><code>/config/application.rb</code></p>

<pre><code class="ruby">config.generators do |g|
  g.view_specs false
  g.helper_specs false
  g.request_specs false
  g.controller_specs false
  g.routing_specs false
end
</code></pre>

<h1>Rspec</h1>

<h3>model</h3>

<pre><code class="ruby">require 'rails_helper' #必須載入才能使用裡面的方法

RSpec.describe Post, type: :model do #RSpec 可省略
    it "is accessible" do
        post = Post.create!
        expect(post).to eq(Post.last)
    end

    it "has title and content columns" do
        columns = Post.column_names
        expect(columns).to include("id")
    end
end
</code></pre>

<ul>
<li><code>describe</code>, <code>context</code> 描述要測試的是什麼，可以用nested</li>
<li><code>it</code>, <code>specify</code>, <code>example</code> 就是⼀⼩段測試</li>
<li><code>expect(…).to</code> 或 <code>expect(…).to_not</code> 定義期望</li>
<li><code>eq</code> 預期的是否和自己設定的相等</li>
<li><code>include</code> 預期的是否有包括自己設定的值</li>
<li><code>describe</code> 和 <code>it</code> 前面加上 x 代表 pending，執行 rspec 就會先跳拓</li>
<li><a href="https://www.relishapp.com/rspec/rspec-expectations/v/3-4/docs/built-in-matchers/change-matcher">其他方法</a></li>
</ul>


<h3>Routing spec syntax</h3>

<pre><code class="ruby">expect(:get =&gt; "/events").to route_to("events#index")
expect(:get =&gt; "/widgets/1/edit").not_to be_routable

expect(:get =&gt; "/posts/1").to route_to(
      :controller =&gt; "posts",
      :action =&gt; "show",
      :id =&gt; "1"
      )
</code></pre>

<h3>Controller spec syntax</h3>

<pre><code class="ruby">expect(response).to render_template(:new)
expect(response).to redirect_to(events_url)
expect(response).to have_http_status(200)
expect(assigns(:event)).to be_a_new(Event)
</code></pre>

<h3>View spec syntax</h3>

<pre><code class="ruby">render
expect(rendered).to include("Title")
expect(response).to render_template(partial: "_form")
</code></pre>

<h3>Helper spec syntax</h3>

<pre><code class="ruby">expect(helper.your_method).to eq("")
</code></pre>

<h3>request</h3>

<pre><code class="ruby">RSpec.describe "Users", :type =&gt; :request do
  before do
    @user = User.create(name: "hello")
  end

  it "GET /users" do
    get "/users"
    expect(response).to have_http_status(200)
    expect(response).to render_template(:index)
    expect(response.body).to include("hello")
  end

  it "GET /user/:id" do
    get "/user", id: @user.id
    expect(response).to have_http_status(200)
    expect(response).to render_template(:index)
    expect(response.body).to include("hello")
  end
</code></pre>

<p>request 通常直接從網址進行 Get 或 Post ，接著判斷傳回來的值是否正確。</p>

<pre><code class="ruby">before do  
    @user = User.new(name: "hello")
end

before(:all) do
    @user = User.new(name: "hello")
end

#也有 after(:each)，afte(:all)
</code></pre>

<ul>
<li>before(:each) 每段it之前執行</li>
<li>before(:all) 整段describe前只執行一次</li>
<li>after(:each) 每段it之後執行</li>
<li>after(:all) 整段describe後只執行一次</li>
<li>(:each) 可以不用加，預設為(:each)</li>
</ul>


<pre><code class="ruby">let(:user){User.new(:name =&gt; "hello")}
</code></pre>

<ul>
<li>相較於 before(:each) 可增加執⾏速度</li>
<li>有使⽤到才會運算(lazy)，並且在同⼀個 example 測試中多次呼叫會 Memoized 快取起來。</li>
<li>let! 則是⾮ lazy 版本</li>
</ul>


<h1>factory_girl</h1>

<p>到 <code>spec/rails_helper.rb</code> 設定</p>

<pre><code class="ruby">RSpec.configure do |config|
  config.include FactoryGirl::Syntax::Methods
end
</code></pre>

<p>在 <code>spec</code> 底下新增 <code>factories</code> 資料夾，接著在裡面新增相對應的物件名稱，像是 <code>user.rb</code></p>

<p><code>spec/factories/user.rb</code></p>

<pre><code class="ruby">FactoryGirl.define do
  factory :user, class: User" do
    name "video1"
    age  18

    trait :child do
      age 6
      #after(:create) {|user| user.add_role(:admin) } 
      #after(:build)  {|user| user.add_role(:admin) } 
      #也可以設定 create 之後的設定
    end
  end
end
</code></pre>

<p>這樣在 spec 裡面就可以直接建立假資料</p>

<pre><code class="ruby">before do  
    @user  = FactoryGirl.create(:user) #FactoryGirl 可省略
    @child = create(:user, :child) #就只替換掉 age
end
</code></pre>

<h3>為什麼要假物件?</h3>

<ul>
<li>無法控制回傳值的外部系統 (例如第三⽅ web service)</li>
<li>建構正確的回傳值很⿇煩 (例如得準備很多假資料)</li>
<li>可能很慢，拖慢測試速度 (例如耗時的運算)</li>
<li>有難以預測的回傳值 (例如亂數⽅法)</li>
<li>還沒開始實作 (特別是採⽤ TDD 流程)</li>
</ul>


<h1>Capybara</h1>

<p>RSpec除了可以拿來寫單元程式，我們也可以把測試的層級拉高做整合性測試，以Web應用程式來說，就是去自動化瀏覽器的操作，實際去向網站伺服器請求，然後驗證出來的HTML是正確的輸出。</p>

<p><a href="https://github.com/jnicklas/capybara">capybara</a>就是一套可以搭配的工具，用來模擬瀏覽器行為</p>

<h1>CI server</h1>

<p>CI(Continuous Integration)
伺服器的用處是每次有人Commit就會自動執行編譯及測試(Ruby不用編譯，所以主要的用處是跑測試)，並回報結果，如果有人送交的程式搞砸了回歸測試，馬上就有回饋可以知道。</p>

<p><a href="https://circleci.com">circleci.com</a></p>

<p>建立 <code>circle.yml</code></p>

<pre><code class="ruby">machine:
  timezone:
    Asia/Taipei
  ruby:
    version: 2.1.2
dependencies:
  pre:
    - rvm use 2.1.2
    - gem install bundler
    - gem install rubocop
  post:
    - gem update rake
database:
  override:
    - cp config/database.yml.example config/database.yml
    - rake db:create db:migrate --trace
test:
  override:
    - bundle exec rspec --color
</code></pre>

<p>建立 <code>config/database.yml.example</code></p>

<pre><code class="ruby">default: &amp;default
  adapter: mysql2
  encoding: utf8
  host: localhost
  username:
  password:

test:
  &lt;&lt;: *default
  database: test_db

development:
  &lt;&lt;: *default
  database: development_db

production:
  &lt;&lt;: *default
  database: production_db
</code></pre>

<p>接著到 <a href="https://circleci.com">circleci.com</a> 和 github 帳號做連結。<br/>
接著將要跑的 project 加進去，之後只要 push 到 github 就會自動跑了！</p>

<h1>大師引言</h1>

<pre><code>大部份都是寫model的測試
controller偶爾會寫

其他的因為後面有驗收測試也會測試到，所以不浪費時間去寫測試
驗收測試多半是測試子路徑，不會測到所有的條件，所以個別的小項測試，就直接在model寫就好了

工程是寫到request就很棒了
feature 比較像是QA在寫的
</code></pre>

<p>官方文件：<br/>
<a href="http://betterspecs.org/">Better Specs</a><br/>
<a href="https://www.relishapp.com/">Relish</a></p>

<p>Gem：<br/>
<a href="https://github.com/rspec/rspec-rails">rspec-rails</a><br/>
<a href="https://github.com/thoughtbot/factory_girl_rails">factory_girl_rails</a>  <br/>
<a href="https://github.com/guard/guard-rspec">guard-rspec</a><br/>
<a href="https://github.com/jnicklas/capybara">capybara</a></p>

<p>參考文件：<br/>
<a href="https://ihower.tw/rails4/testing.html">自動化測試</a><br/>
<a href="http://motion-express.com/trainings/rspec-rails-1">RSpec-Rails (基礎篇)</a><br/>
<a href="http://motion-express.com/blog/20150320-custom-helpers-in-rspec">RSpec-Rails當中自訂methods及helpers</a><br/>
<a href="http://motion-express.com/blog/20150327-rspec-rails-testing-module">RSpec-Rails 針對module進行unit test</a><br/>
<a href="http://www.slideshare.net/ihower/rspec-7394497">RSpec 讓你愛上寫測試</a><br/>
<a href="https://blog.alphacamp.co/2015/03/02/tdd-kata/">程式設計師升級必練內功：TDD Kata</a><br/>
<a href="https://codility.com/programmers/lessons/">codility 練習</a><br/>
<a href="http://www.sportcalculators.com/bowling-score-calculator">保齡球練習</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[用 Carrierwave + FFMPEG 影片轉檔]]></title>
    <link href="http://mgleon08.github.com/blog/2016/01/29/carrierwavea-plus-ffmpeg/"/>
    <updated>2016-01-29T20:26:02+08:00</updated>
    <id>http://mgleon08.github.com/blog/2016/01/29/carrierwavea-plus-ffmpeg</id>
    <content type="html"><![CDATA[<p>若是上傳的檔案是影片，並且要對影片做其他處理，就可以使用 FFMPRG 來處理。</p>

<!-- more -->


<p></p>

<h1>Gem</h1>

<pre><code class="ruby">gem 'carrierwave'
gem 'streamio-ffmpeg'
</code></pre>

<h1>設定</h1>

<p><code>application.rb</code></p>

<pre><code class="ruby">require 'carrierwave'
</code></pre>

<p><code>lib/carrierwave/ffmpeg.rb</code></p>

<pre><code class="ruby">require 'streamio-ffmpeg'
module CarrierWave
  module FFMPEG
    module ClassMethods
      def resample(bitrate)
        process :resample =&gt; bitrate
      end
    end

    def resample(bitrate)
      directory = File.dirname(current_path)
      tmpfile = File.join(directory, "tmpfile")

      FileUtils.mv( current_path, tmpfile )

      file = ::FFMPEG::Movie.new(tmpfile)
      file.transcode(current_path, video_bitrate: bitrate)

      File.delete(tmpfile)
    end
  end
end
</code></pre>

<p><code>app/uploaders/video_uploader.rb</code></p>

<pre><code class="ruby">require File.join(Rails.root, "lib", "carrierwave", "ffmpeg")

class VideoUploader &lt; CarrierWave::Uploader::Base
  include CarrierWave::FFMPEG

  def store_dir
    "uploads/#{model.class.to_s.underscore}/#{mounted_as}/#{model.id}"
  end

  def extension_white_list
    %w(mp4 flv)
  end

  version :bitrate_800k do
    process :resample =&gt; "800k"
  end

  version :bitrate_500k, from_version: :bitrate_800k do
    process :resample =&gt; "500k"
  end

end
</code></pre>

<p>也可以用 ruby 直接下 ffmpef 的指令</p>

<p>Use %x or &lsquo;`&rsquo;:</p>

<pre><code class="ruby">`ffmpeg -y -i #{input_path} -vf "scale=ceil(oh*a):480" -vcodec libx264 -preset:v slow -pix_fmt yuv420p -profile:v baseline -level 3.0 -b #{bitrate} -r 29.97 -acodec libvo_aacenc -ac 2 -ar 44100 -ab 64k -movflags faststart #{output_path}`
%x(ffmpeg -y -i #{input_path} -vf "scale=ceil(oh*a):480" -vcodec libx264 -preset:v slow -pix_fmt yuv420p -profile:v baseline -level 3.0 -b #{bitrate} -r 29.97 -acodec libvo_aacenc -ac 2 -ar 44100 -ab 64k -movflags faststart #{output_path})
</code></pre>

<p>官方文件：<br/>
<a href="https://github.com/carrierwaveuploader/carrierwave">carrierwave</a><br/>
<a href="https://github.com/streamio/streamio-ffmpeg">streamio-ffmpeg</a><br/>
<a href="https://www.ffmpeg.org/">FFMPEG</a></p>

<p>參考文件：<br/>
<a href="http://www.freezzo.com/2010/12/23/create-ffmpeg-processor-for-carrierwave-in-rails-3/">Create FFMPEG processor for Carrierwave in Rails 3</a><br/>
<a href="https://prograils.com/posts/carrierwave-basic-video-conversion">CarrierWave - basic video conversion</a><br/>
<a href="http://stackoverflow.com/questions/3159945/running-command-line-commands-within-ruby-script">Running command line commands within Ruby script</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[用 Carrierwave 輕鬆做上傳檔案功能]]></title>
    <link href="http://mgleon08.github.com/blog/2016/01/22/carrierwave/"/>
    <updated>2016-01-22T22:12:46+08:00</updated>
    <id>http://mgleon08.github.com/blog/2016/01/22/carrierwave</id>
    <content type="html"><![CDATA[<p>另一個上傳檔案的 gem ，相當的實用，和 Paperclip 擇一即可。</p>

<!-- more -->


<h1>安裝</h1>

<p>Gemfile</p>

<pre><code class="ruby">gem 'carrierwave'
gem 'rmagick'

# or gem "mini_magick"
</code></pre>

<ul>
<li>carrierwave 上傳檔案</li>
<li>rmagick 處理圖片</li>
</ul>


<blockquote><p>必須有安裝 ImageMagick 才能使用 rmagick</p></blockquote>

<p>有 homebrew 可以直接</p>

<pre><code class="ruby">brew install imagemagick
</code></pre>

<h1>設定</h1>

<p>先建立資料夾，主要用來存放所有的檔案</p>

<pre><code class="ruby">rails generate uploader file
</code></pre>

<p>接著在在要存放的 model 新增一筆欄位</p>

<pre><code class="ruby">rails generate migration add_file_to_products
</code></pre>

<h1>Model</h1>

<pre><code class="ruby">class Product &lt; ActiveRecord::Base
  mount_uploader :file, FileUploader
end
</code></pre>

<p>最後記得再 strong params 加入</p>

<pre><code class="ruby">private
  def product_params
    params.require(:product).permit(:file)
  end
end
</code></pre>

<h1>Form</h1>

<pre><code class="ruby">&lt;%= form_for @product do |f| %&gt;
  &lt;%= f.file_field :file %&gt;
  &lt;%= f.submit "Submit" %&gt;
&lt;% end %&gt;
</code></pre>

<h1>view</h1>

<pre><code class="ruby">&lt;%= image_tag @product.image_url.to_s %&gt;
</code></pre>

<p>imageurl是預設的helper，to_s是要確定把上傳的路徑轉變為字串，以免發生錯誤。</p>

<h1>RMagick</h1>

<p><code>app/uploaders/file_uploader.rb</code></p>

<p>可以將設定打開，有 RMagick 和 MiniMagick ，都是用來縮圖的。(擇一即可)</p>

<pre><code class="ruby"># Include RMagick or MiniMagick support:
# include CarrierWave::RMagick
# include CarrierWave::MiniMagick
</code></pre>

<p>下面把註解拿掉就可以使用</p>

<pre><code class="ruby">Create different versions of your uploaded files:
version :thumb do
  process :resize_to_fit =&gt; [50, 50]
end
</code></pre>

<p>之後再 view 中只要指定，就會去抓取縮小後的圖檔</p>

<pre><code class="ruby">&lt;%= image_tag @product.image_url(:thumb).to_s %&gt;
</code></pre>

<h1>其他</h1>

<p>限制存取大小<br/>
<a href="https://github.com/carrierwaveuploader/carrierwave/wiki/How-to:-Validate-attachment-file-size">How to: Validate attachment file size</a></p>

<p>存取圖片長寬<br/>
<a href="https://github.com/carrierwaveuploader/carrierwave/wiki/How-to:-Get-image-dimensions">How to: Get image dimensions</a></p>

<p>存取圖片大小和類型<br/>
<a href="https://github.com/carrierwaveuploader/carrierwave/wiki/How-to:-Store-the-uploaded-file-size-and-content-type">How to: Store the uploaded file size and content type</a></p>

<p>官方文件：<br/>
<a href="https://github.com/carrierwaveuploader/carrierwave">carrierwave</a></p>

<p>參考資料：<br/>
<a href="http://motion-express.com/blog/20140708-ruby-gem-carrierwave">Ruby gem &lsquo;Carrierwave&rsquo; 上傳檔案神器的簡易安裝與使用</a><br/>
<a href="http://rubyist.marsz.tw/blog/2012-01-10/carrierwave-guides-with-amazon-s3-and-imagemagick-integration/">使用 Carrierwave 處理檔案上傳 (整合 imagemagick 與 Amazon S3)</a> <br/>
<a href="https://ruby-china.org/topics/4992">gem &lsquo;carrierwave'简易实用介绍</a><br/>
<a href="http://springok-blog.logdown.com/posts/2015/10/21/railsgem-how-to-use-carrierwave-upload-pictures">Rails如何使用Carrierwave上傳圖片</a></p>
]]></content>
  </entry>
  
</feed>
