<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Rails | Leon's Blogging]]></title>
  <link href="http://mgleon08.github.com/blog/categories/rails/atom.xml" rel="self"/>
  <link href="http://mgleon08.github.com/"/>
  <updated>2016-01-13T23:55:31+08:00</updated>
  <id>http://mgleon08.github.com/</id>
  <author>
    <name><![CDATA[LeonJi]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Ruby on Rails - 用 Include 和 Join 避免 N+1 Query]]></title>
    <link href="http://mgleon08.github.com/blog/2016/01/10/ruby-on-rails-include-join-avoid-n-1-query/"/>
    <updated>2016-01-10T10:00:44+08:00</updated>
    <id>http://mgleon08.github.com/blog/2016/01/10/ruby-on-rails-include-join-avoid-n-1-query</id>
    <content type="html"><![CDATA[<p>在 <code>rails</code> 當中，因為 ORM (Object-relational mapping ) 的便利，可以很快速地建立起連結，但在這過程中，經常會發生 <code>N+1 query</code> 的問題，造成效能上的緩慢，因此要如何解決這個問題，是很重要的。</p>

<!--more-->


<h1>N+1 query</h1>

<pre><code class="ruby"># model
class User &lt; ActieRecord::Base
  has_many :skills
end

class Skill &lt; ActiveRecord::Base
  belongs_to :user
end

# controller
def index
  @users = User.all
end

# view
&lt;% @users.each do |user| %&gt;
 &lt;%= user.skills %&gt;
&lt;% end %&gt;
</code></pre>

<p>以上的關聯，就是透過 <code>User</code> 和 <code>Post 的關聯</code> ，在 <code>view</code> 中一筆一筆去資料庫找相關的 <code>post</code> ，而這每一筆去資料庫的動作，就會有以下的查詢，然後造成 <code>N+1 query</code> 的問題。</p>

<p>N+1就是指說，迴圈中查詢 N 筆資料，加上一開始的第一筆。</p>

<pre><code class="ruby">Skill Load (0.2ms)  SELECT `skills`.* FROM `skills` WHERE `skills`.`user_id` = 1
Skill Load (0.2ms)  SELECT `skills`.* FROM `skills` WHERE `skills`.`user_id` = 2
Skill Load (1.6ms)  SELECT `skills`.* FROM `skills` WHERE `skills`.`user_id` = 3
</code></pre>

<p>因此要解決這個問題，就能使用以下方式。</p>

<h1>includes</h1>

<p><code>includes</code> 主要用於可以直接將相關連的資料，在同一筆查詢，一起撈出來</p>

<pre><code class="ruby">User.includes(:skills)

SELECT `skills`.* FROM `skills` WHERE `skills`.`user_id` IN (1, 2, 3)

# 回傳所有 User 和 關聯的 skills
</code></pre>

<p>可以看到後面有 <code>IN (1, 2, 3)</code>，就是將上面一筆一筆查詢，變成這種方式一次撈出來。這樣在 <code>view</code> 中執行 <code>user.skills</code> 就不會再去資料庫查詢，因為已經都先撈出來了。</p>

<pre><code class="ruby">也可以一次 includes 多個關聯

User.includes(skills: :profile)
User.includes(skills: [:cees, :dees])
</code></pre>

<h1>joins</h1>

<p><code>joins</code> 則是關聯其他資料庫，可以進行查詢，但並不會將關聯的資料拉出來。</p>

<pre><code class="ruby">User.joins(:skills)

User Load (0.4ms)  SELECT `users`.* FROM `users` INNER JOIN `skills` ON `skills`.`user_id` = `users`.`id`

#回傳所有，有 skill 的 user
#因為同一個 user 可能有多個 skill ，這樣就會撈出重複的 user 出來 ， 一個 skill 一個 user，因此可以用 .uniq 來去除重複的資料。
#如果是一對一就不會有這個問題了
</code></pre>

<p>回傳的是所有有 <code>skill</code> 的 <code>user</code>，但並不會將 <code>skill</code> 資料撈出來，只是去做比對，因此再用 <code>user.skills</code> ，一樣會去資料庫中撈出資料。</p>

<p>官方資料：<br/>
<a href="http://guides.rubyonrails.org/active_record_querying.html">Active Record Query Interface</a><br/>
<a href="http://rails.ruby.tw/active_record_querying.html">Active Record 查詢</a></p>

<p>參考資料：<br/>
<a href="https://ihower.tw/rails4/performance.html">網站效能</a><br/>
<a href="https://ihower.tw/rails4/activerecord-relationships.html">ActiveRecord - 資料表關聯</a><br/>
<a href="http://motion-express.com/blog/20141028-rails-include-join-avoid-n-1-query">Rails使用 include 和 join 避免 N+1 query</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ruby on Rails - Json]]></title>
    <link href="http://mgleon08.github.com/blog/2016/01/09/ruby-on-rails-json/"/>
    <updated>2016-01-09T12:26:46+08:00</updated>
    <id>http://mgleon08.github.com/blog/2016/01/09/ruby-on-rails-json</id>
    <content type="html"><![CDATA[<p>JSON 是很經常是用到的格式，不管是和程式溝通或是交換資料。</p>

<!--more-->


<h1>什麼是 JSON</h1>

<p>JSON 是個以純文字為基底去儲存和傳送簡單結構資料，可以透過特定的格式去儲存任何資料(字串,數字,陣列,物件)，也可以透過物件或陣列來傳送較複雜的資料。</p>

<p>一旦建立了您的 JSON 資料，就可以非常簡單的跟其他程式溝通或交換資料，因為 JSON 就只是純文字個格式。</p>

<p>JSON 的優點如下:</p>

<ul>
<li>相容性高</li>
<li>格式容易瞭解，閱讀及修改方便</li>
<li>支援許多資料格式 (number,string,booleans,nulls,array,associative array)</li>
<li>許多程式都支援函式庫讀取或修改 JSON 資料</li>
</ul>


<p>參考文件：
<a href="https://blog.wu-boy.com/2011/04/%E4%BD%A0%E4%B8%8D%E5%8F%AF%E4%B8%8D%E7%9F%A5%E7%9A%84-json-%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%B4%B9/">你不可不知的 JSON 基本介紹</a></p>

<h1>Rails 如何傳遞JSON</h1>

<h3>respond_to</h3>

<p>在 <code>rails</code> 當中可以用 <code>respond_to</code> 設定回傳的 <code>format</code>。</p>

<pre><code class="ruby">respond_to do |format|
    format.html { redirect_to :back }
    format.json
    format.js
end

#也可以寫成單行
respond_to :html, :json, :js
</code></pre>

<p>若後面沒指定會去找 <code>view</code> 中，後面是 <code>.json</code> 或 <code>.js</code> 的檔案<br/>
但記得因為 <code>format</code> 有三種，所以要 json 資料的話就在網址後面加 <code>.json</code></p>

<p>respond_to可以用來回應不同的資料格式。Rails內建支援格式包括有<br/>
<code>:html, :text, :js, :css, :ics, :csv, :xml, :rss, :atom, :yaml, :json</code></p>

<blockquote><p>如果需要擴充，可以編輯config/initializers/mime_types.rb這個檔案</p></blockquote>

<h3>render</h3>

<p>可以簡單使用 <code>render json</code> 的方式，直接強制 html 輸出成 json 格式
<code>render json: User.info</code><br/>
這樣連view都不需要，就會直接顯示。</p>

<p>或是直接 <code>render template</code> 指定輸出 json 格式<br/>
<code>render template: "api/users/index.json.jbuilder"</code></p>

<h3>routes scope設定，指定controller使用json格式輸出</h3>

<p>最後是直接設定好 <code>routes</code> 的 <code>default</code> 格式，這樣就不用再指定要 <code>render</code> 什麼!</p>

<pre><code class="ruby">scope :path =&gt; '/api/v1/', :defaults =&gt; { :format =&gt; :json }, :module =&gt; "api_v1", :as =&gt; 'v1' do
    resources :users #ApiV1::CompaniesController
end
</code></pre>

<p><code>path</code>：指令網址前面的路徑<br/>
<code>defaults</code>：指定default的格式<br/>
<code>module</code>：指定 controller 會是 ApiV1::UsersController
<code>as</code>：產生URL helper</p>

<p>參考文件：<br/>
<a href="https://ihower.tw/rails4/routing.html">Scope</a><br/>
<a href="http://motion-express.com/blog/20141124-rails-default-render-json">Rails修改預設顯示格式為json</a></p>

<h1>搭配gem - <a href="https://github.com/rails/jbuilder">jbuilder</a></h1>

<p>再rails當中，很常會用這個 <code>gem</code> 來轉 <code>json</code></p>

<p>像是剛才的<code>render template: "api/users/index.json.jbuilder"</code><br/>
就會去找這個 template，並且像是 <code>html.erb</code> 一樣可以直接使用 <code>@</code> 的參數。</p>

<pre><code class="ruby">#api/users/index.json.jbuilder

json.info do
  json.number do
    json.total User.count
  end

  json.data @users do |u|
    json.id u.id
    json.name u.name
  end
end
</code></pre>

<p>就會生產出以下</p>

<pre><code class="ruby">#json
{
"info": {
  "number": {
     "total": 1
  },
  "data": [
     {
      "id": 1,
      "name": "abc"
            }
        ]
    }
}
</code></pre>

<h1>接收JSON</h1>

<p>可以用 <a href="https://github.com/rest-client/rest-client">rest-client</a> 這個gem<br/>
先用 <code>get</code> 取得資料，再用 <code>JSON.parse</code> 來將 <code>string</code> 解析成 <code>hash</code></p>

<p>範例： <a href="http://data.taipei/opendata/datalist/apiAccess?scope=resourceAquire&amp;rid=ddb80380-f1b3-4f8e-8016-7ed9cba571d5">Ubike</a> 資料，並存取到資料庫。</p>

<pre><code class="ruby">#lib/tasks/dev.rake

namespace :dev do

  task :fetch_ubike =&gt; :environment do
    puts "fetching ubike"

    url = "http://data.taipei/opendata/datalist/apiAccess?scope=resourceAquire&amp;rid=ddb80380-f1b3-4f8e-8016-7ed9cba571d5"

    raw_content = RestClient.get(url)

    data = JSON.parse( raw_content )

    data["result"]["results"].each do |u|
      a = Ubike.find_by_ubike_id( u["_id"] )

      if a == nil
        # maybe update it!
        Ubike.create( :ubike_id =&gt; u["_id"], :name =&gt; u["sna"])
      else
        Ubike.update( :ubike_id =&gt; u["_id"], :name =&gt; u["sna"])
      end
    end

  end

end
</code></pre>

<p>這樣只要打 <code>rake dev:fetch_ubike</code> 就會自動跑了!</p>

<p>範例2：<a href="http://vote.ly.g0v.tw/api/vote/?page=1">立委資料</a></p>

<pre><code class="ruby">#立委資料，資料相當大，很多分頁
namespace :vote do

 task :fetch_raw_vote =&gt; :environment do
   puts "fetching raw_vote"

   url = "http://vote.ly.g0v.tw/api/vote/?page=1"
   raw_content = RestClient.get(url)
   data = JSON.parse( raw_content )
     while data["next"] != nil
        data["results"].each do |r|

           Vote.create( :url =&gt; r["url"],
                           :uid =&gt; r["uid"],
                           :sitting_id =&gt; r["sitting_id"],
                           :vote_seq =&gt; r["vote_seq"],
                           :content =&gt; r["content"],
                           :conflict =&gt; r["conflict"],
                           :results =&gt; r["results"],
                           :result =&gt; r["result"])
         end

         url = data["next"]
         raw_content = RestClient.get(url)
         data = JSON.parse( raw_content )
      end

 end

end
</code></pre>

<p>參考文件：<br/>
<a href="https://blog.wu-boy.com/2011/04/%E4%BD%A0%E4%B8%8D%E5%8F%AF%E4%B8%8D%E7%9F%A5%E7%9A%84-json-%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%B4%B9/">你不可不知的 JSON 基本介紹</a><br/>
<a href="https://ihower.tw/rails4/routing.html">Scope</a><br/>
<a href="http://motion-express.com/blog/20141124-rails-default-render-json">Rails修改預設顯示格式為json</a></p>

<p>gem：<br/>
<a href="https://github.com/rails/jbuilder">jbuilder</a><br/>
<a href="https://github.com/rest-client/rest-client">rest-client</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ruby on Rails - 好用的 Enumerable]]></title>
    <link href="http://mgleon08.github.com/blog/2016/01/07/rails-enumerable/"/>
    <updated>2016-01-07T20:40:22+08:00</updated>
    <id>http://mgleon08.github.com/blog/2016/01/07/rails-enumerable</id>
    <content type="html"><![CDATA[<p>這次主要來介紹一些好用的 Enumerable<br/>
可以很方便的將需要的資料整合在一起</p>

<!-- more -->


<h1>Map/Collect</h1>

<p>對 block 每個值進行運算，並回傳成一個新的 <code>array</code><br/>
處理 <code>hash</code> 時，也可以分開處理 key 和 value</p>

<p><code>map</code> 和 <code>collect</code> 其實是一樣的東西，主要是因為其他語言很多都是用 <code>collect</code>。</p>

<pre><code class="ruby">array = [1,2,3]
array.map {|v| v * 2}
# =&gt; [2, 4, 6]

hash = {:name =&gt; "abc", :age =&gt; 18}
hash.map {|k, v| v }
# =&gt; ["abc", 18]
</code></pre>

<h1>Select</h1>

<p>對物件，挑出指定欄位的值，並回傳 <code>ActiveRecord::Relation</code></p>

<pre><code class="ruby">User.all.select(:id)
=&gt; #&lt;ActiveRecord::Relation [#&lt;User id: 1&gt;, #&lt;User id: 2&gt;, #&lt;User id: 3&gt;,...]&gt;
</code></pre>

<p>可以再搭配 <code>map</code> 變成一個 <code>array</code>。</p>

<pre><code class="ruby">User.all.select(:id).map(&amp;:id)
# =&gt; [1,2,3]
</code></pre>

<p>或是直接針對 array 去篩選</p>

<pre><code class="ruby">my_array = [1,2,3,4,5,6,7,8,100]
my_array.select{|item| item%2==0 }
# =&gt; [2,4,6,8,100]
</code></pre>

<p>hash</p>

<pre><code class="ruby">my_hash = {"Joe" =&gt; "male", "Jim" =&gt; "male", "Patty" =&gt; "female"}
my_hash.select{|name, gender| gender == "male" }
# {"Joe" =&gt; "male", "Jim" =&gt; "male"}

#改成 map 會變成，回傳 boolean值，並且回傳 array
my_hash.map{|name, gender| gender == "male" }
#[true, true, false]
</code></pre>

<h1>Pluck</h1>

<p>對物件，挑出指定欄位的值，並回傳一個新的 <code>array</code><br/>
像是 <code>map</code> 和 <code>select</code> 合在一起的指令</p>

<p>Approach - map</p>

<pre><code class="ruby">User.pluck(:id)
#=&gt; [1, 2, 3]

puts Benchmark.measure {User.pluck(:id)}
#0.000000   0.000000   0.000000 (  0.000857)
</code></pre>

<pre><code class="ruby">User.all.map{|a| a.id}
#=&gt; [1, 2, 3]

puts Benchmark.measure {User.all.map{|a| a.id}}
# 0.000000   0.020000   0.020000 (  0.026401)
</code></pre>

<pre><code class="ruby">User.select(:id)
=&gt; #&lt;ActiveRecord::Relation [#&lt;User id: 1&gt;, #&lt;User id: 2&gt;, #&lt;User id: 3&gt;]&gt;

puts Benchmark.measure {User.select(:id).to_a}
#0.000000   0.000000   0.000000 (  0.001549)
</code></pre>

<p>顯然效能上還是 <code>pluck</code> 最快</p>

<p><code>map</code> 會將所有欄位找出來，再根據 block 的值，回傳新的 <code>array</code></p>

<p><code>pluck</code> 和 <code>select</code> 則是只將需要的欄位選出來，但 <code>select</code> 回傳的是 <code>ActiveRecord::Relation</code> 必須再透過 map 轉成 <code>array</code></p>

<p>參考文件：<br/>
<a href="http://rubyinrails.com/2014/06/05/rails-pluck-vs-select-map-collect/">Rails Pluck vs Select and Map/Collect</a><br/>
<a href="http://gavinmiller.io/2013/getting-to-know-pluck-and-select/">Getting to Know Pluck and Select</a>
<a href="http://ohm.sh/2014/02/09/pluck-vs-map-and-select.html">Pluck vs. map and select</a></p>

<pre><code class="ruby">Person.pluck(:id)
# SELECT people.id FROM people
# =&gt; [1, 2, 3]

Person.pluck(:id, :name)
# SELECT people.id, people.name FROM people
# =&gt; [[1, 'David'], [2, 'Jeremy'], [3, 'Jose']]

Person.pluck('DISTINCT role')
# SELECT DISTINCT role FROM people
# =&gt; ['admin', 'member', 'guest']

Person.where(age: 21).limit(5).pluck(:id)
# SELECT people.id FROM people WHERE people.age = 21 LIMIT 5
# =&gt; [2, 3]

Person.pluck('DATEDIFF(updated_at, created_at)')
# SELECT DATEDIFF(updated_at, created_at) FROM people
# =&gt; ['0', '27761', '173']
</code></pre>

<h1>reject</h1>

<p>回傳 block 為 <code>false</code> 的值，成一個新的 <code>array</code>。</p>

<pre><code class="ruby"># Remove even numbers
(1..30).reject { |n| n % 2 == 0 }
# =&gt; [1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 27, 29]

# Remove years dividable with 4 (this is *not* the full leap years rule)
(1950..2000).reject { |y| y % 4 != 0 }
# =&gt; [1952, 1956, 1960, 1964, 1968, 1972, 1976, 1980, 1984, 1988, 1992, 1996, 2000]

# Remove users with karma below arithmetic mean
total = users.inject(0) { |total, user| total += user.karma }
mean = total / users.size
good_users = users.reject { |u| u.karma &lt; mean }
</code></pre>

<h1>inject</h1>

<p>inject 方法可以先給予初始值(數字，hash，array 都可以)，之後給予指定的元素，不斷的迭代。</p>

<pre><code class="ruby">(5..10).inject(1) {|init, n| init * n }
# =&gt; 151200
(5..10).inject(1, :*)                         
#=&gt; 151200
</code></pre>

<pre><code class="ruby">(5..10).inject {|sum, n| sum * n }
# =&gt; 45
(5..10).inject(:+)                            
#=&gt; 45
</code></pre>

<p>也可以拿來做比較。</p>

<pre><code class="ruby">%w{ cat sheep bear }.inject do |memo,word|
   memo.length &gt; word.length ? memo : word
end
# =&gt; "sheep"
</code></pre>

<p>如果給予 inject 的參數為一個空區塊，那麼 inject 會將結果整理成 Hash。</p>

<pre><code class="ruby">User.all.inject({}) do |hash, user| 
    hash[user.name] = user.id  
    hash # 需要回傳運算結果
end
# =&gt; {"A"=&gt;1, "B"=&gt;2, "C"=&gt;3}
</code></pre>

<p>但要注意的是，由於每跑一次，都會取用最後的回傳值，當做這次的初始值，因此最後必須再加個 <code>hash</code> ，否則會出錯。</p>

<p>也可改用 reduce 跟 inject 一模一樣<br/>
<a href="http://stackoverflow.com/questions/13813243/is-inject-the-same-thing-as-reduce-in-ruby">Is inject the same thing as reduce in ruby?</a></p>

<h3>額外說明</h3>

<p>也可以用 map 方式，湊成上面的值。</p>

<pre><code class="ruby">Hash[User.all.map {|user| [user.name, user.id ]}]
# =&gt; {"A"=&gt;1, "B"=&gt;2, "C"=&gt;3}

User.all.map {|user| [user.name, user.id ]}.to_h
# =&gt; {"A"=&gt;1, "B"=&gt;2, "C"=&gt;3}
</code></pre>

<h1>each_with_object</h1>

<p>跟 inject 非常類似，，主要差別在於你不用回傳運算結果，還有參數是顛倒過來的。</p>

<pre><code class="ruby">User.all.each_with_object({}) do | user, hash | 
    hash[user.name] = user.id  
end
</code></pre>

<h1>each_with_index</h1>

<p>用來加上索引。</p>

<pre><code class="ruby">hash = Hash.new
%w(cat dog wombat).each_with_index {|item, index|
  hash[item] = index
}
#=&gt; ["cat", "dog", "wombat"]

hash
#=&gt; {"cat"=&gt;0, "dog"=&gt;1, "wombat"=&gt;2}
</code></pre>

<p><a href="http://www.bbs-software.com/blog/2013/11/22/rubys-injectreduce-and-each_with_object/">Ruby’s inject/reduce and each_with_object</a></p>

<p>也可以用來將複數的的 position 印出來。</p>

<pre><code class="ruby">["Cool", "chicken!", "beans!", "beef!"].each_with_index do |item, index|
    print "#{item} " if index%2==0
end
Cool beans!  # =&gt; ["Cool", "chicken!", "beans!", "beef!"]
</code></pre>

<h1>sum</h1>

<p>可以算出集合的加總</p>

<pre><code class="ruby">payments.sum { |p| p.price * p.tax_rate }
payments.sum(&amp;:price)
</code></pre>

<p>數字，字串，陣列都可以，其實就是用 <code>+</code> 的方法</p>

<pre><code class="ruby">[5, 15, 10].sum # =&gt; 30
['foo', 'bar'].sum # =&gt; "foobar"
[[1, 2], [3, 1, 5]].sum #=&gt; [1, 2, 3, 1, 5]
</code></pre>

<h1>group_by</h1>

<p>可以依照指定的欄位分組出來。</p>

<pre><code class="ruby">latest_transcripts.group_by(&amp;:day).each do |day, transcripts|
  p "#{day} -&gt; #{transcripts.map(&amp;:class).join(', ')}"
end

# "2006-03-01 -&gt; Transcript"
# "2006-02-28 -&gt; Transcript"
# "2006-02-27 -&gt; Transcript, Transcript"
# "2006-02-26 -&gt; Transcript, Transcript"
# "2006-02-25 -&gt; Transcript"
# "2006-02-24 -&gt; Transcript, Transcript"
# "2006-02-23 -&gt; Transcript"
</code></pre>

<pre><code class="ruby">names = ["James", "Bob", "Joe", "Mark", "Jim"]
names.group_by{|name| name.length}
# =&gt; {5=&gt;["James"], 3=&gt;["Bob", "Joe", "Jim"], 4=&gt;["Mark"]} 
</code></pre>

<h1>grep</h1>

<p>根據指定的條件塞選</p>

<pre><code class="ruby">names = ["James", "Bob", "Joe", "Mark", "Jim"]
names.grep(/J/)
#=&gt; ["James", "Joe", "Jim"]
</code></pre>

<h1>index_by</h1>

<p>index_by可以指定欄位做為鍵值整理成Hash。</p>

<pre><code class="ruby">User.index_by(&amp;:phone)
# =&gt; {'0912xxxxxx' =&gt; &lt;User ...&gt;, '0919xxxxxx' =&gt; &lt;User ...&gt;, ...}
</code></pre>

<p>鍵值通常必須是唯一的，若不是唯一的話，會以最後出現的元素做為判斷值。</p>

<h1>any?</h1>

<p>只要有任何條件符合，就回傳true</p>

<pre><code class="ruby">%w{ant bear cat}.any? {|word| word.length &gt;= 3}   
#=&gt; true
%w{ant bear cat}.any? {|word| word.length &gt;= 4}   
#=&gt; true
[ nil, true, 99 ].any?                            
#=&gt; 只要有一個不是 nil 和 false 就是 true
</code></pre>

<p>主要都是集合的方法</p>

<p>可參考之前的<br/>
<a href="http://mgleon08.github.io/blog/2015/12/16/ruby-on-rail-nil-empty-blank-present/">.nil? .empty? .blank? .present? 傻傻分不清楚？</a></p>

<h1>&amp;:</h1>

<pre><code class="ruby">User.all.map(&amp;:name)
</code></pre>

<p> <code>&amp;:</code> 代表代入一個Proc<br/>
 <code>(&amp;:name)</code> = <code>{|name| user.name}</code> 的概念XD。</p>

<h1>Benchmark</h1>

<p>上面其實很多都很類似，主要差異的話就是速度吧<br/>
所以可以用以下的方式來測試每種執行出來的速度。</p>

<p><a href="http://ruby-doc.org/stdlib-2.0.0/libdoc/benchmark/rdoc/Benchmark.html">Benchmark</a><br/>
<a href="https://github.com/evanphx/benchmark-ips">benchmark-ips</a></p>

<p>官方文件：<br/>
<a href="http://ruby-doc.org/core-2.1.0/Enumerable.html">Enumerable</a><br/>
<a href="http://apidock.com/ruby/Array/map">map/collect</a><br/>
<a href="http://ruby-doc.org/core-2.2.3/Enumerable.html#method-i-reject">reject</a><br/>
<a href="http://apidock.com/ruby/Enumerable/inject">inject</a><br/>
<a href="http://apidock.com/rails/ActiveRecord/QueryMethods/select">select</a><br/>
<a href="http://apidock.com/rails/ActiveRecord/Calculations/pluck">pluck</a>  <br/>
<a href="http://apidock.com/ruby/Enumerable/reduce">reduce</a><br/>
<a href="http://apidock.com/rails/Enumerable/each_with_object">each_with_object</a><br/>
<a href="http://apidock.com/ruby/v1_9_3_392/Enumerable/each_with_index">each_with_index</a><br/>
<a href="http://apidock.com/rails/Enumerable/sum">sum</a><br/>
<a href="http://apidock.com/rails/Enumerable/group_by">group_by</a><br/>
<a href="http://apidock.com/rails/v4.2.1/Enumerable/index_by">index_by</a><br/>
<a href="http://apidock.com/rails/Enumerable/many%3F">many?</a><br/>
<a href="http://apidock.com/ruby/Enumerable/any%3F">any?</a></p>

<p>參考文件：<br/>
<a href="http://rubyinrails.com/2014/06/05/rails-pluck-vs-select-map-collect/">Rails Pluck vs Select and Map/Collect</a><br/>
<a href="http://gavinmiller.io/2013/getting-to-know-pluck-and-select/">Getting to Know Pluck and Select</a><br/>
<a href="http://ohm.sh/2014/02/09/pluck-vs-map-and-select.html">Pluck vs. map and select</a><br/>
<a href="http://www.eriktrautman.com/posts/ruby-explained-map-select-and-other-enumerable-methods">Ruby Explained: Map, Select, and Other Enumerable Methods</a><br/>
<a href="https://gist.github.com/cupakromer/3371003">each_with_object vs inject</a><br/>
<a href="https://ihower.tw/rails4/activesupport.html">ActiveSupport - 工具函式庫</a><br/>
<a href="http://motion-express.com/blog/20141027-ruby-inject-each-with-object-hash">Ruby 用 inject 和 each_with_object 來組 hash
</a>
<a href="http://stackoverflow.com/questions/1217088/what-does-mapname-mean-in-ruby">What does map(&amp;:name) mean in Ruby?</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[用 Backup 來備份資料庫]]></title>
    <link href="http://mgleon08.github.com/blog/2016/01/03/backup/"/>
    <updated>2016-01-03T21:42:46+08:00</updated>
    <id>http://mgleon08.github.com/blog/2016/01/03/backup</id>
    <content type="html"><![CDATA[<p>當網站上線之後，經常會提心吊膽的害怕網站資料不見。<br/>
這是很重要的動作就是 <code>備份</code> !</p>

<!-- more -->


<p>這次主要介紹用 <a href="http://backup.github.io/backup/v4/">backup</a>來做備份</p>

<p>先到遠端的 server 上面</p>

<p><code>gem install backup</code></p>

<p>將 backup 安裝起來</p>

<p>接著輸入</p>

<p><code>backup generate:model --trigger my_backup --archives --storages='s3' --compressor='gzip' --notifiers=‘mail'</code></p>

<p>之後會產生一個 <code>config.rb</code> 和一個 <code>my_backup.rb</code> 的檔案。</p>

<p>打開 <code>my_backup.rb</code> 設定</p>

<pre><code class="ruby">Model.new(:my_backup, '[describe]') do

  ##
  # MySQL [Database]
  #
  database MySQL do |db|
    # To dump all databases, set `db.name = :all` (or leave blank)
    db.name               = "[dbname]"
    db.username           = "root"
    db.password           = "xxxx"
    db.host               = "localhost"
    db.port               = 3306
    # db.socket             = "/tmp/mysql.sock"
    # Note: when using `skip_tables` with the `db.name = :all` option,
    # table names should be prefixed with a database name.
    # e.g. ["db_name.table_to_skip", ...]
    # db.skip_tables        = ["skip", "these", "tables"]
    # db.only_tables        = ["only", "these", "tables"]
    db.additional_options = ["--quick", "--single-transaction"]
  end

  ##
  # Amazon Simple Storage Service [Storage]
  #

 # 將備份檔案儲存到S3
 store_with S3 do |s3|
    # AWS Credentials
    s3.access_key_id     = "xxxx"
    s3.secret_access_key = "xxxx"
    # Or, to use a IAM Profile:
    # s3.use_iam_profile = true

    s3.region            = "ap-northeast-1"
    s3.bucket            = "[bucketname]"
    s3.path              = "[path]"
  end

  # 額外的檔案壓縮，例如用戶上傳的圖片，就可以指定路徑
  # archive.add “/home/deploy/xxxxxxx/shared/public/systems/
  # archive :my_archive do |archive|
    # Run the `tar` command using `sudo`
    # archive.use_sudo
    # archive.add "/srv"
  # end

  ##
  # Gzip [Compressor]
  #
  compress_with Gzip

  ##
  # Mail [Notifier]
  #
  # The default delivery method for Mail Notifiers is 'SMTP'.
  # See the documentation for other delivery options.
  # 寄信通知，也有很多其他的通知方法，官方文件都有
  notify_by Mail do |mail|
    mail.on_success           = true
    mail.on_warning           = true
    mail.on_failure           = true

    mail.from                 = "mail.from"
    mail.to                   = "mail.to"
    mail.address              = "smtp.mailgun.org"
    mail.port                 = 587
    mail.domain               = "mail.domain"
    mail.user_name            = "mail.user_name"
    mail.password             = "mail.password"

    mail.authentication       = "plain"
    mail.encryption           = :starttls
  end
end
</code></pre>

<p>接著打</p>

<p><code>backup perform --trigger my_backup</code></p>

<p>就可以做備份了</p>

<h1>排程</h1>

<p>每次都要手動去備份相當麻煩，因此接下來就是要設定固定時間跑指令來做備份拉。</p>

<p>這邊是用 <a href="https://github.com/javan/whenever">whenever</a> 來跑 crontab</p>

<p>先在 Gemfile. 加入</p>

<p><code>gem 'whenever', :require =&gt; false</code></p>

<p>接著打 <code>wheneverize .</code></p>

<p>就會產生檔案 <code>config/schedule.rb</code></p>

<p>打開檔案</p>

<pre><code class="ruby">env :PATH, ENV['PATH']
set :output, '/home/[username]/cron.log'

every 1.day, :at =&gt; '4:30 am' do
  command "/usr/local/bin/backup perform -t my_backup -c /home/[username]/Backup/config.rb"
end
</code></pre>

<blockquote><p>切記! 路徑要用絕對路徑啊啊啊!</p></blockquote>

<p>設定就完成囉!</p>

<p>如果有使用 capistrano 的話，可以在 Capfile 加入下面程式：
<code>require "whenever/capistrano"</code></p>

<p>也可以只更新遠端 whenever<br/>
<code>cap production whenever:update_crontab</code></p>

<p>另外要看有沒有進排程可以打</p>

<p><code>crontab -e</code></p>

<p>另外 crontab 會分帳號的，所以要用原本的帳號打才會出現。</p>

<blockquote><p>如果只用 whenever 的 rake “XXX” 的話，crontab -e 裡面會先 cd 到專案目錄下，
這時候 log/cron.log 就沒問題</p>

<p>但是 whenever 的 command “XXXX” 並不會先 cd 到專案目錄下，因此 log/cron.log 會不知道跑去哪裡</p></blockquote>

<h1>匯入資料庫</h1>

<p>有了備份檔案，就能夠直接在本機端匯入檔案<br/>
匯入方式如下</p>

<p><code>mysql -u root -p db_name &lt; backup.sql</code></p>

<p>就會看到資料都匯入進去了，另外圖片都是存在 s3 ，如果希望圖片也顯示，就將 production 的圖片複製一份到 development 就可以了，因為兩邊設定的 bucket 是不一樣的。</p>

<p>官方文件：<br/>
<a href="http://backup.github.io/backup/v4/">backup</a><br/>
<a href="https://github.com/javan/whenever">whenever</a></p>

<p>參考文件：<br/>
<a href="http://blog.eddie.com.tw/2011/05/24/backup-your-website/">用Backup來備份你的網站</a><br/>
<a href="http://lemonup.logdown.com/posts/169422-rails-whenever-use-note">Whenever 使用筆記</a><br/>
<a href="http://programmer.shinchi.tw/2013/12/18/mysql%E5%8C%AF%E5%85%A5%E8%88%87%E5%8C%AF%E5%87%BA%E6%8C%87%E4%BB%A4/">mysql匯入與匯出指令</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ruby on Rails - Helper?partial?yield?]]></title>
    <link href="http://mgleon08.github.com/blog/2015/12/21/ruby-on-rails-view-helper-partial-yield/"/>
    <updated>2015-12-21T11:08:08+08:00</updated>
    <id>http://mgleon08.github.com/blog/2015/12/21/ruby-on-rails-view-helper-partial-yield</id>
    <content type="html"><![CDATA[<p>在 Rails 中 View 是負責放 html 的地方，因此會盡量讓它單純呈現畫面，邏輯的東西則是放在別的地方。<br/>
但是有時候還是不免會有許多重複的 html ，或是判斷和邏輯的東西必須擺放。<br/>
因此 rails 就有提供了幾個方法可以解決這些問題。</p>

<!-- more -->


<h1>helper</h1>

<p>Helper 主要是來整理 view 中，包含邏輯的部份，指的是可以在 Template 中使用的輔助方法。</p>

<p>像是</p>

<ul>
<li>link_to：可以轉換成，HTML 的 <code>&lt;a&gt;</code> 標籤</li>
<li>image_tag：可以轉換成，HTML 的 <code>&lt;img&gt;</code> 標籤</li>
<li>simple_format：可以將內容中 <code>\n</code> 換行字元換成HTML的 <code>&lt;br&gt;</code> 標籤</li>
<li>truncate：可以將過長的內容，指定擷取前幾個字元，後面則變成 &hellip;</li>
<li>strip_tags：移除HTML標籤</li>
</ul>


<p>以上這些都是內建好的一些 helper<br/>
當然我們也可以自訂自己的 helper 出來</p>

<h3>範例</h3>

<p>判斷現在登入的使用者，是否為此篇文章的使用者，是的話才顯示刪除按鈕。</p>

<pre><code class="ruby"># 如果指定用户是當前用户，返回 true
def current_user?(user)
    user == current_user
end
</code></pre>

<p>這樣在 view 中就可以</p>

<pre><code class="ruby">&lt;% if current_user?(@post.user) %&gt;
    &lt;%= link_to "delete", post_path, method: :delete, data: { confirm: "You sure?" } %&gt;
&lt;% end %&gt;
</code></pre>

<blockquote><p>注意 helper 檔案，會預設跟 controller 和 view 一樣的名稱，但是並沒有限制只有該名稱的 view 才能使用，而是所有 view 都能使用。controller 則無法使用。</p></blockquote>

<p>若是希望 controller 可以使用，可以在 controller 檔案加上 <code>include PostsHelper</code></p>

<p>application_controller.rb</p>

<pre><code class="ruby">class ApplicationController &lt; ActionController::Base
  protect_from_forgery with: :exception
  include PostsHelper
end
</code></pre>

<p>或是在 controller 加上 <code>view_context</code></p>

<pre><code class="ruby">class PostsController
  def show
    @post =  view_context.truncate(@post.desc, :lenght =&gt; 50 )
  end
end
</code></pre>

<p>最後是 helper 也可以放 html 進去<br/>
只要加上 <code>content_tag</code></p>

<pre><code class="ruby">content_tag(:p, "Hello world!")
 # =&gt; &lt;p&gt;Hello world!&lt;/p&gt;
content_tag(:div, content_tag(:p, "Hello world!"), class: "strong")
 # =&gt; &lt;div class="strong"&gt;&lt;p&gt;Hello world!&lt;/p&gt;&lt;/div&gt;
content_tag(:div, "Hello world!", class: ["strong", "highlight"])
 # =&gt; &lt;div class="strong highlight"&gt;Hello world!&lt;/div&gt;
content_tag("select", options, multiple: true)
 # =&gt; &lt;select multiple="multiple"&gt;...options...&lt;/select&gt;

&lt;%= content_tag :div, class: "strong" do -%&gt;
  Hello world!
&lt;% end -%&gt;
 # =&gt; &lt;div class="strong"&gt;Hello world!&lt;/div&gt;
</code></pre>

<p><a href="http://apidock.com/rails/ActionView/Helpers/TagHelper/content_tag">content_tag</a></p>

<h1>partial(局部樣板)</h1>

<p>partial 主要是來整理 view 中，重複出現的部分。</p>

<h3>範例</h3>

<p>_post_list.html.erb</p>

<pre><code class="ruby">&lt;% @posts.each do |post| %&gt;
  &lt;li&gt;&lt;%= post.id %&gt;&lt;/li&gt;
  &lt;li&gt;Title: &lt;%= link_to(post.title, post_path(post)) %&gt;&lt;/li&gt;
  &lt;li&gt;Content: &lt;%= post.content %&gt;&lt;/li&gt;
&lt;% end %&gt;
</code></pre>

<p>記得照 rails 的慣例，partial 檔案前面要加上 <code>_</code></p>

<p>之後再 view 中只要 <code>render</code> 指定的位置，就可以了</p>

<p>index.html.erb</p>

<pre><code class="ruby">&lt;%= render 'post_list' %&gt;
</code></pre>

<h3>collection partial</h3>

<p>另外一種是直接傳遞參數進去的 collection partial，上述可改成</p>

<p>_post_list.html.erb</p>

<pre><code class="ruby">&lt;li&gt;&lt;%= post.id %&gt;&lt;/li&gt;
&lt;li&gt;Title: &lt;%= link_to(post.title, post_path(post)) %&gt;&lt;/li&gt;
&lt;li&gt;Content: &lt;%= post.content %&gt;&lt;/li&gt;
</code></pre>

<p>index.html.erb</p>

<p>```ruby</p>

<ul><%= render :partial => "post_list", :collection => @posts, :as => :post %></ul>


<pre><code>or
</code></pre>

<p>&lt;% @posts.each do |p|
  &lt;%= render :partial => &ldquo;post_list&rdquo;, :locals => { :post => p } %>
&lt;% end %>
```</p>

<p>將參數直接丟進去，就不用在 view 裡面包 block</p>

<h1>yield</h1>

<p>yield 主要是會被替換成樣板的地方。<br/>
通常是使用在 layout 裡面的 <code>application.html.erb</code>。<br/>
會將上下板固定，而中間有 <code>&lt;%= yield %&gt;</code> 的地方，就是顯示其他所有的 html.erb 檔案的內容</p>

<p>好處是可以將網站的版型固定，只在需要出現內容的地方用 yield 引進來就可以了。</p>

<p>另外的作用是像是，網站標題，或是fb的Open Graph設定等等，都可以使用這個方式。</p>

<h3>網站標題</h3>

<p>先在 <code>helper</code> 設定</p>

<pre><code class="ruby">  def full_title(page_title = '')
    base_title = "Ruby on Rails"
    if page_title.empty?
      base_title
    else
      page_title + " | " + base_title
    end
  end
</code></pre>

<p>接著在 <code>application.html.erb</code></p>

<pre><code class="ruby"> &lt;title&gt;&lt;%= full_title(yield(:title)) %&gt;&lt;/title&gt;
</code></pre>

<p>之後就可以在每個想呈現不同標題的地方加上</p>

<pre><code class="ruby">&lt;% provide(:title, "About") %&gt;
# 也可以改 &lt;% content_for(:title, "About") %&gt;
</code></pre>

<h3>Facebook Open Graph</h3>

<p>在 <code>application.html.erb</code></p>

<pre><code class="ruby">&lt;%= yield :head %&gt;
</code></pre>

<p>再到要加 Open Graph 設定的頁面加上</p>

<pre><code class="ruby">&lt;%= content_for :head do %&gt;
    &lt;%= tag(:meta, :content =&gt; @post.name, :property =&gt; "og:title") %&gt;
    &lt;%= tag(:meta, :content =&gt; truncate(@post.about, :length =&gt; 150 ), :property =&gt; "og:description") %&gt;
    &lt;%= tag(:meta, :content =&gt; "post", :property =&gt; "og:type") %&gt;
    &lt;%= tag(:meta, :content =&gt; post_url(@post), :property =&gt; "og:url") %&gt;
&lt;% end %&gt;
</code></pre>

<p>總結</p>

<ul>
<li>partial 負責經常性重複的東西，或是比較大片HTML的東西。</li>
<li>helper 負責處理跟邏輯判斷有關的東西。</li>
<li>yield 負責替換樣板的東西。</li>
</ul>


<blockquote><p>建議在 Helper 與 Controller 的 code 不要互相混來呼叫來呼叫去。<br/>
讓 View 歸 View，Controller 歸 Controller。<br/>
若真有業務上的需求需要「到處都可以用」。建議寫 Module 掛在 lib 用 mixin 技巧混入。</p></blockquote>

<p>官方文件：<br/>
<a href="http://guides.rubyonrails.org/layouts_and_rendering.html#structuring-layouts">Guides</a><br/>
<a href="http://rails.ruby.tw/layouts_and_rendering.html#%E7%B5%84%E7%B9%94%E7%89%88%E5%9E%8B">Guides 中文</a></p>

<p>APIdock：<br/>
<a href="http://apidock.com/rails/ActionView/Partials">partial</a><br/>
<a href="http://apidock.com/rails/ActionController/Helpers">helper</a></p>

<p>參考資料：<br/>
<a href="https://ihower.tw/rails4/actionview.html">Ruby on Rails 實戰聖經</a><br/>
<a href="https://rocodev.gitbooks.io/rails-102/content/chapter1-mvc/v/what-is-view.html">rails102</a><br/>
<a href="http://blog.xdite.net/posts/2011/12/09/how-to-design-helpers">如何運用 / 設計 Rails Helper (1)</a><br/>
<a href="http://blog.xdite.net/posts/2011/12/10/how-to-design-helpers-2">如何運用 / 設計 Rails Helper (2)</a><br/>
<a href="http://blog.xdite.net/posts/2012/01/16/how-to-design-helper-3">如何運用 / 設計 Rails Helper (3)</a></p>
]]></content>
  </entry>
  
</feed>
