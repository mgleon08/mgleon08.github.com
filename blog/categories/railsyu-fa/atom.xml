<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Rails語法 | Leon's Blogging]]></title>
  <link href="http://mgleon08.github.com/blog/categories/railsyu-fa/atom.xml" rel="self"/>
  <link href="http://mgleon08.github.com/"/>
  <updated>2015-12-13T21:28:41+08:00</updated>
  <id>http://mgleon08.github.com/</id>
  <author>
    <name><![CDATA[LeonJi]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Ruby on Rails-accepts_nested_attributes_for]]></title>
    <link href="http://mgleon08.github.com/blog/2015/12/13/ruby-on-rails-accepts-nested-attributes-for/"/>
    <updated>2015-12-13T18:35:13+08:00</updated>
    <id>http://mgleon08.github.com/blog/2015/12/13/ruby-on-rails-accepts-nested-attributes-for</id>
    <content type="html"><![CDATA[<p><code>accepts_nested_attributes_for</code> 是一個蠻常會用到的語法</p>

<p>簡單的來說，就是可以透過這個語法，在更新 data 的時候，同時更新其他 model 裡的 data<br/>
所以並不是每個 model 都必須要有 controller 才能夠做更新的動作</p>

<!-- more -->


<p>這裏有兩種情境</p>

<h1>One-to-one</h1>

<pre><code class="ruby">class Book &lt; ActiveRecord::Base
  has_one :author
  accepts_nested_attributes_for :author
end
</code></pre>

<pre><code class="ruby">params = { book: { name: 'Harry Potter', author_attributes: { name: 'J. K. Rowling' } } }

book = Book.create(params[:book])
book.author.name # =&gt; 'J. K. Rowling'
</code></pre>

<p>透過 params 更新 Book 的 name<br/>
同時透過 <code>author_attributes: { name: 'J. K. Rowling' }</code> 更新 Author 的 name</p>

<p>當然 update 同樣適用</p>

<pre><code class="ruby">params = { book: { author_attributes: { name: 'J. K. Rowling' } } }
book.update params[:book]
book.author.name # =&gt; 'J. K. Rowling'
</code></pre>

<p>另外值得注意的是</p>

<pre><code class="ruby">accepts_nested_attributes_for :author, :allow_destroy =&gt; true, :reject_if =&gt; :all_blank
</code></pre>

<p><code>:allow_destroy =&gt; true</code> 可以在表單增加一個 _destroy 核選塊來表示刪除<br/>
<code>:reject_if =&gt; :all_blank</code> 表示在什麼條件下就當作沒有要動作， all_blank 表示如果資料都是空的，就不執行</p>

<h1>One-to-many</h1>

<pre><code class="ruby">class Book &lt; ActiveRecord::Base
  has_many :pages
  accepts_nested_attributes_for :page
end
</code></pre>

<pre><code class="ruby">params = { book: { 
    name: 'Harry Potter', page_attributes: [
        { title: "Philosopher's Stone" }, 
        { title: "Chamber of Secrets" }
    ] 
}}

book = Book.create(params[:book])
book.pages.length # =&gt; 2
book.pages.first.title # =&gt; 'Philosopher's Stone'
book.pages.last.title # =&gt; 'Chamber of Secrets'
</code></pre>

<h1>通常會搭配 fields_for 來嵌入到同一個表單</h1>

<h3>One-to-one</h3>

<pre><code class="ruby">&lt;%= form_for @book do |b| %&gt;
  &lt;%= b.label :name %&gt;
  &lt;%= b.text_field : name %&gt;

  &lt;%= b.fields_for :author do |a| %&gt;
      &lt;%= a.label :name %&gt;
      &lt;%= a.text_field : name %&gt;

      &lt;% unless a.object.new_record? %&gt;
         &lt;%= a.label :_destroy, 'Remove:' %&gt;
        &lt;%= a.check_box :_destroy %&gt;
      &lt;% end %&gt;
  &lt;% end %&gt;

  &lt;%= b.submit %&gt;
&lt;% end %&gt;
</code></pre>

<p>這樣就能夠透過原本是 @book 的表單，裡面再放入 author 的欄位進行更新。</p>

<h3>One-to-many</h3>

<p>one-to-many 會比較麻煩，因為當新增的時候，並不知道要新增幾個，因此會動用到 jquery 的動態新增，就是可以在表單上面一直增加欄位。</p>

<p>不過幸好有 gem 可以解決了，以下有幾個 gem</p>

<ul>
<li><a href="https://github.com/ryanb/nested_form">nested_form</a> ( <a href="http://motion-express.com/blog/20140722-ruby-gem-nested-form">網路上教學</a></li>
<li><a href="https://github.com/nathanvda/cocoon">cocoon</a></li>
<li><a href="https://github.com/ncri/nested_form_fields">nested_form_fields</a></li>
</ul>


<h1>strong parameter</h1>

<p>最後記得要加 strong parameter<br/>
one-to-one 和 one-to-many 都要</p>

<pre><code class="ruby">def book_params
    params.require(:book)
        .permit(:name, pages_attributes:[:title, :_destroy, :id])
end
</code></pre>

<blockquote><p>每個 gem strong parameter 的方式都有點不太一樣，記得要看一下</p></blockquote>

<h1>helper</h1>

<p>book_helper.rb</p>

<pre><code class="ruby">def setup_author(book)
    book.build_author if book.author.blank? 
    #one-to-one 用 build_author ， one-to-many 可以用 authors.build or authors.new 
    book
end
</code></pre>

<p>如果一開始沒設定的話，在 book 表單上是看不到 author 的欄位，因為一開始還沒 build  <br/>
因此要給它一個判斷，如果是 nil 就先 build_author 給它</p>

<p>接著用 <code>setup_author(@book)</code> 來置換 form_for 中的 @book</p>

<pre><code class="ruby">&lt;%= form_for setup_author(@book), :url =&gt; books_path do |b| %&gt;

...

&lt;% end %&gt;
</code></pre>

<p>官方文件：<a href="http://api.rubyonrails.org/classes/ActiveRecord/NestedAttributes/ClassMethods.html">accepts_nested_attributes_for </a> <a href="http://apidock.com/rails/ActionView/Helpers/FormHelper/fields_for">fields_for</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ruby on Rails-delegate]]></title>
    <link href="http://mgleon08.github.com/blog/2015/12/13/ruby-on-rails-delegate/"/>
    <updated>2015-12-13T12:25:16+08:00</updated>
    <id>http://mgleon08.github.com/blog/2015/12/13/ruby-on-rails-delegate</id>
    <content type="html"><![CDATA[<p>神奇語法delegate，之前就看過這個語法，不過一直搞不懂在幹什麼？<br/>
研究了之後，發現是個很magic的用法!!</p>

<!-- more -->


<blockquote><p>說穿了其實是讓 class 的 object 可以直接呼叫到另一個 class 的 method</p></blockquote>

<p>還是看範例比較快</p>

<pre><code class="ruby">class Cart &lt; ActiveRecord::Base
  has_many :cart_items
  delegate :empty?, :clear, to: :line_items
end
</code></pre>

<pre><code class="ruby">class CartItem &lt; ActiveRecord::Base
  belongs_to :cart
end
</code></pre>

<p>上面有兩個 model 的關係是 one-to-many<br/>
一般正常來說必須要<code>@cart.cart_items.empty?</code> 才能夠從 cart 關聯到 cart_items 在呼叫他的方法 <code>empty?</code></p>

<p>不過因為加上了</p>

<pre><code class="ruby">delegate :empty?, :clear, to: :line_items
</code></pre>

<p>所以直接呼叫 <code>@cart.empty?</code> 就可以回傳 <code>@cart.cart_items.empty?</code><br/>
仔細觀察後，其實也就等於下面的 method (但是可以一行解決下面的語法</p>

<pre><code class="ruby">def empty?
    cart_items.empty?
end
</code></pre>

<p>另外還可以加上 <code>prefix: true</code></p>

<pre><code class="ruby">delegate :empty?, :clear, to: :line_items, prefix: true
</code></pre>

<p>變成直接呼叫 <code>@cart.cart_items_empty?</code> 字面上面的更加清楚!</p>

<p>在官方API文件上甚至可以看到
可以加上 <code>allow_nil: true</code> 允許 nil
甚至是 prefix 可以加上別的字，變成</p>

<pre><code class="ruby">delegate :empty?, :clear, to: :line_items, prefix: mycart
</code></pre>

<p>就變成 <code>@cart. mycart_empty?</code><br/>
蠻酷的吧!</p>

<p>官方文件：
<a href="http://apidock.com/rails/Module/delegate">delegate</a></p>

<ol>
<li>:to - Specifies the target object</li>
<li>:prefix - Prefixes the new method with the target name or a custom prefix</li>
<li>:allow_nil - if set to true, prevents a NoMethodError to be raised</li>
</ol>

]]></content>
  </entry>
  
</feed>
