<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Gem | Leon's Blogging]]></title>
  <link href="http://mgleon08.github.com/blog/categories/gem/atom.xml" rel="self"/>
  <link href="http://mgleon08.github.com/"/>
  <updated>2016-01-29T21:40:07+08:00</updated>
  <id>http://mgleon08.github.com/</id>
  <author>
    <name><![CDATA[LeonJi]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[用 Rspec + Factory Girl 寫測試]]></title>
    <link href="http://mgleon08.github.com/blog/2016/01/29/rspec-plus-factory-girl/"/>
    <updated>2016-01-29T20:36:46+08:00</updated>
    <id>http://mgleon08.github.com/blog/2016/01/29/rspec-plus-factory-girl</id>
    <content type="html"><![CDATA[<p>程式寫久之後，就會發現測試的重要性!<br/>
因此來介紹 rails 中，比內建測試還好用的 rspec 搭配 factory_girl</p>

<!-- more -->


<h1>測試種類</h1>

<ul>
<li><p>單元測試(Unit test)<br/>
針對每個程式各個最小單位進行測試，像是在 controller 就單單只測試 controller 裡面的 action，而裡面產生的 model,method，都用假的方式來取代，已確保有錯誤時，可以很快知道是哪邊有問題 。</p></li>
<li><p>整合測試(Integration test)<br/>
主要是用來測試，每個 class 的互動，像是 controller 裡面會 call 到 model ，也會 call 到 view ，並測試回傳的值是否正確。</p></li>
</ul>


<h1>寫測試的好處</h1>

<ul>
<li>Instant Feedback 即時反饋（寫測試的時間 &lt; debug的時間）</li>
<li>回歸測試及重構 （重構時就不需要再重複的測試）</li>
<li>幫助設計API（TDD = 先測試，在實作）</li>
<li>一種程式文件（可以讓很快就知道之前api怎麼寫的）</li>
</ul>


<h1>慣例</h1>

<ul>
<li>⼀個 rb 檔案配⼀個同名的 _spec.rb 檔案</li>
<li>guard 等⼯具容易設定<br/>
<a href="https://github.com/guard/guard-rspec">guard-rspec</a> 程式⼀修改完存檔，⾃動跑對應的測試（bundle後，輸入 guard init repec 初始化，打guard（bundle exec guard 真正執行））</li>
<li>editor 有⽀援快速鍵</li>
<li>describe “#name” 是 instance method</li>
<li>describe “.name” 是 class method</li>
<li>測試spec盡量比較簡單清楚，可以不用DRY，實作才會要DRY</li>
</ul>


<h1>輸出格式</h1>

<ul>
<li>rspec filename.rb 預設不產⽣⽂件</li>
<li>rspec filename.rb -fd 輸出 specdoc ⽂件</li>
<li>rspec filename.rb -fh 輸出 html ⽂件</li>
</ul>


<h1>安裝</h1>

<pre><code class="ruby">group :development, :test do
  gem 'rspec-rails'
  gem 'factory_girl_rails'
end
</code></pre>

<h1>設定</h1>

<h3>顏色描述</h3>

<pre><code class="ruby">#vi .rspec檔案輸入
--color #顯示顏色
--format #documentation顯示描述
</code></pre>

<h3>將不需要的檔案關閉</h3>

<p>generate 新的 controller 或是 model 時，rails 就會很聰明的順便新增 sepc 檔案，但有時候我們會希望用到的時候再去建立即可，所以需要關閉就輸入以下指令。</p>

<p><code>/config/application.rb</code></p>

<pre><code class="ruby">config.generators do |g|
  g.view_specs false
  g.helper_specs false
  g.request_specs false
  g.controller_specs false
  g.routing_specs false
end
</code></pre>

<h1>Rspec</h1>

<h3>model</h3>

<pre><code class="ruby">require 'rails_helper' #必須載入才能使用裡面的方法

RSpec.describe Post, type: :model do #RSpec 可省略
    it "is accessible" do
        post = Post.create!
        expect(post).to eq(Post.last)
    end

    it "has title and content columns" do
        columns = Post.column_names
        expect(columns).to include("id")
    end
end
</code></pre>

<ul>
<li><code>describe</code>, <code>context</code> 描述要測試的是什麼，可以用nested</li>
<li><code>it</code>, <code>specify</code>, <code>example</code> 就是⼀⼩段測試</li>
<li><code>expect(…).to</code> 或 <code>expect(…).to_not</code> 定義期望</li>
<li><code>eq</code> 預期的是否和自己設定的相等</li>
<li><code>include</code> 預期的是否有包括自己設定的值</li>
<li><code>describe</code> 和 <code>it</code> 前面加上 x 代表 pending，執行 rspec 就會先跳拓</li>
<li><a href="https://www.relishapp.com/rspec/rspec-expectations/v/3-4/docs/built-in-matchers/change-matcher">其他方法</a></li>
</ul>


<h3>Routing spec syntax</h3>

<pre><code class="ruby">expect(:get =&gt; "/events").to route_to("events#index")
expect(:get =&gt; "/widgets/1/edit").not_to be_routable

expect(:get =&gt; "/posts/1").to route_to(
      :controller =&gt; "posts",
      :action =&gt; "show",
      :id =&gt; "1"
      )
</code></pre>

<h3>Controller spec syntax</h3>

<pre><code class="ruby">expect(response).to render_template(:new)
expect(response).to redirect_to(events_url)
expect(response).to have_http_status(200)
expect(assigns(:event)).to be_a_new(Event)
</code></pre>

<h3>View spec syntax</h3>

<pre><code class="ruby">render
expect(rendered).to include("Title")
expect(response).to render_template(partial: "_form")
</code></pre>

<h3>Helper spec syntax</h3>

<pre><code class="ruby">expect(helper.your_method).to eq("")
</code></pre>

<h3>request</h3>

<pre><code class="ruby">RSpec.describe "Users", :type =&gt; :request do
  before do
    @user = User.create(name: "hello")
  end

  it "GET /users" do
    get "/users"
    expect(response).to have_http_status(200)
    expect(response).to render_template(:index)
    expect(response.body).to include("hello")
  end

  it "GET /user/:id" do
    get "/user", id: @user.id
    expect(response).to have_http_status(200)
    expect(response).to render_template(:index)
    expect(response.body).to include("hello")
  end
</code></pre>

<p>request 通常直接從網址進行 Get 或 Post ，接著判斷傳回來的值是否正確。</p>

<pre><code class="ruby">before do  
    @user = User.new(name: "hello")
end

before(:all) do
    @user = User.new(name: "hello")
end

#也有 after(:each)，afte(:all)
</code></pre>

<ul>
<li>before(:each) 每段it之前執行</li>
<li>before(:all) 整段describe前只執行一次</li>
<li>after(:each) 每段it之後執行</li>
<li>after(:all) 整段describe後只執行一次</li>
<li>(:each) 可以不用加，預設為(:each)</li>
</ul>


<pre><code class="ruby">let(:user){User.new(:name =&gt; "hello")}
</code></pre>

<ul>
<li>相較於 before(:each) 可增加執⾏速度</li>
<li>有使⽤到才會運算(lazy)，並且在同⼀個 example 測試中多次呼叫會 Memoized 快取起來。</li>
<li>let! 則是⾮ lazy 版本</li>
</ul>


<h1>factory_girl</h1>

<p>到 <code>spec/rails_helper.rb</code> 設定</p>

<pre><code class="ruby">RSpec.configure do |config|
  config.include FactoryGirl::Syntax::Methods
end
</code></pre>

<p>在 <code>spec</code> 底下新增 <code>factories</code> 資料夾，接著在裡面新增相對應的物件名稱，像是 <code>user.rb</code></p>

<p><code>spec/factories/user.rb</code></p>

<pre><code class="ruby">FactoryGirl.define do
  factory :user, class: User" do
    name "video1"
    age  18

    trait :child do
      age 6
      #after(:create) {|user| user.add_role(:admin) } 
      #after(:build)  {|user| user.add_role(:admin) } 
      #也可以設定 create 之後的設定
    end
  end
end
</code></pre>

<p>這樣在 spec 裡面就可以直接建立假資料</p>

<pre><code class="ruby">before do  
    @user  = FactoryGirl.create(:user) #FactoryGirl 可省略
    @child = create(:user, :child) #就只替換掉 age
end
</code></pre>

<h3>為什麼要假物件?</h3>

<ul>
<li>無法控制回傳值的外部系統 (例如第三⽅ web service)</li>
<li>建構正確的回傳值很⿇煩 (例如得準備很多假資料)</li>
<li>可能很慢，拖慢測試速度 (例如耗時的運算)</li>
<li>有難以預測的回傳值 (例如亂數⽅法)</li>
<li>還沒開始實作 (特別是採⽤ TDD 流程)</li>
</ul>


<h1>Capybara</h1>

<p>RSpec除了可以拿來寫單元程式，我們也可以把測試的層級拉高做整合性測試，以Web應用程式來說，就是去自動化瀏覽器的操作，實際去向網站伺服器請求，然後驗證出來的HTML是正確的輸出。</p>

<p><a href="https://github.com/jnicklas/capybara">capybara</a>就是一套可以搭配的工具，用來模擬瀏覽器行為</p>

<h1>CI server</h1>

<p>CI(Continuous Integration)
伺服器的用處是每次有人Commit就會自動執行編譯及測試(Ruby不用編譯，所以主要的用處是跑測試)，並回報結果，如果有人送交的程式搞砸了回歸測試，馬上就有回饋可以知道。</p>

<p><a href="https://circleci.com">circleci.com</a></p>

<p>建立 <code>circle.yml</code></p>

<pre><code class="ruby">machine:
  timezone:
    Asia/Taipei
  ruby:
    version: 2.1.2
dependencies:
  pre:
    - rvm use 2.1.2
    - gem install bundler
    - gem install rubocop
  post:
    - gem update rake
database:
  override:
    - cp config/database.yml.example config/database.yml
    - rake db:create db:migrate --trace
test:
  override:
    - bundle exec rspec --color
</code></pre>

<p>建立 <code>config/database.yml.example</code></p>

<pre><code class="ruby">default: &amp;default
  adapter: mysql2
  encoding: utf8
  host: localhost
  username:
  password:

test:
  &lt;&lt;: *default
  database: test_db

development:
  &lt;&lt;: *default
  database: development_db

production:
  &lt;&lt;: *default
  database: production_db
</code></pre>

<p>接著到 <a href="https://circleci.com">circleci.com</a> 和 github 帳號做連結。<br/>
接著將要跑的 project 加進去，之後只要 push 到 github 就會自動跑了！</p>

<h1>大師引言</h1>

<pre><code>大部份都是寫model的測試
controller偶爾會寫

其他的因為後面有驗收測試也會測試到，所以不浪費時間去寫測試
驗收測試多半是測試子路徑，不會測到所有的條件，所以個別的小項測試，就直接在model寫就好了

工程是寫到request就很棒了
feature 比較像是QA在寫的
</code></pre>

<p>官方文件：<br/>
<a href="http://betterspecs.org/">Better Specs</a><br/>
<a href="https://www.relishapp.com/">Relish</a></p>

<p>Gem：<br/>
<a href="https://github.com/rspec/rspec-rails">rspec-rails</a><br/>
<a href="https://github.com/thoughtbot/factory_girl_rails">factory_girl_rails</a>  <br/>
<a href="https://github.com/guard/guard-rspec">guard-rspec</a><br/>
<a href="https://github.com/jnicklas/capybara">capybara</a></p>

<p>參考文件：<br/>
<a href="https://ihower.tw/rails4/testing.html">自動化測試</a><br/>
<a href="http://motion-express.com/trainings/rspec-rails-1">RSpec-Rails (基礎篇)</a><br/>
<a href="http://motion-express.com/blog/20150320-custom-helpers-in-rspec">RSpec-Rails當中自訂methods及helpers</a><br/>
<a href="http://motion-express.com/blog/20150327-rspec-rails-testing-module">RSpec-Rails 針對module進行unit test</a><br/>
<a href="http://www.slideshare.net/ihower/rspec-7394497">RSpec 讓你愛上寫測試</a><br/>
<a href="https://blog.alphacamp.co/2015/03/02/tdd-kata/">程式設計師升級必練內功：TDD Kata</a><br/>
<a href="https://codility.com/programmers/lessons/">codility 練習</a><br/>
<a href="http://www.sportcalculators.com/bowling-score-calculator">保齡球練習</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[用 Carrierwave + FFMPEG 影片轉檔]]></title>
    <link href="http://mgleon08.github.com/blog/2016/01/29/carrierwavea-plus-ffmpeg/"/>
    <updated>2016-01-29T20:26:02+08:00</updated>
    <id>http://mgleon08.github.com/blog/2016/01/29/carrierwavea-plus-ffmpeg</id>
    <content type="html"><![CDATA[<p>若是上傳的檔案是影片，並且要對影片做其他處理，就可以使用 FFMPRG 來處理。</p>

<!-- more -->


<p></p>

<h1>Gem</h1>

<pre><code class="ruby">gem 'carrierwave'
gem 'streamio-ffmpeg'
</code></pre>

<h1>設定</h1>

<p><code>application.rb</code></p>

<pre><code class="ruby">require 'carrierwave'
</code></pre>

<p><code>lib/carrierwave/ffmpeg.rb</code></p>

<pre><code class="ruby">require 'streamio-ffmpeg'
module CarrierWave
  module FFMPEG
    module ClassMethods
      def resample(bitrate)
        process :resample =&gt; bitrate
      end
    end

    def resample(bitrate)
      directory = File.dirname(current_path)
      tmpfile = File.join(directory, "tmpfile")

      FileUtils.mv( current_path, tmpfile )

      file = ::FFMPEG::Movie.new(tmpfile)
      file.transcode(current_path, video_bitrate: bitrate)

      File.delete(tmpfile)
    end
  end
end
</code></pre>

<p><code>app/uploaders/video_uploader.rb</code></p>

<pre><code class="ruby">require File.join(Rails.root, "lib", "carrierwave", "ffmpeg")

class VideoUploader &lt; CarrierWave::Uploader::Base
  include CarrierWave::FFMPEG

  def store_dir
    "uploads/#{model.class.to_s.underscore}/#{mounted_as}/#{model.id}"
  end

  def extension_white_list
    %w(mp4 flv)
  end

  version :bitrate_800k do
    process :resample =&gt; "800k"
  end

  version :bitrate_500k, from_version: :bitrate_800k do
    process :resample =&gt; "500k"
  end

end
</code></pre>

<p>也可以用 ruby 直接下 ffmpef 的指令</p>

<p>Use %x or &lsquo;`&rsquo;:</p>

<pre><code class="ruby">`ffmpeg -y -i #{input_path} -vf "scale=ceil(oh*a):480" -vcodec libx264 -preset:v slow -pix_fmt yuv420p -profile:v baseline -level 3.0 -b #{bitrate} -r 29.97 -acodec libvo_aacenc -ac 2 -ar 44100 -ab 64k -movflags faststart #{output_path}`
%x(ffmpeg -y -i #{input_path} -vf "scale=ceil(oh*a):480" -vcodec libx264 -preset:v slow -pix_fmt yuv420p -profile:v baseline -level 3.0 -b #{bitrate} -r 29.97 -acodec libvo_aacenc -ac 2 -ar 44100 -ab 64k -movflags faststart #{output_path})
</code></pre>

<p>官方文件：<br/>
<a href="https://github.com/carrierwaveuploader/carrierwave">carrierwave</a><br/>
<a href="https://github.com/streamio/streamio-ffmpeg">streamio-ffmpeg</a><br/>
<a href="https://www.ffmpeg.org/">FFMPEG</a></p>

<p>參考文件：<br/>
<a href="http://www.freezzo.com/2010/12/23/create-ffmpeg-processor-for-carrierwave-in-rails-3/">Create FFMPEG processor for Carrierwave in Rails 3</a><br/>
<a href="https://prograils.com/posts/carrierwave-basic-video-conversion">CarrierWave - basic video conversion</a><br/>
<a href="http://stackoverflow.com/questions/3159945/running-command-line-commands-within-ruby-script">Running command line commands within Ruby script</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[用 Rubocop 寫出好風格]]></title>
    <link href="http://mgleon08.github.com/blog/2016/01/22/rubocop/"/>
    <updated>2016-01-22T22:39:47+08:00</updated>
    <id>http://mgleon08.github.com/blog/2016/01/22/rubocop</id>
    <content type="html"><![CDATA[<p>rubocop 像是一個程式評量工具，會告知在 rails 中的寫法，要如何才會比較好!</p>

<!-- more -->


<pre><code class="ruby">gem install rubocop
</code></pre>

<p>指令</p>

<pre><code class="ruby">rubocop app spec lib/something.rb
</code></pre>

<p><a href="https://github.com/bbatsov/rubocop">rubocop</a></p>

<p>參考文件：
<a href="https://blog.alphacamp.co/2015/12/24/how-to-use-rubocop-in-rails-project/">如何在Rails專案中使用Rubocop統一程式風格？</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[用 Carrierwave 輕鬆做上傳檔案功能]]></title>
    <link href="http://mgleon08.github.com/blog/2016/01/22/carrierwave/"/>
    <updated>2016-01-22T22:12:46+08:00</updated>
    <id>http://mgleon08.github.com/blog/2016/01/22/carrierwave</id>
    <content type="html"><![CDATA[<p>另一個上傳檔案的 gem ，相當的實用，和 Paperclip 擇一即可。</p>

<!-- more -->


<h1>安裝</h1>

<p>Gemfile</p>

<pre><code class="ruby">gem 'carrierwave'
gem 'rmagick'

# or gem "mini_magick"
</code></pre>

<ul>
<li>carrierwave 上傳檔案</li>
<li>rmagick 處理圖片</li>
</ul>


<blockquote><p>必須有安裝 ImageMagick 才能使用 rmagick</p></blockquote>

<p>有 homebrew 可以直接</p>

<pre><code class="ruby">brew install imagemagick
</code></pre>

<h1>設定</h1>

<p>先建立資料夾，主要用來存放所有的檔案</p>

<pre><code class="ruby">rails generate uploader file
</code></pre>

<p>接著在在要存放的 model 新增一筆欄位</p>

<pre><code class="ruby">rails generate migration add_file_to_products
</code></pre>

<h1>Model</h1>

<pre><code class="ruby">class Product &lt; ActiveRecord::Base
  mount_uploader :file, FileUploader
end
</code></pre>

<p>最後記得再 strong params 加入</p>

<pre><code class="ruby">private
  def product_params
    params.require(:product).permit(:file)
  end
end
</code></pre>

<h1>Form</h1>

<pre><code class="ruby">&lt;%= form_for @product do |f| %&gt;
  &lt;%= f.file_field :file %&gt;
  &lt;%= f.submit "Submit" %&gt;
&lt;% end %&gt;
</code></pre>

<h1>view</h1>

<pre><code class="ruby">&lt;%= image_tag @product.image_url.to_s %&gt;
</code></pre>

<p>imageurl是預設的helper，to_s是要確定把上傳的路徑轉變為字串，以免發生錯誤。</p>

<h1>RMagick</h1>

<p><code>app/uploaders/file_uploader.rb</code></p>

<p>可以將設定打開，有 RMagick 和 MiniMagick ，都是用來縮圖的。(擇一即可)</p>

<pre><code class="ruby"># Include RMagick or MiniMagick support:
# include CarrierWave::RMagick
# include CarrierWave::MiniMagick
</code></pre>

<p>下面把註解拿掉就可以使用</p>

<pre><code class="ruby">Create different versions of your uploaded files:
version :thumb do
  process :resize_to_fit =&gt; [50, 50]
end
</code></pre>

<p>之後再 view 中只要指定，就會去抓取縮小後的圖檔</p>

<pre><code class="ruby">&lt;%= image_tag @product.image_url(:thumb).to_s %&gt;
</code></pre>

<h1>其他</h1>

<p>限制存取大小<br/>
<a href="https://github.com/carrierwaveuploader/carrierwave/wiki/How-to:-Validate-attachment-file-size">How to: Validate attachment file size</a></p>

<p>存取圖片長寬<br/>
<a href="https://github.com/carrierwaveuploader/carrierwave/wiki/How-to:-Get-image-dimensions">How to: Get image dimensions</a></p>

<p>存取圖片大小和類型<br/>
<a href="https://github.com/carrierwaveuploader/carrierwave/wiki/How-to:-Store-the-uploaded-file-size-and-content-type">How to: Store the uploaded file size and content type</a></p>

<p>官方文件：<br/>
<a href="https://github.com/carrierwaveuploader/carrierwave">carrierwave</a></p>

<p>參考資料：<br/>
<a href="http://motion-express.com/blog/20140708-ruby-gem-carrierwave">Ruby gem &lsquo;Carrierwave&rsquo; 上傳檔案神器的簡易安裝與使用</a><br/>
<a href="http://rubyist.marsz.tw/blog/2012-01-10/carrierwave-guides-with-amazon-s3-and-imagemagick-integration/">使用 Carrierwave 處理檔案上傳 (整合 imagemagick 與 Amazon S3)</a> <br/>
<a href="https://ruby-china.org/topics/4992">gem &lsquo;carrierwave'简易实用介绍</a><br/>
<a href="http://springok-blog.logdown.com/posts/2015/10/21/railsgem-how-to-use-carrierwave-upload-pictures">Rails如何使用Carrierwave上傳圖片</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[用 Paperclip 輕鬆做上傳檔案功能]]></title>
    <link href="http://mgleon08.github.com/blog/2016/01/22/paperclip/"/>
    <updated>2016-01-22T22:12:20+08:00</updated>
    <id>http://mgleon08.github.com/blog/2016/01/22/paperclip</id>
    <content type="html"><![CDATA[<p>在網站中經常會需要用到上傳檔案功能
而 Paperclip 就是可以在上傳檔案這件事變得更加便利。</p>

<!-- more -->


<h1>安裝</h1>

<pre><code class="ruby">gem "paperclip"
</code></pre>

<h1>設定</h1>

<pre><code class="ruby">class AddAvatarColumnsToUsers &lt; ActiveRecord::Migration
  def up
    add_attachment :topics, :picture
  end

  def down
    remove_attachment :topics, :picture
  end
end
</code></pre>

<p>attachment 會自動產生以下四個攔位</p>

<pre><code class="ruby">t.string   "picture_file_name",    limit: 255
t.string   "picture_content_type", limit: 255
t.integer  "picture_file_size",    limit: 4
t.datetime "picture_updated_at"
</code></pre>

<h1>Model</h1>

<pre><code class="ruby">class User &lt; ActiveRecord::Base
  has_attached_file :picture, styles: { medium: "300x300&gt;", thumb: "100x100&gt;" }, default_url: "/images/:style/missing.png"
  validates_attachment_content_type :picture, content_type: /\Aimage\/.*\Z/
end
</code></pre>

<h1>Form</h1>

<pre><code class="ruby">&lt;%= form_for @user, url: users_path, html: { multipart: true } do |form| %&gt;
  &lt;%= form.file_field :picture %&gt;
  &lt;%=%&gt;

&lt;% if @user.picture.exist?%&gt;
    &lt;%= check_box_tag “remove” ,”1”%&gt; #刪除按鈕
&lt;%end%&gt;
&lt;% end %&gt;
</code></pre>

<p>在編輯的時候設定如果remove=1就設定圖片欄位為nil就會刪除</p>

<h3>controller</h3>

<pre><code class="ruby">if params[:remove]==1
    @user.picture=nil
end
</code></pre>

<h1>View</h1>

<pre><code class="ruby">&lt;%= image_tag @topic.picture.url %&gt;
&lt;%= image_tag @topic.picture.url(:medium) %&gt;
&lt;%= image_tag @topic.picture.url(:thumb) %&gt;
</code></pre>

<h1>同時上傳多個檔案</h1>

<p>1-to-1 可以使用 <code>fields_for</code> 來達成，但若是 1-to-many ，則必須要搭配 JavaScript 協助動態增減欄位，動態加減數量。</p>

<p>可以使用以下 gem<br/>
<a href="https://github.com/ncri/nested_form_fields">nested_form_fields</a></p>

<p>(注意 Strong Parameter，這個 gem 的 README 沒提到)</p>

<h3>model</h3>

<pre><code class="ruby">has_many :banners, dependent: :destroy
accepts_nested_attributes_for :banners, allow_destroy: true, :reject_if =&gt; :all_blank
</code></pre>

<h3>strong params</h3>

<pre><code class="ruby">params.require(:company).permit(:banners_attributes =&gt; [:id, :banner, :banner_alt, :_destroy])
</code></pre>

<h3>form</h3>

<p>```ruby</p>

<p><div class="image">
  <p>Banner</p>
    &lt;%= c.nested_fields_for :banners do |b| %>
      <div class="form-group">
      &lt;%= b.file_field :banner%>
      &lt;%= b.label :banner_alt, &ldquo;banner_alt&rdquo; %><br>
      &lt;%= b.text_field :banner_alt, :class=>&ldquo;form-control&rdquo;%>
      &lt;%= b.remove_nested_fields_link &lsquo;Remove me&rsquo;%>
    &lt;% end %>
    &lt;%=c.add_nested_fields_link :banners, &lsquo;新增Banner&rsquo;, :class => &ldquo;btn btn-default&rdquo;%>
</div></p>

<p>```</p>

<p>或是  <a href="https://github.com/nathanvda/cocoon">cocoon</a></p>

<h3>可參考之前的</h3>

<p><a href="http://mgleon08.github.io/blog/2015/12/13/ruby-on-rails-accepts-nested-attributes-for/">Ruby on Rails - Accepts_nested_attributes_for</a></p>

<p>官方文件：<br/>
<a href="https://github.com/thoughtbot/paperclip">paperclip</a><br/>
<a href="https://github.com/ncri/nested_form_fields">nested_form_fields</a><br/>
<a href="https://github.com/nathanvda/cocoon">cocoon</a></p>

<p>參考文件：<br/>
<a href="http://chouandy.logdown.com/posts/249554-use-paperclip-implement-any-format-file-uploading">使用 paperclip 實作任意格式檔案上傳</a><br/>
<a href="http://chouandy.logdown.com/posts/252165-use-paperclip-implement-any-format-file-uploading-to-aws-s3">使用 paperclip 實作任意格式檔案上傳至 AWS S3</a><br/>
<a href="http://blog.jex.tw/blog/2015/07/13/rails-upload/">Rails 上傳 Upload</a><br/>
<a href="http://www.railscook.com/recipes/multiple-files-upload-with-nested-resource-using-paperclip-in-rails/">Multiple files upload with nested resource using Paperclip in Rails</a></p>
]]></content>
  </entry>
  
</feed>
