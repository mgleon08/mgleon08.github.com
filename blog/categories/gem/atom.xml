<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Gem | Leon's Blogging]]></title>
  <link href="http://mgleon08.github.com/blog/categories/gem/atom.xml" rel="self"/>
  <link href="http://mgleon08.github.com/"/>
  <updated>2016-01-08T10:05:38+08:00</updated>
  <id>http://mgleon08.github.com/</id>
  <author>
    <name><![CDATA[LeonJi]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[用 Backup 來備份資料庫]]></title>
    <link href="http://mgleon08.github.com/blog/2016/01/03/backup/"/>
    <updated>2016-01-03T21:42:46+08:00</updated>
    <id>http://mgleon08.github.com/blog/2016/01/03/backup</id>
    <content type="html"><![CDATA[<p>當網站上線之後，經常會提心吊膽的害怕網站資料不見。<br/>
這是很重要的動作就是 <code>備份</code> !</p>

<!-- more -->


<p>這次主要介紹用 <a href="http://backup.github.io/backup/v4/">backup</a>來做備份</p>

<p>先到遠端的 server 上面</p>

<p><code>gem install backup</code></p>

<p>將 backup 安裝起來</p>

<p>接著輸入</p>

<p><code>backup generate:model --trigger my_backup --archives --storages='s3' --compressor='gzip' --notifiers=‘mail'</code></p>

<p>之後會產生一個 <code>config.rb</code> 和一個 <code>my_backup.rb</code> 的檔案。</p>

<p>打開 <code>my_backup.rb</code> 設定</p>

<pre><code class="ruby">Model.new(:my_backup, '[describe]') do

  ##
  # MySQL [Database]
  #
  database MySQL do |db|
    # To dump all databases, set `db.name = :all` (or leave blank)
    db.name               = "[dbname]"
    db.username           = "root"
    db.password           = "xxxx"
    db.host               = "localhost"
    db.port               = 3306
    # db.socket             = "/tmp/mysql.sock"
    # Note: when using `skip_tables` with the `db.name = :all` option,
    # table names should be prefixed with a database name.
    # e.g. ["db_name.table_to_skip", ...]
    # db.skip_tables        = ["skip", "these", "tables"]
    # db.only_tables        = ["only", "these", "tables"]
    db.additional_options = ["--quick", "--single-transaction"]
  end

  ##
  # Amazon Simple Storage Service [Storage]
  #

 # 將備份檔案儲存到S3
 store_with S3 do |s3|
    # AWS Credentials
    s3.access_key_id     = "xxxx"
    s3.secret_access_key = "xxxx"
    # Or, to use a IAM Profile:
    # s3.use_iam_profile = true

    s3.region            = "ap-northeast-1"
    s3.bucket            = "[bucketname]"
    s3.path              = "[path]"
  end

  # 額外的檔案壓縮，例如用戶上傳的圖片，就可以指定路徑
  # archive.add “/home/deploy/xxxxxxx/shared/public/systems/
  # archive :my_archive do |archive|
    # Run the `tar` command using `sudo`
    # archive.use_sudo
    # archive.add "/srv"
  # end

  ##
  # Gzip [Compressor]
  #
  compress_with Gzip

  ##
  # Mail [Notifier]
  #
  # The default delivery method for Mail Notifiers is 'SMTP'.
  # See the documentation for other delivery options.
  # 寄信通知，也有很多其他的通知方法，官方文件都有
  notify_by Mail do |mail|
    mail.on_success           = true
    mail.on_warning           = true
    mail.on_failure           = true

    mail.from                 = "mail.from"
    mail.to                   = "mail.to"
    mail.address              = "smtp.mailgun.org"
    mail.port                 = 587
    mail.domain               = "mail.domain"
    mail.user_name            = "mail.user_name"
    mail.password             = "mail.password"

    mail.authentication       = "plain"
    mail.encryption           = :starttls
  end
end
</code></pre>

<p>接著打</p>

<p><code>backup perform --trigger my_backup</code></p>

<p>就可以做備份了</p>

<h1>排程</h1>

<p>每次都要手動去備份相當麻煩，因此接下來就是要設定固定時間跑指令來做備份拉。</p>

<p>這邊是用 <a href="https://github.com/javan/whenever">whenever</a> 來跑 crontab</p>

<p>先在 Gemfile. 加入</p>

<p><code>gem 'whenever', :require =&gt; false</code></p>

<p>接著打 <code>wheneverize .</code></p>

<p>就會產生檔案 <code>config/schedule.rb</code></p>

<p>打開檔案</p>

<pre><code class="ruby">env :PATH, ENV['PATH']
set :output, '/home/[username]/cron.log'

every 1.day, :at =&gt; '4:30 am' do
  command "/usr/local/bin/backup perform -t my_backup -c /home/[username]/Backup/config.rb"
end
</code></pre>

<blockquote><p>切記! 路徑要用絕對路徑啊啊啊!</p></blockquote>

<p>設定就完成囉!</p>

<p>如果有使用 capistrano 的話，可以在 Capfile 加入下面程式：</p>

<p><code>require "whenever/capistrano"</code></p>

<p>另外要看有沒有進排程可以打</p>

<p><code>crontab -e</code></p>

<p>另外 crontab 會分帳號的，所以要用原本的帳號打才會出現。</p>

<blockquote><p>如果只用 whenever 的 rake “XXX” 的話，crontab -e 裡面會先 cd 到專案目錄下，
這時候 log/cron.log 就沒問題</p>

<p>但是 whenever 的 command “XXXX” 並不會先 cd 到專案目錄下，因此 log/cron.log 會不知道跑去哪裡</p></blockquote>

<h1>匯入資料庫</h1>

<p>有了備份檔案，就能夠直接在本機端匯入檔案<br/>
匯入方式如下</p>

<p><code>mysql -u root -p db_name &lt; backup.sql</code></p>

<p>就會看到資料都匯入進去了，另外圖片都是存在 s3 ，如果希望圖片也顯示，就將 production 的圖片複製一份到 development 就可以了，因為兩邊設定的 bucket 是不一樣的。</p>

<p>官方文件：<br/>
<a href="http://backup.github.io/backup/v4/">backup</a><br/>
<a href="https://github.com/javan/whenever">whenever</a></p>

<p>參考文件：<br/>
<a href="http://blog.eddie.com.tw/2011/05/24/backup-your-website/">用Backup來備份你的網站</a><br/>
<a href="http://lemonup.logdown.com/posts/169422-rails-whenever-use-note">Whenever 使用筆記</a><br/>
<a href="http://programmer.shinchi.tw/2013/12/18/mysql%E5%8C%AF%E5%85%A5%E8%88%87%E5%8C%AF%E5%87%BA%E6%8C%87%E4%BB%A4/">mysql匯入與匯出指令</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ruby on Rails - Debugging]]></title>
    <link href="http://mgleon08.github.com/blog/2015/12/19/ruby-on-rails-debugging/"/>
    <updated>2015-12-19T11:09:06+08:00</updated>
    <id>http://mgleon08.github.com/blog/2015/12/19/ruby-on-rails-debugging</id>
    <content type="html"><![CDATA[<p>當發生 bug 的時候，要如何來有效率的debug!?<br/>
今天就來介紹幾種方式，快速的找出這些 <code>bug!!</code></p>

<!-- more -->


<h1>raise</h1>

<p>直接在覺得有問題的程式碼上面，插入 <code>raise</code><br/>
rails 就會在該行指令處產生 <a href="http://apidock.com/ruby/Kernel/raise">RuntimeError</a>，接著網頁就會進入錯誤畫面了<br/>
下面黑色區塊就可以輸入指令，看到底哪裡出問題!!</p>

<p>這是比較陽春的方式，但好處是</p>

<ol>
<li>不用特別安裝 gem</li>
<li>也不用去 console 中 debug ， 直接在瀏覽器上就可以執行</li>
</ol>


<p><img src="http://i.imgur.com/W0GTWCo.png" alt="raise" /></p>

<h1><a href="https://github.com/deivid-rodriguez/byebug">byebug</a></h1>

<p>開起新的專案時，就會內建在 development 和 test 環境的一個 gem</p>

<pre><code class="ruby">group :development, :test do
  # Call 'byebug' anywhere in the code to stop execution and get a debugger console
  gem 'byebug'
end
</code></pre>

<p>一樣是在覺得有問題的程式碼上面插入 <code>byebug</code><br/>
當跑到那個地方的時候就會停下來，接著就可以在 console 裡面輸入指令<br/>
測試完後就輸入 <code>continue</code> 繼續跑，或是 <code>exit</code> 離開。</p>

<p>但缺點是很吃效能，每次繼續跑就會變超慢，所以我都會直接整個重開XD</p>

<p><img src="http://i.imgur.com/dsaqKTB.png" alt="byebug" /></p>

<h1><a href="https://github.com/charliesome/better_errors">better_errors</a></h1>

<p>安裝方式</p>

<pre><code class="ruby">group :development, :test do
    gem 'better_errors' 
    gem 'binding_of_caller'
end
</code></pre>

<p>有點像是 raise 的進階版本，更多詳細的資訊<br/>
只要有例外，就會顯示這種畫面</p>

<p><img src="http://i.imgur.com/6BxsIH1.png" alt="better_errors" /></p>

<ol>
<li>左上 - 檢查檔案</li>
<li>右上 - 可以直接輸入指令來測試，像在 console 一樣</li>
<li>右下 - 檢查數值，request的互動中是否有參數漏掉?</li>
</ol>


<p>參考文章：<br/>
<a href="http://motion-express.com/blog/20141014-debugging-rails-better-errors/">Debugging Rails 使用 better_errors 在瀏覽器中直接進行除錯</a></p>

<h1><a href="https://github.com/pry/pry">pry</a></h1>

<p>安裝方式</p>

<pre><code class="ruby">gem 'pry'
gem 'pry-rails'
gem 'pry-nav'
</code></pre>

<p>超強的 debug 神器，一樣直接插入 <code>binding.pry</code><br/>
並且有顏色更加清楚，還可以像打指令 <code>cd @books.first</code> 進入某個變數裡面<br/>
接著就可以直接打 <code>name</code> <code>content</code>，顯示變數內容</p>

<p><img src="http://i.imgur.com/67g9JXM.png" alt="pry" /></p>

<p>指令：<br/>
<code>self</code> 檢查目前所在的 class 或 scope<br/>
<code>next</code> 執行這一段 block，並在下一段 block 開始時停止<br/>
<code>step</code> 執行這一行，並在下一行停止<br/>
<code>ls、methods</code> 可以看目前的 class 或 scope 內有什麼樣的 variable 或 method 可以使用<br/>
<code>continue</code> 繼續執行，如果有下一個 <code>binding.pry</code>就會停下來<br/>
<code>exit</code> 離開 pry ，繼續執行程式</p>

<blockquote><p>注意!!如果是用上一篇的 pow 來執行的話，要安裝 <a href="https://github.com/Mon-Ouie/pry-remote">pry-remote</a>，並且把原本的 <code>bindig.pry</code> 改成 <code>binding.remote_pry</code></p></blockquote>

<p>參考文章：<br/>
<a href="http://blog.xdite.net/posts/2012/08/13/pry-the-new-debugger">Pry ：新一代 Debug 利器</a><br/>
<a href="http://motion-express.com/blog/20141015-debugging-rails-pry">Debugging Rails 沒有錯誤訊息卻還是有bug！要如何即時除錯？</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ruby on Rails - 用 Pow 當 HTTP Server]]></title>
    <link href="http://mgleon08.github.com/blog/2015/12/18/ruby-on-rails-pow/"/>
    <updated>2015-12-18T17:39:04+08:00</updated>
    <id>http://mgleon08.github.com/blog/2015/12/18/ruby-on-rails-pow</id>
    <content type="html"><![CDATA[<p>當要啟動一個專案的時候，通常都是打 <code>rails s</code><br/>
就會跑在 port 3000 接著網址打 <code>http://localhost:3000/</code>，就可以打開了!</p>

<p>那要啟動另一個勒？ 通常有以下兩種方式</p>

<!-- more -->


<ol>
<li>先關掉第一個，再開啟另一個</li>
<li>換別的 port <code>rails s -p 4000</code></li>
</ol>


<p>但是萬一facebook登入，已經設定是 <code>http://localhost:3000/</code>，那就悲劇了..<br/>
因此有另一種方式來解決這種問題</p>

<h1><a href="http://pow.cx/">pow</a></h1>

<p>安裝方式也相當簡單，照著官方網站</p>

<p>先下載到電腦上</p>

<pre><code>curl get.pow.cx | sh
</code></pre>

<p>在指向到專案裡面</p>

<pre><code>cd ~/.pow
$ ln -s /path/to/myapp
</code></pre>

<p>接著在 <code>open http://myapp.dev</code><br/>
就會啟動了!</p>

<h1><a href="https://github.com/Rodreegez/powder">powder</a></h1>

<p>powder 是一個整合好 pow 的 gem ，可以更方便快速的啟動一個專案</p>

<h3>安裝方式</h3>

<pre><code>gem install powder
</code></pre>

<h3>使用方式</h3>

<p>在專案底下輸入</p>

<pre><code>powder link
</code></pre>

<p>就會建立起連結，接著輸入</p>

<pre><code>powder open
</code></pre>

<p>就打開了，超方便</p>

<p>另外一定會問到，那要怎麼看 <code>log</code></p>

<ol>
<li><code>tail -f log/development.log</code></li>
<li><code>powder applog</code></li>
</ol>


<p>重新啟動 (通常有動到 app 以外的檔案，就會需要重啟)</p>

<ol>
<li><code>touch tmp/restart.txt</code></li>
<li><code>powder restart</code></li>
</ol>


<p>更多指令可以到 github 上面看<br/>
<a href="https://github.com/Rodreegez/powder">powder</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ruby on Rails - 簡易搜尋功能]]></title>
    <link href="http://mgleon08.github.com/blog/2015/12/18/ruby-on-rails-basic-search/"/>
    <updated>2015-12-18T16:01:02+08:00</updated>
    <id>http://mgleon08.github.com/blog/2015/12/18/ruby-on-rails-basic-search</id>
    <content type="html"><![CDATA[<p>在架設網站得時候，不免常常需要用到搜尋功能（增加使用者體驗)<br/>
所以在這邊介紹一個簡易的搜尋功能</p>

<!-- more -->


<p>並不需要額外加 router，直接先在 view 裡面加上</p>

<pre><code class="ruby">&lt;%= form_tag books_path, :method =&gt; :get do %&gt;
    &lt;%= text_field_tag "keyword", nil, placeholder: '請輸入關鍵字...', :class=&gt;"form-control"%&gt;
    &lt;%= submit_tag "Search" %&gt;
&lt;% end %&gt;
</code></pre>

<p>之後在 controller 加上</p>

<pre><code class="ruby">if params[:keyword]
    @books = Book.where( [ "name like ? or content like", "%#{params[:keyword]}%", "%#{params[:keyword]}%"] )
end
</code></pre>

<p>用SQL的語法 <code>LIKE</code>，直接在資料庫裡面找尋相關的關鍵字，如果有多個欄位，再加上 <code>OR</code> 即可，其中 <code>name</code> 和 <code>content</code> 就是要搜尋的欄位。</p>

<p>記得前面後面要加上 <code>%</code> ，如果沒加上，就一定要完全跟輸入的關鍵字一樣。<br/>
加上去之後代表，前面後面都可以加上任意字組，就等於是說只有欄位裡有這個關鍵字就搜尋出來的意思。</p>

<p><code>% (百分比符號)：代表零個、一個、或數個字母。</code></p>

<p><a href="http://www.1keydata.com/tw/sql/sql-wildcard.html">SQL萬用字元</a></p>

<p>以上是比較簡易的方式來達成，相對的效能上可能也沒那麼好</p>

<h1>進階搜尋</h1>

<p>如果要更加複雜，效能更好或是全文搜尋的話<br/>
可以用 gem 來取代</p>

<ul>
<li><p><a href="https://github.com/activerecord-hackery/ransack">ransack</a><br/>
比較不考慮效能</p></li>
<li><p><a href="https://github.com/outoftime/sunspot">Solr</a><br/>
<a href="http://gogojimmy.net/2012/01/25/full-text-search-in-rails-with-solr/">在 Rails 中使用 Solr 做全文搜尋</a></p></li>
<li><p><a href="https://www.elastic.co/">Elasticsearch</a><br/>
<a href="https://github.com/elastic/elasticsearch-rails">elasticsearch-rails</a><br/>
<a href="https://github.com/ankane/searchkick">第三方gem: Searchkick</a></p></li>
</ul>


<p>不過目前都還沒用過啊..改天要用到再來研究一下:D</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ruby on Rails - 虛擬屬性Virtual Attribute]]></title>
    <link href="http://mgleon08.github.com/blog/2015/12/14/ruby-on-rails-virtual-attribute/"/>
    <updated>2015-12-14T13:13:37+08:00</updated>
    <id>http://mgleon08.github.com/blog/2015/12/14/ruby-on-rails-virtual-attribute</id>
    <content type="html"><![CDATA[<p>當要操作的屬性資料，和資料庫的欄位不相同的時候，就可以在 model 裡建立 Virtual Attribute 來取代。</p>

<h3>範例1 - full_name</h3>

<pre><code class="ruby">def full_name
    "#{self.first_name} #{self.last_name}"
end

def full_name=(value)
    self.first_name, self.last_name = value.to_s.split(" ", 2)
end
</code></pre>

<!-- more -->


<p>當資料庫欄位裡面有 <code>first_name</code> 和 <code>last_name</code> 分別去存取，但顯示的時候卻不可能只顯示一個，通常都一定是要連在一起</p>

<p>這時候就能夠用 Virtual Attribute 做出一個虛擬的屬性 <code>full_name</code> ， 而它的值則是 <code>first_name</code> 和 <code>last_name</code> 合在一起</p>

<p>這樣以後要取出名字，就只要用 <code>full_name</code> 即可，就不需要每次都在那邊相加。</p>

<h3>範例2 - tag_list</h3>

<pre><code class="ruby">def tag_list
  self.tags.map{ |t| t.name }.join(",")
end

def tag_list=(str)
  arr = str.split(",")

  self.tags = arr.map do |t|
    tag = CompanyTag.find_by_name(t)
    unless tag
      tag = CompanyTag.create!( :name =&gt; t )
    end
      tag  #沒有加這個的話，uless 最後一個回傳的會是 nil 就會爆錯
  end

end
</code></pre>

<p>取出時，先將所有 tag 透過 <code>map</code> 取出所有 name 變成一個 array，再用 <code>join</code> 轉成 string</p>

<p>存取時，先用 <code>split</code> 將 string 轉 array，用 name 去判斷每個元素是否已經存在資料庫，若是沒有，就 <code>create</code> 一個新的</p>

<blockquote><p>可以另外搭配 <a href="https://select2.github.io/">select2</a> 做出比較好看的 tag !!</p></blockquote>

<p>Rails gem
<a href="https://github.com/argerim/select2-rails">select2-rails</a></p>

<p>```ruby</p>

<script>
  $("#tag_list").select2({
    tags: <%=raw Tags.all.map{|t| t.name}%>,
    tokenSeparators: [',', ' ']
  });
</script>


<pre><code>

#最後來介紹一下attr_accessor

如果只要一般(沒有像上面還要取出來，單純只要讀取.存取)的虛擬屬性  
（就是資料庫並不需要這個欄位，但可能要透過這個虛擬屬性，組成某個陣列裡的元素）

則可以直接用 `attr_accessor` 直接產生以下的結果
</code></pre>

<p>class Girl
  def initialize(age)
    @age = age
  end
  # @age的getter方法
  def age<br/>
    @age<br/>
  end<br/>
  # @age的setter方法<br/>
  def age=(x)<br/>
    @age = x<br/>
  end
end
```</p>

<p><code>attr_accessor</code> 就是可以自動產生 getter 和 setter<br/>
<code>attr_reader</code> 產生 getter<br/>
<code>attr_writer</code> 產生 setter</p>

<p>網路上有一篇講的很清楚，可以去看看<br/>
<a href="http://blog.eddie.com.tw/2015/03/21/attr_accessor/">Ruby 語法放大鏡之「attr_accessor 是幹嘛的?」</a></p>

<h1>attr_accessible 和 attr_protected</h1>

<p>另外在網路上有發現兩個長個很相像的方法<br/>
仔細研究發現，這兩個主要好像都是為了防止 Mass assignment (大量賦值)</p>

<p><code>attr_accessible</code> 被設定的 attributes <code>以外</code> 不能夠被 Mass assignment<br/>
<code>attr_protected</code> 被設定的 attributes <code>自己</code> 不能夠被 Mass assignment</p>

<p>哈哈，一個是自己本身，一個是本身以外，蠻奇妙的。<br/>
原來這是在還沒有 Strong Parameter 這個功能時的防禦機制!!</p>

<p>詳情：</p>

<ul>
<li><a href="http://blog.xdite.net/posts/2012/03/05/github-hacked-rails-security/">從 Github 被 hack，談 Rails 的安全性（ mass-assignment ）</a></li>
<li><a href="http://blog.xdite.net/posts/2012/08/12/strong-parameter-mass-assignment-solution">Strong Parameter: Mass Assignment 機制的防彈衣</a></li>
</ul>


<p>官方文件：</p>

<ul>
<li><a href="http://apidock.com/rails/ActiveRecord/Base/attr_accessible/class">attr_accessible</a></li>
<li><a href="http://apidock.com/rails/ActiveRecord/Base/attr_protected/class">attr_protected</a></li>
<li><a href="http://stackoverflow.com/questions/2652907/what-is-the-difference-between-attr-accessibleattributes-attr-protectedat">stackoverflow</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
