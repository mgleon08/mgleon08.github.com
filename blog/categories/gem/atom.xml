<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Gem | Leon's Blogging]]></title>
  <link href="http://mgleon08.github.com/blog/categories/gem/atom.xml" rel="self"/>
  <link href="http://mgleon08.github.com/"/>
  <updated>2015-12-18T18:04:48+08:00</updated>
  <id>http://mgleon08.github.com/</id>
  <author>
    <name><![CDATA[LeonJi]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Ruby on Rails - 用 Pow 當 HTTP Server]]></title>
    <link href="http://mgleon08.github.com/blog/2015/12/18/ruby-on-rails-pow/"/>
    <updated>2015-12-18T17:39:04+08:00</updated>
    <id>http://mgleon08.github.com/blog/2015/12/18/ruby-on-rails-pow</id>
    <content type="html"><![CDATA[<p>當要啟動一個專案的時候，通常都是打 <code>rails s</code><br/>
就會跑在 port 3000 接著網址打 <code>http://localhost:3000/</code>，就可以打開了!</p>

<p>那要啟動另一個勒？</p>

<!-- more -->


<ol>
<li>先關掉第一個，再開啟另一個</li>
<li>另一個打 <code>rails s -p 4000</code> ，換別的 port</li>
</ol>


<p>但是萬一facebook登入，已經設定是 <code>http://localhost:3000/</code>，那就悲劇了..</p>

<p>因此有另一種方式來解決這種問題</p>

<h1><a href="http://pow.cx/">pow</a></h1>

<p>安裝方式也相當簡單，照著官方網站</p>

<p>先下載到電腦上</p>

<pre><code>curl get.pow.cx | sh
</code></pre>

<p>在指向到專案裡面</p>

<pre><code>cd ~/.pow
$ ln -s /path/to/myapp
</code></pre>

<p>接著在 <code>open http://myapp.dev</code><br/>
就會啟動了!</p>

<h1><a href="https://github.com/Rodreegez/powder">powder</a></h1>

<p>powder 是一個整合好 pow 的 gem ，可以更方便快速的啟動一個專案</p>

<h3>安裝方式</h3>

<pre><code>gem install powder
</code></pre>

<h3>使用方式</h3>

<p>在專案底下輸入</p>

<pre><code>powder link
</code></pre>

<p>就會建立起連結，接著輸入</p>

<pre><code>powder open
</code></pre>

<p>就打開了，超方便</p>

<p>另外一定會問到，那要怎麼看 <code>Log</code></p>

<ol>
<li><code>tail -f log/development.log</code></li>
<li><code>powder applog</code></li>
</ol>


<p>重新啟動</p>

<ol>
<li><code>touch tmp/restart.txt</code></li>
<li><code>powder restart</code></li>
</ol>


<p>更多指令可以到 github 上面看<br/>
<a href="https://github.com/Rodreegez/powder">powder</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ruby on Rails - 簡易搜尋功能]]></title>
    <link href="http://mgleon08.github.com/blog/2015/12/18/ruby-on-rails-basic-search/"/>
    <updated>2015-12-18T16:01:02+08:00</updated>
    <id>http://mgleon08.github.com/blog/2015/12/18/ruby-on-rails-basic-search</id>
    <content type="html"><![CDATA[<p>在架設網站得時候，不免常常需要用到搜尋功能（增加使用者體驗)<br/>
所以在這邊介紹一個簡易的搜尋功能</p>

<!-- more -->


<p>並不需要額外加 router，直接先在 view 裡面加上</p>

<pre><code class="ruby">&lt;%= form_tag books_path, :method =&gt; :get do %&gt;
    &lt;%= text_field_tag "keyword", nil, placeholder: '請輸入關鍵字...', :class=&gt;"form-control"%&gt;
    &lt;%= submit_tag "Search" %&gt;
&lt;% end %&gt;
</code></pre>

<p>之後在 controller 加上</p>

<pre><code class="ruby">if params[:keyword]
    @books = Book.where( [ "name like ? or content like", "%#{params[:keyword]}%", "%#{params[:keyword]}%"] )
end
</code></pre>

<p>用SQL的語法 <code>LIKE</code>，直接在資料庫裡面找尋相關的關鍵字，如果有多個欄位，再加上 <code>OR</code> 即可，其中 <code>name</code> 和 <code>content</code> 就是要搜尋的欄位。</p>

<p>記得前面後面要加上 <code>%</code> ，如果沒加上，就一定要完全跟輸入的關鍵字一樣。<br/>
加上去之後代表，前面後面都可以加上任意字組，就等於是說只有欄位裡有這個關鍵字就搜尋出來的意思。</p>

<p><code>% (百分比符號)：代表零個、一個、或數個字母。</code></p>

<p><a href="http://www.1keydata.com/tw/sql/sql-wildcard.html">SQL萬用字元</a></p>

<p>以上是比較簡易的方式來達成</p>

<h1>進階搜尋</h1>

<p>如果要更加複雜或是全文搜尋的話<br/>
可以用 gem 來取代</p>

<ul>
<li><p><a href="https://github.com/activerecord-hackery/ransack">ransack</a><br/>
比較不考慮效能</p></li>
<li><p><a href="https://github.com/outoftime/sunspot">Solr</a><br/>
<a href="http://gogojimmy.net/2012/01/25/full-text-search-in-rails-with-solr/">在 Rails 中使用 Solr 做全文搜尋</a></p></li>
<li><p><a href="https://www.elastic.co/">Elasticsearch</a><br/>
<a href="https://github.com/elastic/elasticsearch-rails">elasticsearch-rails</a><br/>
<a href="https://github.com/ankane/searchkick">第三方gem: Searchkick</a></p></li>
</ul>


<p>不過目前都還沒用過啊..改天要用到再來研究一下:D</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ruby on Rails - 虛擬屬性Virtual Attribute]]></title>
    <link href="http://mgleon08.github.com/blog/2015/12/14/ruby-on-rails-virtual-attribute/"/>
    <updated>2015-12-14T13:13:37+08:00</updated>
    <id>http://mgleon08.github.com/blog/2015/12/14/ruby-on-rails-virtual-attribute</id>
    <content type="html"><![CDATA[<p>當要操作的屬性資料，和資料庫的欄位不相同的時候，就可以在 model 裡建立 Virtual Attribute 來取代。</p>

<h3>範例1 - full_name</h3>

<pre><code class="ruby">def full_name
    "#{self.first_name} #{self.last_name}"
end

def full_name=(value)
    self.first_name, self.last_name = value.to_s.split(" ", 2)
end
</code></pre>

<!-- more -->


<p>當資料庫欄位裡面有 <code>first_name</code> 和 <code>last_name</code> 分別去存取，但顯示的時候卻不可能只顯示一個，通常都一定是要連在一起</p>

<p>這時候就能夠用 Virtual Attribute 做出一個虛擬的屬性 <code>full_name</code> ， 而它的值則是 <code>first_name</code> 和 <code>last_name</code> 合在一起</p>

<p>這樣以後要取出名字，就只要用 <code>full_name</code> 即可，就不需要每次都在那邊相加。</p>

<h3>範例2 - tag_list</h3>

<pre><code class="ruby">def tag_list
  self.tags.map{ |t| t.name }.join(",")
end

def tag_list=(str)
  arr = str.split(",")

  self.tags = arr.map do |t|
    tag = CompanyTag.find_by_name(t)
    unless tag
      tag = CompanyTag.create!( :name =&gt; t )
    end
      tag  #沒有加這個的話，uless 最後一個回傳的會是 nil 就會爆錯
  end

end
</code></pre>

<p>取出時，先將所有 tag 透過 <code>map</code> 取出所有 name 變成一個 array，再用 <code>join</code> 轉成 string</p>

<p>存取時，先用 <code>split</code> 將 string 轉 array，用 name 去判斷每個元素是否已經存在資料庫，若是沒有，就 <code>create</code> 一個新的</p>

<blockquote><p>可以另外搭配 <a href="https://select2.github.io/">select2</a> 做出比較好看的 tag !!</p></blockquote>

<p>Rails gem
<a href="https://github.com/argerim/select2-rails">select2-rails</a></p>

<p>```ruby</p>

<script>
  $("#tag_list").select2({
    tags: <%=raw Tags.all.map{|t| t.name}%>,
    tokenSeparators: [',', ' ']
  });
</script>


<pre><code>

#最後來介紹一下attr_accessor

如果只要一般(沒有像上面還要取出來，單純只要讀取.存取)的虛擬屬性  
（就是資料庫並不需要這個欄位，但可能要透過這個虛擬屬性，組成某個陣列裡的元素）

則可以直接用 `attr_accessor` 直接產生以下的結果
</code></pre>

<p>class Girl
  def initialize(age)
    @age = age
  end
  # @age的getter方法
  def age<br/>
    @age<br/>
  end<br/>
  # @age的setter方法<br/>
  def age=(x)<br/>
    @age = x<br/>
  end
end
```</p>

<p><code>attr_accessor</code> 就是可以自動產生 getter 和 setter<br/>
<code>attr_reader</code> 產生 getter<br/>
<code>attr_writer</code> 產生 setter</p>

<p>網路上有一篇講的很清楚，可以去看看<br/>
<a href="http://blog.eddie.com.tw/2015/03/21/attr_accessor/">Ruby 語法放大鏡之「attr_accessor 是幹嘛的?」</a></p>

<h1>attr_accessible 和 attr_protected</h1>

<p>另外在網路上有發現兩個長個很相像的方法<br/>
仔細研究發現，這兩個主要好像都是為了防止 Mass assignment (大量賦值)</p>

<p><code>attr_accessible</code> 被設定的 attributes <code>以外</code> 不能夠被 Mass assignment<br/>
<code>attr_protected</code> 被設定的 attributes <code>自己</code> 不能夠被 Mass assignment</p>

<p>哈哈，一個是自己本身，一個是本身以外，蠻奇妙的。<br/>
但目前還不太知道什時候會用上..有用上再來補吧(笑)</p>

<p>官方文件：</p>

<ul>
<li><a href="http://apidock.com/rails/ActiveRecord/Base/attr_accessible/class">attr_accessible</a></li>
<li><a href="http://apidock.com/rails/ActiveRecord/Base/attr_protected/class">attr_protected</a></li>
<li><a href="http://stackoverflow.com/questions/2652907/what-is-the-difference-between-attr-accessibleattributes-attr-protectedat">stackoverflow</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ruby on Rails - Accepts_nested_attributes_for]]></title>
    <link href="http://mgleon08.github.com/blog/2015/12/13/ruby-on-rails-accepts-nested-attributes-for/"/>
    <updated>2015-12-13T18:35:13+08:00</updated>
    <id>http://mgleon08.github.com/blog/2015/12/13/ruby-on-rails-accepts-nested-attributes-for</id>
    <content type="html"><![CDATA[<p><code>accepts_nested_attributes_for</code> 是一個蠻常會用到的語法</p>

<p>簡單的來說，就是可以透過這個語法，在更新 data 的時候，同時更新其他 model 裡的 data<br/>
所以並不是每個 model 都必須要有 controller 才能夠做更新的動作</p>

<!-- more -->


<p>這裏有兩種情境</p>

<h1>One-to-one</h1>

<pre><code class="ruby">class Book &lt; ActiveRecord::Base
  has_one :author
  accepts_nested_attributes_for :author
end
</code></pre>

<pre><code class="ruby">params = { book: { name: 'Harry Potter', author_attributes: { name: 'J. K. Rowling' } } }

book = Book.create(params[:book])
book.author.name # =&gt; 'J. K. Rowling'
</code></pre>

<p>透過 params 更新 Book 的 name<br/>
同時透過 <code>author_attributes: { name: 'J. K. Rowling' }</code> 更新 Author 的 name</p>

<p>當然 update 同樣適用</p>

<pre><code class="ruby">params = { book: { author_attributes: { name: 'J. K. Rowling' } } }
book.update params[:book]
book.author.name # =&gt; 'J. K. Rowling'
</code></pre>

<p>另外值得注意的是</p>

<pre><code class="ruby">accepts_nested_attributes_for :author, :allow_destroy =&gt; true, :reject_if =&gt; :all_blank
</code></pre>

<p><code>:allow_destroy =&gt; true</code> 可以在表單增加一個 _destroy 核選塊來表示刪除<br/>
<code>:reject_if =&gt; :all_blank</code> 表示在什麼條件下就當作沒有要動作， all_blank 表示如果資料都是空的，就不執行</p>

<h1>One-to-many</h1>

<pre><code class="ruby">class Book &lt; ActiveRecord::Base
  has_many :pages
  accepts_nested_attributes_for :page
end
</code></pre>

<pre><code class="ruby">params = { book: { 
    name: 'Harry Potter', page_attributes: [
        { title: "Philosopher's Stone" }, 
        { title: "Chamber of Secrets" }
    ] 
}}

book = Book.create(params[:book])
book.pages.length # =&gt; 2
book.pages.first.title # =&gt; 'Philosopher's Stone'
book.pages.last.title # =&gt; 'Chamber of Secrets'
</code></pre>

<h1>通常會搭配 fields_for 來嵌入到同一個表單</h1>

<h3>One-to-one</h3>

<pre><code class="ruby">&lt;%= form_for @book do |b| %&gt;
  &lt;%= b.label :name %&gt;
  &lt;%= b.text_field : name %&gt;

  &lt;%= b.fields_for :author do |a| %&gt;
      &lt;%= a.label :name %&gt;
      &lt;%= a.text_field : name %&gt;

      &lt;% unless a.object.new_record? %&gt;
         &lt;%= a.label :_destroy, 'Remove:' %&gt;
        &lt;%= a.check_box :_destroy %&gt;
      &lt;% end %&gt;
  &lt;% end %&gt;

  &lt;%= b.submit %&gt;
&lt;% end %&gt;
</code></pre>

<p>這樣就能夠透過原本是 @book 的表單，裡面再放入 author 的欄位進行更新。</p>

<h3>One-to-many</h3>

<p>one-to-many 會比較麻煩，因為當新增的時候，並不知道要新增幾個，因此會動用到 jquery 的動態新增，就是可以在表單上面一直增加欄位。</p>

<p>不過幸好有 gem 可以解決了，以下有幾個 gem</p>

<ul>
<li><a href="https://github.com/ryanb/nested_form">nested_form</a> ( <a href="http://motion-express.com/blog/20140722-ruby-gem-nested-form">網路上教學</a></li>
<li><a href="https://github.com/nathanvda/cocoon">cocoon</a></li>
<li><a href="https://github.com/ncri/nested_form_fields">nested_form_fields</a></li>
</ul>


<h1>strong parameter</h1>

<p>最後記得要加 strong parameter<br/>
one-to-one 和 one-to-many 都要</p>

<pre><code class="ruby">def book_params
    params.require(:book)
        .permit(:name, pages_attributes:[:title, :_destroy, :id])
end
</code></pre>

<blockquote><p>每個 gem strong parameter 的方式都有點不太一樣，記得要看一下</p></blockquote>

<h1>helper</h1>

<p>book_helper.rb</p>

<pre><code class="ruby">def setup_author(book)
    book.build_author if book.author.blank? 
    #one-to-one 用 build_author ， one-to-many 可以用 authors.build or authors.new 
    book
end
</code></pre>

<p>如果一開始沒設定的話，在 book 表單上是看不到 author 的欄位，因為一開始還沒 build  <br/>
因此要給它一個判斷，如果是 nil 就先 build_author 給它</p>

<p>接著用 <code>setup_author(@book)</code> 來置換 form_for 中的 @book</p>

<pre><code class="ruby">&lt;%= form_for setup_author(@book), :url =&gt; books_path do |b| %&gt;

...

&lt;% end %&gt;
</code></pre>

<p>官方文件：<a href="http://api.rubyonrails.org/classes/ActiveRecord/NestedAttributes/ClassMethods.html">accepts_nested_attributes_for </a> <a href="http://apidock.com/rails/ActionView/Helpers/FormHelper/fields_for">fields_for</a></p>
]]></content>
  </entry>
  
</feed>
