<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Rspec | Leon's Blogging]]></title>
  <link href="http://mgleon08.github.com/blog/categories/rspec/atom.xml" rel="self"/>
  <link href="http://mgleon08.github.com/"/>
  <updated>2016-02-23T21:09:37+08:00</updated>
  <id>http://mgleon08.github.com/</id>
  <author>
    <name><![CDATA[LeonJi]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[如何測試上傳檔案 Rspec Upload File]]></title>
    <link href="http://mgleon08.github.com/blog/2016/02/01/rspec-upload-file/"/>
    <updated>2016-02-01T21:32:55+08:00</updated>
    <id>http://mgleon08.github.com/blog/2016/02/01/rspec-upload-file</id>
    <content type="html"><![CDATA[<p>rails 本身就有內建的 helper 可以很快的建造假的檔案，然後就可以測試上傳的功能了。</p>

<!-- more -->


<h1>建立資料夾</h1>

<p><code>spec/fixtures/files</code></p>

<p>在資料夾裡放入用來測試的檔案</p>

<h1>Rack::Test::UploadedFile.new</h1>

<p><code>Rack::Test::UploadedFile.new('path','mime-type')</code></p>

<pre><code class="ruby">Rack::Test::UploadedFile.new('test.jpg', "image/jpeg")
Rack::Test::UploadedFile.new(File.open(File.join(Rails.root, '/spec/fixtures/files/1.jpg')), "image/jpeg")
</code></pre>

<h1>fixture_file_upload</h1>

<p>上面的簡短版本 <code>fixture_file_upload('path','mime-type')</code></p>

<pre><code class="ruby">@file1 = fixture_file_upload('files/1.jpg', 'image/jpg')
@file2 = fixture_file_upload('files/2.pdf', 'application/pdf')
</code></pre>

<p>以上兩個擇一，這樣就可以在 <code>create</code> 將 <code>@file</code> 帶入到 params</p>

<p>官方文件：
<a href="http://www.rubydoc.info/github/brynary/rack-test/Rack/Test/UploadedFile">Class: Rack::Test::UploadedFile</a>
<a href="http://apidock.com/rails/ActionDispatch/TestProcess/fixture_file_upload">fixture_file_upload</a></p>

<p>參考文件：
<a href="http://stackoverflow.com/questions/1178587/how-do-i-test-a-file-upload-in-rails">How do I test a file upload in rails?</a>
<a href="https://ruby-china.org/topics/21057">[求助] 文件上传的测试代码怎么写</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[用 Rspec + Factory Girl 寫測試]]></title>
    <link href="http://mgleon08.github.com/blog/2016/01/29/rspec-plus-factory-girl/"/>
    <updated>2016-01-29T20:36:46+08:00</updated>
    <id>http://mgleon08.github.com/blog/2016/01/29/rspec-plus-factory-girl</id>
    <content type="html"><![CDATA[<p>程式寫久之後，就會發現測試的重要性!<br/>
因此來介紹 rails 中，比內建測試還好用的 rspec 搭配 factory_girl</p>

<!-- more -->


<h1>測試種類</h1>

<ul>
<li><p>單元測試(Unit test)<br/>
針對每個程式各個最小單位進行測試，像是在 controller 就單單只測試 controller 裡面的 action，而裡面產生的 model,method，都用假的方式來取代，已確保有錯誤時，可以很快知道是哪邊有問題 。</p></li>
<li><p>整合測試(Integration test)<br/>
主要是用來測試，每個 class 的互動，像是 controller 裡面會 call 到 model ，也會 call 到 view ，並測試回傳的值是否正確。</p></li>
</ul>


<h1>寫測試的好處</h1>

<ul>
<li>Instant Feedback 即時反饋（寫測試的時間 &lt; debug的時間）</li>
<li>回歸測試及重構 （重構時就不需要再重複的測試）</li>
<li>幫助設計API（TDD = 先測試，在實作）</li>
<li>一種程式文件（可以讓很快就知道之前api怎麼寫的）</li>
</ul>


<h1>慣例</h1>

<ul>
<li>⼀個 rb 檔案配⼀個同名的 _spec.rb 檔案</li>
<li>guard 等⼯具容易設定<br/>
<a href="https://github.com/guard/guard-rspec">guard-rspec</a> 程式⼀修改完存檔，⾃動跑對應的測試（bundle後，輸入 guard init repec 初始化，打guard（bundle exec guard 真正執行））</li>
<li>editor 有⽀援快速鍵</li>
<li>describe “#name” 是 instance method</li>
<li>describe “.name” 是 class method</li>
<li>測試spec盡量比較簡單清楚，可以不用DRY，實作才會要DRY</li>
</ul>


<h1>輸出格式</h1>

<ul>
<li>rspec filename.rb 預設不產⽣⽂件</li>
<li>rspec filename.rb -fd 輸出 specdoc ⽂件</li>
<li>rspec filename.rb -fh 輸出 html ⽂件</li>
</ul>


<h1>安裝</h1>

<pre><code class="ruby">group :development, :test do
  gem 'rspec-rails'
  gem 'factory_girl_rails'
end
</code></pre>

<h1>設定</h1>

<h3>顏色描述</h3>

<pre><code class="ruby">#vi .rspec檔案輸入
--color #顯示顏色
--format #documentation顯示描述
</code></pre>

<h3>將不需要的檔案關閉</h3>

<p>generate 新的 controller 或是 model 時，rails 就會很聰明的順便新增 sepc 檔案，但有時候我們會希望用到的時候再去建立即可，所以需要關閉就輸入以下指令。</p>

<p><code>/config/application.rb</code></p>

<pre><code class="ruby">config.generators do |g|
  g.view_specs false
  g.helper_specs false
  g.request_specs false
  g.controller_specs false
  g.routing_specs false
end
</code></pre>

<h1>Rspec</h1>

<h3>model</h3>

<pre><code class="ruby">require 'rails_helper' #必須載入才能使用裡面的方法

RSpec.describe Post, type: :model do #RSpec 可省略
    it "is accessible" do
        post = Post.create!
        expect(post).to eq(Post.last)
    end

    it "has title and content columns" do
        columns = Post.column_names
        expect(columns).to include("id")
    end
end
</code></pre>

<ul>
<li><code>describe</code>, <code>context</code> 描述要測試的是什麼，可以用nested</li>
<li><code>it</code>, <code>specify</code>, <code>example</code> 就是⼀⼩段測試</li>
<li><code>expect(…).to</code> 或 <code>expect(…).to_not</code> 定義期望</li>
<li><code>eq</code> 預期的是否和自己設定的相等</li>
<li><code>include</code> 預期的是否有包括自己設定的值</li>
<li><code>describe</code> 和 <code>it</code> 前面加上 x 代表 pending，執行 rspec 就會先跳拓</li>
<li><a href="https://www.relishapp.com/rspec/rspec-expectations/v/3-4/docs/built-in-matchers/change-matcher">其他方法</a></li>
</ul>


<h3>Routing spec syntax</h3>

<pre><code class="ruby">RSpec.describe "posts", :type =&gt; :routing do

  expect(:get =&gt; "/events").to route_to("events#index")
  expect(:get =&gt; "/widgets/1/edit").not_to be_routable

  expect(:get =&gt; "/posts/1").to route_to(
        :controller =&gt; "posts",
        :action =&gt; "show",
        :id =&gt; "1"
        )
end
</code></pre>

<h3>Controller spec syntax</h3>

<pre><code class="ruby">RSpec.describe PostsController, type: :controller do
  expect(response).to render_template(:new)
  expect(response).to redirect_to(events_url)
  expect(response).to have_http_status(200)
  expect(assigns(:event)).to be_a_new(Event)
end
</code></pre>

<h3>View spec syntax</h3>

<pre><code class="ruby">RSpec.describe "posts/index.html.erb", type: :view do
  render
  expect(rendered).to include("Title")
  expect(response).to render_template(partial: "_form")
end
</code></pre>

<h3>Helper spec syntax</h3>

<pre><code class="ruby">expect(helper.your_method).to eq("")
</code></pre>

<h3>model spec</h3>

<pre><code class="ruby">describe Material::Banner, type: :model do
end
</code></pre>

<h3>request</h3>

<pre><code class="ruby">RSpec.describe "Users", :type =&gt; :request do
  before do
    @user = User.create(name: "hello")
  end

  it "GET /users" do
    get "/users"
    expect(response).to have_http_status(200)
    expect(response).to render_template(:index)
    expect(response.body).to include("hello")
  end

  it "GET /user/:id" do
    get "/user", id: @user.id
    expect(response).to have_http_status(200)
    expect(response).to render_template(:index)
    expect(response.body).to include("hello")
  end
</code></pre>

<p>request 通常直接從網址進行 Get 或 Post ，接著判斷傳回來的值是否正確。</p>

<pre><code class="ruby">before do  
    @user = User.new(name: "hello")
end

before(:all) do
    @user = User.new(name: "hello")
end

#也有 after(:each)，afte(:all)
</code></pre>

<ul>
<li>before(:each) 每段it之前執行</li>
<li>before(:all) 整段describe前只執行一次</li>
<li>after(:each) 每段it之後執行</li>
<li>after(:all) 整段describe後只執行一次</li>
<li>(:each) 可以不用加，預設為(:each)</li>
</ul>


<pre><code class="ruby">let(:user){User.new(:name =&gt; "hello")}
</code></pre>

<ul>
<li>相較於 before(:each) 可增加執⾏速度</li>
<li>有使⽤到才會運算(lazy)，並且在同⼀個 example 測試中多次呼叫會 Memoized 快取起來。</li>
<li>let! 則是⾮ lazy 版本</li>
</ul>


<h3>Stub</h3>

<pre><code class="ruby">allow_any_instance_of(User).to receive(:follow).and_return(false)
</code></pre>

<p>用stub 假造 method，讓它忽略這個 method，或是指定回傳東西，可以避免在測試時，測試不必要的東西。</p>

<h3>focus</h3>

<p>當想要只跑指定的測試時，可以加上 focus</p>

<pre><code class="ruby">  it '#index',  focus:true do
    get :index, format: :json
    expect(response).to have_http_status 200
  end
</code></pre>

<pre><code class="ruby">rspec --tag focus
</code></pre>

<h1>factory_girl</h1>

<p>到 <code>spec/rails_helper.rb</code> 設定</p>

<pre><code class="ruby">RSpec.configure do |config|
  config.include FactoryGirl::Syntax::Methods
end
</code></pre>

<p>在 <code>spec</code> 底下新增 <code>factories</code> 資料夾，接著在裡面新增相對應的物件名稱，像是 <code>user.rb</code></p>

<p><code>spec/factories/user.rb</code></p>

<pre><code class="ruby">FactoryGirl.define do
  factory :user, class: User" do
    name "hello"
    age  18

    # 可以設定create 之後要做哪些動作
    after(:create) do |video|
      create(:photo, photo_id: photo.id)
      create(:photo, size: "500", photo_id: photo.id)
      create(:photo, size: "800", photo_id: photo.id)
    end

    # 也可以設定多種條件
    trait :child do
      age 6
      #after(:create) {|user| user.add_role(:admin) } 
      #after(:build)  {|user| user.add_role(:admin) } 
      # 也可以設定 create 之後的設定
    end
  end
end
</code></pre>

<p>這樣在 spec 裡面就可以直接建立假資料</p>

<pre><code class="ruby">before do  
    @user  = FactoryGirl.create(:user) #FactoryGirl 可省略
    @child = create(:user, :child) #就只替換掉 age
end
</code></pre>

<h3>注意</h3>

<p>factory_girl 產生出來的資料，不會透過 controller ，而是直接再 model 產生，因此會跑出 validation 的驗證。</p>

<p>若是希望能跑 controller action 裡的 method 則是要另外跑</p>

<pre><code class="ruby">trait :user_buy do
  after(:create) do |user|
    user.buy
  end
end
</code></pre>

<h3>為什麼要假物件?</h3>

<ul>
<li>無法控制回傳值的外部系統 (例如第三⽅ web service)</li>
<li>建構正確的回傳值很⿇煩 (例如得準備很多假資料)</li>
<li>可能很慢，拖慢測試速度 (例如耗時的運算)</li>
<li>有難以預測的回傳值 (例如亂數⽅法)</li>
<li>還沒開始實作 (特別是採⽤ TDD 流程)</li>
</ul>


<h1>Capybara</h1>

<p>RSpec除了可以拿來寫單元程式，我們也可以把測試的層級拉高做整合性測試，以Web應用程式來說，就是去自動化瀏覽器的操作，實際去向網站伺服器請求，然後驗證出來的HTML是正確的輸出。</p>

<p><a href="https://github.com/jnicklas/capybara">capybara</a>就是一套可以搭配的工具，用來模擬瀏覽器行為</p>

<h1>CI server</h1>

<p>CI(Continuous Integration)
伺服器的用處是每次有人Commit就會自動執行編譯及測試(Ruby不用編譯，所以主要的用處是跑測試)，並回報結果，如果有人送交的程式搞砸了回歸測試，馬上就有回饋可以知道。</p>

<p><a href="https://circleci.com">circleci.com</a></p>

<p>建立 <code>circle.yml</code></p>

<pre><code class="ruby">machine:
  timezone:
    Asia/Taipei
  ruby:
    version: 2.1.2
dependencies:
  pre:
    - rvm use 2.1.2
    - gem install bundler
    - gem install rubocop
  post:
    - gem update rake
database:
  override:
    - cp config/database.yml.example config/database.yml
    - rake db:create db:migrate --trace
test:
  override:
    - bundle exec rspec --color
</code></pre>

<p>建立 <code>config/database.yml.example</code></p>

<pre><code class="ruby">default: &amp;default
  adapter: mysql2
  encoding: utf8
  host: localhost
  username:
  password:

test:
  &lt;&lt;: *default
  database: test_db

development:
  &lt;&lt;: *default
  database: development_db

production:
  &lt;&lt;: *default
  database: production_db
</code></pre>

<p>接著到 <a href="https://circleci.com">circleci.com</a> 和 github 帳號做連結。<br/>
接著將要跑的 project 加進去，之後只要 push 到 github 就會自動跑了！</p>

<h1>大師引言</h1>

<pre><code>大部份都是寫model的測試
controller偶爾會寫

其他的因為後面有驗收測試也會測試到，所以不浪費時間去寫測試
驗收測試多半是測試子路徑，不會測到所有的條件，所以個別的小項測試，就直接在model寫就好了

工程是寫到request就很棒了
feature 比較像是QA在寫的
</code></pre>

<p>官方文件：<br/>
<a href="http://betterspecs.org/">Better Specs</a><br/>
<a href="https://www.relishapp.com/">Relish</a></p>

<p>Gem：<br/>
<a href="https://github.com/rspec/rspec-rails">rspec-rails</a><br/>
<a href="https://github.com/thoughtbot/factory_girl_rails">factory_girl_rails</a>  <br/>
<a href="https://github.com/guard/guard-rspec">guard-rspec</a><br/>
<a href="https://github.com/jnicklas/capybara">capybara</a></p>

<p>參考文件：<br/>
<a href="https://ihower.tw/rails4/testing.html">自動化測試</a><br/>
<a href="http://motion-express.com/trainings/rspec-rails-1">RSpec-Rails (基礎篇)</a><br/>
<a href="http://motion-express.com/blog/20150320-custom-helpers-in-rspec">RSpec-Rails當中自訂methods及helpers</a><br/>
<a href="http://motion-express.com/blog/20150327-rspec-rails-testing-module">RSpec-Rails 針對module進行unit test</a><br/>
<a href="http://www.slideshare.net/ihower/rspec-7394497">RSpec 讓你愛上寫測試</a><br/>
<a href="https://blog.alphacamp.co/2015/03/02/tdd-kata/">程式設計師升級必練內功：TDD Kata</a><br/>
<a href="https://codility.com/programmers/lessons/">codility 練習</a><br/>
<a href="http://www.sportcalculators.com/bowling-score-calculator">保齡球練習</a></p>
]]></content>
  </entry>
  
</feed>
