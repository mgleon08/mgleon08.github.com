<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Docker | Leon's Blogging]]></title>
  <link href="https://mgleon08.github.io/blog/categories/docker/atom.xml" rel="self"/>
  <link href="https://mgleon08.github.io/"/>
  <updated>2019-07-11T17:15:31+08:00</updated>
  <id>https://mgleon08.github.io/</id>
  <author>
    <name><![CDATA[LeonJi]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Rails + Puma + Nginx + MySQL With Docker]]></title>
    <link href="https://mgleon08.github.io/blog/2019/01/13/rails-puma-nginx-mysql-with-docker/"/>
    <updated>2019-01-13T23:57:34+08:00</updated>
    <id>https://mgleon08.github.io/blog/2019/01/13/rails-puma-nginx-mysql-with-docker</id>
    <content type="html"><![CDATA[<!-- more -->


<p>將 Rails + Puma,  Nginx,  MySQL 都拆開成各自的 container，並透過 docker-compose 將多個 container 串起來，各司其職，協同服務。</p>

<ul>
<li>Nginx 在最前面解析請求並處理靜態資源</li>
<li>Puma 位於 Nginx 於 Rails 程序之間，用於處理動態的請求；最後面還有一個數據存儲的 MySQL</li>
</ul>


<p>container 分配</p>

<ul>
<li>app - 用來啟動 Rails + Puma</li>
<li>web - 存放 nginx，負責解析各種外部請求，處理靜態的資源
(靜態資源就是運行 rake assets:precompile 生成在 public/assets 中的內容)</li>
<li>db - MySQL</li>
</ul>


<p>在現有的 rails project 加上 docker 所需的 file</p>

<pre><code class="ruby">rails_project
├── docker
│   └── app
│       └── Dockerfile
│   └── db
│       └── grant_user.sql
│   └── web
│       ├── Dockerfile
│       └── nginx.conf
├── docker-compose.yml
└── .env
</code></pre>

<h3>docker/app/Dockerfile</h3>

<p><code>--path vendor/bundle</code></p>

<p><a href="https://chengl.com/using-docker-for-rails-development/">Using Docker for Rails Development</a></p>

<blockquote><p>We want to install gems in ./vendor/bundle because the gems will persist in ./vendor/bundle regardless of the lifecyle of the container. When we update the Gemfile and do bundle install again, it will only install the newly added gems, not everything again.</p></blockquote>

<pre><code class="ruby"># Base image
FROM ruby:2.5.1

# Install plugin
RUN apt-get update -qq &amp;&amp; apt-get install -y build-essential vim

# Install mysql
RUN apt-get install -y default-libmysqlclient-dev

# Install nodejs
RUN curl -sL https://deb.nodesource.com/setup_11.x | bash - &amp;&amp;\
    apt-get install -y nodejs

# Clears out the local repository of retrieved package files
RUN apt-get -q clean

# Set an environment variable where the Rails app is installed to inside of Docker image
ENV APP_PATH /usr/src/app
RUN mkdir -p $APP_PATH

# Set working directory
WORKDIR $APP_PATH

# Setting env up
ENV RAILS_ENV production
ENV RACK_ENV production
# Setting local
ENV LC_ALL C.UTF-8
# Setting timezone
ENV TZ Asia/Taipei
RUN cp /usr/share/zoneinfo/$TZ /etc/localtime &amp;&amp; echo $TZ &gt; /etc/timezone

# COPY Gemfile &amp; Gemfil.lock
COPY Gemfile* $APP_PATH/

# Run bundle
RUN bundle install --jobs 20 --retry 5 --without development test --path vendor/bundle

# Adding project files
COPY . $APP_PATH/

# Build Frond-End
RUN RAILS_ENV=$RAILS_ENV bundle exec rake assets:precompile

EXPOSE 3000

CMD ["bundle", "exec", "puma", "-C", "config/puma.rb"]
</code></pre>

<h3>docker/web/Dockerfile</h3>

<pre><code class="ruby"># Base image
FROM nginx:1.15.8

# Install dependencies
RUN apt-get update -qq &amp;&amp; apt-get -y install apache2-utils vim

# Establish where Nginx should look for files
ENV RAILS_ROOT /usr/src/app
# Setting local
ENV LC_ALL C.UTF-8
# Setting timezone
ENV TZ Asia/Taipei
RUN cp /usr/share/zoneinfo/$TZ /etc/localtime &amp;&amp; echo $TZ &gt; /etc/timezone

# Set our working directory inside the image
WORKDIR $RAILS_ROOT

# create log directory
RUN mkdir log

# copy over static assets
COPY public public/

# Copy Nginx config template
COPY docker/web/nginx.conf /tmp/docker.nginx

# substitute variable references in the Nginx config template for real values from the environment
# put the final config in its place
RUN envsubst '$RAILS_ROOT' &lt; /tmp/docker.nginx &gt; /etc/nginx/conf.d/default.conf
EXPOSE 80

# Use the "exec" form of CMD so Nginx shuts down gracefully on SIGTERM (i.e. `docker stop`)
CMD [ "nginx", "-g", "daemon off;" ]
</code></pre>

<h3>docker/web/nginx.conf</h3>

<pre><code class="ruby"># define our application server

upstream rails_app {
  # The app service 3000 port that points to the docker-compose definition
   server app:3000;
}

server {
   listen 80;
   # define your domain or IP
   server_name localhost;

   # define the public application root
   root   $RAILS_ROOT/public;
   index  index.html;

   # define where Nginx should write its logs
   access_log $RAILS_ROOT/log/nginx.access.log;
   error_log $RAILS_ROOT/log/nginx.error.log;

   # deny requests for files that should never be accessed
   # ~ regular 區分大小寫, .env / .git
   location ~ /\. {
      deny all;
   }

   # ~* regular 不分大小寫, .rb / .log
   location ~* ^.+\.(rb|log)$ {
      deny all;
   }

   # serve static (compiled) assets directly if they exist (for rails production)
   location ~ ^/(assets|images|javascripts|stylesheets|swfs|system)/   {
      # $uri: localhost/404.html，則 $uri 為 `/404.html`
      # @rails: 後面定義的 location @rails
      # 如果 url 匹配進來，則先按 $uri 處理，若沒有找到，則交給 @rails 處理
      try_files $uri @rails;
      # close access log
      access_log off;
      # to serve pre-gzipped version
      # 設定為 `on` ，在處理壓縮之前，先查找已經預壓縮的文件（.gz）
      # 避免每次對同一個文件進行重複的壓縮處理
      gzip_static on;

      expires max;
      # public 對每個用戶有效; private 對當前用戶有效
      add_header Cache-Control public;

      add_header Last-Modified "";
      add_header ETag "";
      break;
   }

   # send non-static file requests to the app server
   location / {
      try_files $uri @rails;
   }

   location @rails {
      internal; # 只能被內部的請求呼叫，外部的呼叫請求會返回 'Not found'
      proxy_set_header  X-Real-IP  $remote_addr;
      proxy_set_header  X-Forwarded-For $proxy_add_x_forwarded_for;
      proxy_set_header Host $http_host;
      proxy_redirect off;
      proxy_pass http://rails_app; # 導向到 upstream rails_app
   }
}
</code></pre>

<h3>database.yml</h3>

<p><code>host name</code> 必須對應到 docker-compose 所定義的 <code>service name</code>，並且透過環境變數所設定的 user 來登入</p>

<pre><code class="ruby">default: &amp;default
  adapter: mysql2
  encoding: utf8
  pool: &lt;%= ENV.fetch("RAILS_MAX_THREADS") { 5 } %&gt;
  host: db
  port: 3306
  username: &lt;%= ENV.fetch('MYSQL_USER') { 'root' } %&gt;
  password: &lt;%= ENV.fetch('MYSQL_PASSWORD') { 'password' } %&gt;
  socket: /tmp/mysql.sock
</code></pre>

<h3>docker/db/grant_user.sql</h3>

<p>因為在 mysql 有另外建立一個 user，並且在 database.yml 也是透過這個 user 來登入，因此必須授權給此 user 權限，才能夠操作</p>

<pre><code class="ruby">GRANT ALL PRIVILEGES ON *.* TO 'user_name'@'%';
FLUSH PRIVILEGES;
</code></pre>

<h3>docker-compose.yml</h3>

<blockquote><p>.env 的變數，可以用 <code>${MYSQL_USER}</code> 使用在 docker-compose 中</p></blockquote>

<pre><code class="ruby">version: '3'
services:
  app:
    build:
      context: .
      dockerfile: ./docker/app/Dockerfile
    env_file:
      - .env
    volumes:
      - .:/usr/src/app
    depends_on:
      - db
  db:
    image: mysql:5.7.23
    command: --default-authentication-plugin=mysql_native_password
    restart: always
    env_file:
      - .env
    ports:
      - "3306:3306"
    volumes:
      - db-data:/var/lib/mysql
  web:
    build:
      context: .
      dockerfile: ./docker/web/Dockerfile
    ports:
      - 80:80
    depends_on:
      - app
volumes:
  db-data:
    external: false
</code></pre>

<h3>.env</h3>

<p>docker-compose 所需要用到的環境變數，app &amp; web 都會用到</p>

<pre><code class="ruby">MYSQL_ROOT_PASSWORD=password
MYSQL_USER=user_name
MYSQL_PASSWORD=user_password
</code></pre>

<h3>Example project</h3>

<p><a href="https://github.com/mgleon08/product_system_production">product_system_production</a></p>

<pre><code class="ruby">git clone https://github.com/mgleon08/product_system_production
# 建立 image
docker-compose build
# 啟動
docker-compose up -d
# 因為是建立新的 user 來造訪 mysql，因此必須先授權此 user 權限
p# 確認是否授權成功
docker-compose exec db mysql -u user_name -p -e"show grants;"
# 建立資料庫
docker-compose run --rm app bundle exec rails db:create
# 跑 migrate
docker-compose run --rm app bundle exec rails db:migrate
# 建立假資料
docker-compose run --rm app bundle exec rails db:seed
# 查看畫面, 記得是 http
http://localhost
</code></pre>

<h3>Production</h3>

<p>Rails5.2 之後，secret_key_base 的設定改了，在 production 上要在 config 裡面加上 master.key file，並將 local 的亂碼貼上去</p>

<ul>
<li><a href="https://mgleon08.github.io/blog/2018/07/14/rails-credentials/">Rails 5.2 Credentials</a></li>
<li><a href="https://keithpblog.org/post/encrypted-secrets/">Rails 5.2: encrypted secrets</a></li>
</ul>


<h1>最後另外附上 develop 的 docker</h1>

<pre><code class="ruby"># docker-compose
version: '3'
services:
  db:
    image: mysql:5.7.23
    command: --default-authentication-plugin=mysql_native_password
    restart: always
    environment:
      MYSQL_ROOT_PASSWORD: password
    ports:
      - "3306:3306"
    volumes:
      - ./opt/data:/var/lib/mysql
  backend:
    container_name: product_system
    build:
      context: .
      args:
        UID: ${UID:-1001}
    volumes:
      - .:/usr/src/app
    ports:
      - "3000:3000"
    depends_on:
      - db
    user: deploy
</code></pre>

<pre><code class="ruby"># Dockerfile
FROM ruby:2.5.1

RUN apt-get update -qq &amp;&amp;\
    curl -sL https://deb.nodesource.com/setup_11.x | bash - &amp;&amp;\
    apt-get install -y nodejs cmake &amp;&amp;\
    apt-get clean

ARG UID
RUN adduser deploy --uid $UID --disabled-password --gecos ""

ENV APP /usr/src/app
RUN mkdir $APP
WORKDIR $APP

COPY Gemfile* $APP/
RUN bundle install -j3 --path vendor/bundle

COPY . $APP/

CMD ["bundle", "exec", "rails", "server", "-p", "3000", "-b", "0.0.0.0"]
</code></pre>

<p>README</p>

<pre><code class="ruby"># build image
docker-compose build

# bundle
docker-compose run -u root backend bundle

# create database
docker-compose run backend bundle exec rails db:create db:migrate db:seed

# start
docker-compose up
</code></pre>

<p>New project need to add <code>db (docker-compose.yml mysql name)</code> to <code>database.yml</code></p>

<pre><code class="ruby">default: &amp;default
  adapter: mysql2
  encoding: utf8
  pool: &lt;%= ENV.fetch("RAILS_MAX_THREADS") { 5 } %&gt;
  host: db
  port: 3306
  username: root
  password: password
  socket: /tmp/mysql.sock
</code></pre>

<h1>Sample</h1>

<ul>
<li><a href="https://github.com/mgleon08/product_system_production">product_system_production</a></li>
<li><a href="https://github.com/mgleon08/product_system_develop">product_system_develop</a></li>
</ul>


<p>參考文件:</p>

<ul>
<li><a href="https://qiita.com/eighty8/items/0288ab9c127ddb683315#db%E6%8E%A5%E7%B6%9A%E7%94%A8%E3%81%AE%E6%83%85%E5%A0%B1%E3%83%95%E3%82%A1%E3%82%A4%E3%83%AB">Docker + Rails + Puma + Nginx + MySQL</a></li>
<li><a href="https://itnext.io/docker-rails-puma-nginx-postgres-999cd8866b18">Docker + Rails + Puma + Nginx + Postgres</a></li>
<li><a href="https://stackoverflow.com/questions/8821864/config-assets-compile-true-in-rails-production-why-not/8827757#8827757">config.assets.compile=true in Rails production, why not?</a></li>
<li><a href="http://chrisstump.online/2016/02/20/docker-existing-rails-application/">Docker for an Existing Rails Application</a></li>
<li><a href="https://stackoverflow.com/questions/5877929/what-does-upstream-mean-in-nginx">What does upstream mean in nginx?</a></li>
<li><a href="https://www.fooish.com/sql/grant-privileges.html">SQL GRANT 授與資料庫使用權限</a></li>
<li><a href="https://blog.hellojcc.tw/2015/12/07/nginx-beginner-tutorial/">nginx 基礎設定教學</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Install Docker & Docker Compose With Ubuntu]]></title>
    <link href="https://mgleon08.github.io/blog/2019/01/08/install-docker-and-docker-compose-with-ubuntu/"/>
    <updated>2019-01-08T20:51:40+08:00</updated>
    <id>https://mgleon08.github.io/blog/2019/01/08/install-docker-and-docker-compose-with-ubuntu</id>
    <content type="html"><![CDATA[<!-- more -->


<h1>Install Docker</h1>

<h3>Prerequsites</h3>

<p>Install packages to allow apt to use a repository over <a href="HTTPS:">HTTPS:</a></p>

<pre><code class="`ruby">sudo apt-get install apt-transport-https ca-certificates curl software-properties-common
</code></pre>

<h3>Setup Docker Repository</h3>

<p> Add Docker’s official GPG key:</p>

<pre><code class="`ruby">curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -
</code></pre>

<p>After that add the Docker repository on your Ubuntu system which contains Docker packages including its dependencies</p>

<pre><code class="`ruby"> sudo add-apt-repository "deb [arch=amd64] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable"
</code></pre>

<h3>Install Docker on Ubuntu</h3>

<p> Update the apt package index.</p>

<pre><code class="`ruby"> sudo apt-get update
</code></pre>

<p> Install the latest version of Docker CE, or go to the next step to install a specific version:</p>

<pre><code class="`ruby"> sudo apt-get install -y docker-ce
</code></pre>

<p> Verify that Docker CE is installed correctly by running the hello-world image.</p>

<pre><code class="`ruby"> sudo docker container run hello-world
</code></pre>

<h1>Install Docker Compose</h1>

<p>Run this command to download the latest version of Docker Compose</p>

<pre><code class="`ruby">sudo curl -L "https://github.com/docker/compose/releases/download/1.23.2/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
</code></pre>

<p>Apply executable permissions to the binary:</p>

<pre><code class="`ruby"> sudo chmod +x /usr/local/bin/docker-compose
</code></pre>

<h1>免 sudo 用 docker 指令</h1>

<p>因為使用的是 <code>sudo</code> 來安裝 docker，因此在普通用戶的狀況，使用 docker 的指令會導致</p>

<pre><code class="`ruby">docker ps -a

# Got permission denied while trying to connect to the Docker daemon socket at unix:///var/run/docker.sock: Get http://%2Fvar%2Frun%2Fdocker.sock/v1.39/containers/json?all=1: dial unix /var/run/docker.sock: connect: permission denied
</code></pre>

<p>可以看到最後一行 <code>var/run/docker.sock: connect: permission denied</code> 因此來看一下這個檔案的權限狀況</p>

<pre><code class="ruby">ls -al /var/run/
srw-rw----  1 root docker    0 Jan 20 14:59 docker.sock
</code></pre>

<p>可以看到</p>

<ul>
<li><code>user 權限</code>  rw-</li>
<li><code>group 權限</code> rw-</li>
<li><code>other 權限</code>: &mdash;</li>
<li><code>擁有人</code>: root</li>
<li><code>組別</code>&ldquo; docker</li>
</ul>


<p>所以希望有權限，要嗎是 <code>root</code> 或是在 <code>docker</code> 這個組別裡面，先查一下目前有沒有這個組別</p>

<p>entire group list</p>

<pre><code class="ruby">cut -d: -f1 /etc/group | sort
</code></pre>

<p>發現沒有 <code>docker</code> 這個組別，那就自己新增一個</p>

<pre><code class="ruby">sudo groupadd docker
</code></pre>

<p>將自己加入 docker group</p>

<pre><code class="ruby">sudo gpasswd -a ${USER} docker
# 或是 sudo usermod -G docker -a ${USER}
</code></pre>

<blockquote><p>usemod -G 改寫用戶的組之後 如果用戶同時屬於多個組 那麼最終只會屬於一個組
而 gpasswd -a 則是將一個用戶加入到另一個組 同時不改變用戶原來的組</p></blockquote>

<p>重啟 docker</p>

<pre><code class="ruby">sudo service docker restart
</code></pre>

<p>切換當前 group，或重開新的 session</p>

<pre><code class="ruby">newgrp - docker
</code></pre>

<p>接著就可以試著用普通用戶來執行，成功!</p>

<pre><code class="ruby">docker ps -a
</code></pre>

<p>參考文件:</p>

<ul>
<li><a href="https://docs.docker.com/install/linux/docker-ce/ubuntu/#install-docker-ce">InstallDocker CE</a></li>
<li><a href="https://tecadmin.net/install-docker-on-ubuntu/">How To Install Docker on Ubuntu 18.04 &amp; 16.04 LTS</a></li>
<li><a href="https://docs.docker.com/compose/install/">Compose Install</a></li>
<li><a href="https://www.jianshu.com/p/95e397570896">免sudo使用docker命令</a></li>
<li><a href="https://stackoverflow.com/questions/14059916/is-there-a-command-to-list-all-unix-group-names">Is there a command to list all Unix group names? [closed]</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Docker - Docker Machine, Docker Swarm]]></title>
    <link href="https://mgleon08.github.io/blog/2018/12/28/docker-swarm/"/>
    <updated>2018-12-28T23:14:00+08:00</updated>
    <id>https://mgleon08.github.io/blog/2018/12/28/docker-swarm</id>
    <content type="html"><![CDATA[<p>透過 docker machine 在 local 測試 docker swarm!
雖然目前是 k8s 比較紅，但還是先來玩玩看 swarm，之後再來研究 k8s (Kubernetes)</p>

<!-- more -->


<h2>Docker Machine</h2>

<p>Docker Machine 最主要的目的就是可以快速的把虛擬機和 Docker 環境架設起來。</p>

<p><img src="https://docs.docker.com/machine/img/machine.png" alt="" /></p>

<pre><code class="ruby"># 建立, --driver=virtualbox
docker-machine create -d virtualbox machine1

#啟動
docker-machine start machine1

# 停止
docker-machine stop machine1

# 重啟
docker-machine restart machine1

# 刪除
docker-machine rm machine1

# list
docker-machine ls

# ssh
docker-machine ssh machine1

#檢查訊息
docker-machine inspect

#查看狀態
docker-machine status machine1
</code></pre>

<h2>Docker Swarm</h2>

<p><img src="https://docs.docker.com/engine/swarm/images/ingress-routing-mesh.png" alt="" /></p>

<ul>
<li>運行 docker 的主機可初始化或加入 Swarm 集群，這樣主機就成為 Swarm 集群的節點 (node)。</li>
<li>節點分為管理 (manager 管理成員以及指派任務) 節點和工作 (worker 執行 swarm service) 節點。</li>
<li>可以有多個 manager 但只能有一個 leader</li>
<li>管理節點用於 Swarm 集群的管理，docker swarm 命令基本只能在管理節點執行（節點退出集群命令 docker swarm leave 可以在工作節點執行）。</li>
<li>一個 Swarm 集群可以有多個管理節點，但只有一個管理節點可以成為 leader。</li>
</ul>


<blockquote><p>由於 docker swarm 最主要是多台機器可以在同一個群集，但在 local 並沒有那個多台機器，因此可以透過 docker machine 的方式，建立多台 vm，來模擬多台機器的狀況</p></blockquote>

<p>一開始記得先安裝 <a href="https://www.virtualbox.org">virtualbox</a></p>

<p>執行</p>

<pre><code class="ruby">brew cask install virtualbox
</code></pre>

<p>建立用來當 manager 的機器，如果沒有 Boot2Docker 就會自動去安裝</p>

<pre><code class="ruby"># docker-machine create --driver virtualbox manager1
# 由於新版會有問題，所以改指定版本
docker-machine create --virtualbox-boot2docker-url https://github.com/boot2docker/boot2docker/releases/download/v18.06.1-ce/boot2docker.iso  --driver virtualbox manager1
</code></pre>

<ul>
<li><a href="https://github.com/docker/machine/issues/4608">18.09.0 iso breaks swarm ingress</a></li>
</ul>


<pre><code class="ruby">Running pre-create checks...
(manager1) Image cache directory does not exist, creating it at /Users/leon/.docker/machine/cache...
(manager1) No default Boot2Docker ISO found locally, downloading the latest release...
(manager1) Latest release for github.com/boot2docker/boot2docker is v18.09.0
(manager1) Downloading /Users/leon/.docker/machine/cache/boot2docker.iso from https://github.com/boot2docker/boot2docker/releases/download/v18.09.0/boot2docker.iso...
(manager1) 0%....10%....20%....30%....40%....50%....60%....70%....80%....90%....100%
Creating machine...
(manager1) Unable to get the local Boot2Docker ISO version:  Did not find prefix "-v" in version string
(manager1) Default Boot2Docker ISO is out-of-date, downloading the latest release...
(manager1) Latest release for github.com/boot2docker/boot2docker is v18.09.0
(manager1) Downloading /Users/leon/.docker/machine/cache/boot2docker.iso from https://github.com/boot2docker/boot2docker/releases/download/v18.09.0/boot2docker.iso...
(manager1) 0%....10%....20%....30%....40%....50%....60%....70%....80%....90%....100%
(manager1) Copying /Users/leon/.docker/machine/cache/boot2docker.iso to /Users/leon/.docker/machine/machines/manager1/boot2docker.iso...
(manager1) Creating VirtualBox VM...
(manager1) Creating SSH key...
(manager1) Starting the VM...
(manager1) Check network to re-create if needed...
(manager1) Found a new host-only adapter: "vboxnet0"
(manager1) Waiting for an IP...
Waiting for machine to be running, this may take a few minutes...
Detecting operating system of created instance...
Waiting for SSH to be available...
Detecting the provisioner...
Provisioning with boot2docker...
Copying certs to the local machine directory...
Copying certs to the remote machine...
Setting Docker configuration on the remote daemon...
Checking connection to Docker...
Docker is up and running!
To see how to connect your Docker Client to the Docker Engine running on this virtual machine, run: docker-machine env manager1
</code></pre>

<p>接著查看 ip</p>

<pre><code class="ruby">docker-machine env manager1
</code></pre>

<pre><code class="ruby">export DOCKER_TLS_VERIFY="1"
export DOCKER_HOST="tcp://192.168.99.100:2376"
export DOCKER_CERT_PATH="/Users/leon/.docker/machine/machines/manager1"
export DOCKER_MACHINE_NAME="manager1"
# Run this command to configure your shell:
# eval $(docker-machine env manager1)
</code></pre>

<p>再新增兩台機器中當作 worker</p>

<pre><code class="ruby">docker-machine create --virtualbox-boot2docker-url https://github.com/boot2docker/boot2docker/releases/download/v18.06.1-ce/boot2docker.iso  --driver virtualbox worker1
docker-machine create --virtualbox-boot2docker-url https://github.com/boot2docker/boot2docker/releases/download/v18.06.1-ce/boot2docker.iso  --driver virtualbox worker2
</code></pre>

<h3>接著建立 docker swarm 集群</h3>

<p><img src="https://docs.docker.com/engine/swarm/images/swarm-diagram.png" alt="" /></p>

<p>進入 manager</p>

<pre><code class="ruby">docker-machine ssh manager1
</code></pre>

<p>將 manager1 指定為 manager</p>

<pre><code class="ruby">docker swarm init --advertise-addr 192.168.99.100
</code></pre>

<pre><code class="ruby">Swarm initialized: current node (2vo249yn5wa5inamg7r20hu1q) is now a manager.

To add a worker to this swarm, run the following command:

    docker swarm join --token SWMTKN-1-4vl3brd3z91s6kqsqjhz4p9dqnesanq30bu2kgty1krin8e5wp-0yd8lyh4g1l30njzo2yxflcjo 192.168.99.100:2377

To add a manager to this swarm, run 'docker swarm join-token manager' and follow the instructions.
</code></pre>

<p>進入 worker1 &amp; worker2</p>

<pre><code class="ruby">docker-machine ssh worker1
docker-machine ssh worker2
</code></pre>

<p>加入 swarm</p>

<pre><code class="ruby"> docker swarm join --token SWMTKN-1-4vl3brd3z91s6kqsqjhz4p9dqnesanq30bu2kgty1krin8e5wp-0yd8lyh4g1l30njzo2yxflcjo 192.168.99.100:2377
</code></pre>

<p>接著到 manager 看目前 node 狀況，只有 manager1 是 leader</p>

<pre><code class="ruby">docker node ls
</code></pre>

<pre><code class="ruby">ID                            HOSTNAME            STATUS              AVAILABILITY        MANAGER STATUS      ENGINE VERSION
2vo249yn5wa5inamg7r20hu1q *   manager1            Ready               Active              Leader              18.09.0
jhv6fv23627gpja6nhu06bx1a     worker1             Ready               Active                                  18.09.0
80x4t8oyhh7orpck7uksuv24c     worker2             Ready               Active                                  18.09.0
</code></pre>

<p>網路狀況，可看到 swarm 是 overlay</p>

<pre><code class="ruby">docker network ls
</code></pre>

<pre><code class="ruby">NETWORK ID          NAME                DRIVER              SCOPE
f01fa41ff7a6        bridge              bridge              local
1979e800b7d0        docker_gwbridge     bridge              local
85fd158c6bb0        host                host                local
jpgat6x8ukxl        ingress             overlay             swarm
4e106b8319a7        none                null                local
</code></pre>

<p>進到 manager1 啟動一個 service</p>

<pre><code class="ruby">docker service create --replicas 1 -d -p 8080:80 --name my_nginx nginx
</code></pre>

<p>查看跑在哪個 worker</p>

<pre><code class="ruby">docker service ps my_nginx
</code></pre>

<pre><code class="ruby">ID                  NAME                IMAGE               NODE                DESIRED STATE       CURRENT STATE           ERROR               PORTS
lu4in7orcr7t        my_nginx.1          nginx:latest        worker2             Running             Running 9 minutes ago
</code></pre>

<p>查看詳細資料</p>

<pre><code class="ruby">docker service inspect --pretty my_nginx
</code></pre>

<p>接著就可以在</p>

<pre><code class="ruby"># 看到所有 nginx
192.168.99.100:8080
192.168.99.101:8080
192.168.99.102:8080

# 可以試試看更改 /usr/share/nginx/html/index.html
</code></pre>

<p>調整 replicas</p>

<pre><code class="ruby">docker service update --replicas 2 my_nginx
</code></pre>

<h3>相關指令</h3>

<pre><code class="ruby"># 查看 ip 等相關訊息
docker-machine env manager1

# 初始化一個 Swarm 集群(manager, leader)
docker swarm init --advertise-addr 192.168.99.100

# 其他 worker join 到同一個集群
docker swarm join --token [token] [master的IP]:[master的port]

# 獲取加入集群的token
docker swarm join-token worker

# 取得 manager toke，可以用另外一台當 manager 的職代，可以有多個 manager 但只能有一個 leader
docker swarm join-token manager

# 離開 swarm
docker swarm leave manager

# 查看 node 資料
docker node inspect

# 移除 node
docker node rm worker1

# 讓其中2份nginx容器副本，分配到集群中
docker service create --replicas 2 -d -p 8080:80 --name my_nginx nginx

# 查看
docker service ls

# 查看目前跑在哪個 service
docker service ps my_nginx
docker service inspect --pretty my_nginx

# 擴容service中的任務，到第三台
docker service scale my_nginx=3

# remove service
docker service rm my_nginx
</code></pre>

<p>參考文件:</p>

<ul>
<li><a href="https://docs.docker.com/machine/overview/">Docker Machine Overview</a></li>
<li><a href="https://docs.docker.com/engine/swarm/">Swarm mode overview</a></li>
<li><a href="https://docs.docker.com/engine/reference/commandline/service/">docker service</a></li>
<li><a href="https://docs.docker.com/engine/swarm/ingress/">Use swarm mode routing mesh</a></li>
<li><a href="https://github.com/twtrubiks/docker-swarm-tutorial">docker-swarm-tutorial</a></li>
<li><a href="http://www.ityouknow.com/docker/2018/03/30/docker-machine.html">Docker(五)：Docker 三剑客之 Docker Machine</a></li>
<li><a href="http://www.ityouknow.com/docker/2018/04/19/docker-swarm.html">Docker(六)：Docker 三劍客之 Docker Swarm</a></li>
<li><a href="https://www.jianshu.com/p/3f3c9e0e3db5">Docker Swarm集群初探</a></li>
<li><a href="https://www.jianshu.com/p/9eb9995884a5">Docker Swarm 入門一篇文章就夠了</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Rails API + Nuxt.js + Devise-JWT]]></title>
    <link href="https://mgleon08.github.io/blog/2018/07/17/rails-nuxt-jwt/"/>
    <updated>2018-07-17T17:39:32+08:00</updated>
    <id>https://mgleon08.github.io/blog/2018/07/17/rails-nuxt-jwt</id>
    <content type="html"><![CDATA[<p>在網路上發現這篇文章，覺得寫得很不錯，所以這次就跟著這篇一起做一遍~</p>

<!-- more-->


<p><a href="https://medium.com/@fishpercolator/how-to-separate-frontend-backend-with-rails-api-nuxt-js-and-devise-jwt-cf7dd9da9d16">How to separate frontend + backend with Rails API, Nuxt.js and Devise-JWT</a></p>

<p>來學習，<code>Rails API / Nuxt.js / JWT / Docker</code></p>

<ul>
<li><a href="#part1">Part 1: Creating a development environment</a></li>
<li><a href="#part2">Part 2: Getting them talking to each other</a></li>
<li><a href="#part3">Part 3: Authentication with Devise-JWT</a></li>
</ul>


<h1><span id="part1">Part 1: Creating a development environment</span></h1>

<pre><code class="ruby"># backend
mkdir autheg
cd autheg
rails new autheg-backend -T --skip-spring -C -B -d postgresql --api
# -T = skip test
# -C = skip action cable
# -B = skip bundle 主要是作者要跑在 docker 裡面
# --api = 沒有任何 view 純 API server

#frontend
vue init nuxt-community/starter-template autheg-frontend
cd autheg-frontend
yarn generate-lock-entry &gt; yarn.lock
# 跟 -B 類似，為了不 install
</code></pre>

<h3>backend</h3>

<pre><code class="ruby"># autheg/autheg-backend/Dockerfile
FROM ruby:2.5

ARG UID
RUN adduser rails --uid $UID --disabled-password --gecos ""
# 可以透過 $UID 給予不同的 user ID，並且進到任何的 container 都可以用相同的 user ID
# --disabled-password - 讓 rails 無法用密碼登入
# --gecos 用戶的詳細訊息（如姓名，年齡，電話等），因為 adduser 會提示你輸入用戶的密碼和相關的finger訊息，但是這個可以用選項--gecos來覆蓋。

ENV APP /usr/src/app
RUN mkdir $APP
WORKDIR $APP

COPY Gemfile* $APP/
RUN bundle install -j3 --path vendor/bundle
# Gems and yarn packages are installed into the mounted volumes.
# This will stop you from needing to rebuild the whole Docker image every time you change the Gemfile or package.json.

COPY . $APP/

CMD ["bin/rails", "server", "-p", "8080", "-b", "0.0.0.0"]
# 這裡原本是 rails，但實際在 run 的時候會有 error，因此改為 bin/rails
</code></pre>

<p><code>.dockerignore</code> 避免 Docker 在 build 的時候，一併複製過去</p>

<pre><code class="ruby"># autheg/autheg-backend/.dockerignore
/vendor/bundle
/log
/tmp
</code></pre>

<pre><code class="ruby"># autheg/autheg-backend/.gitignore
/vendor/bundle/
</code></pre>

<h3>frontend</h3>

<pre><code class="ruby"># autheg/autheg-frontend/Dockerfile

FROM node:9

ARG UID
RUN adduser frontend --uid $UID --disabled-password --gecos ""

ENV APP /usr/src/app
RUN mkdir $APP
WORKDIR $APP

COPY package.json yarn.lock $APP/
RUN yarn
# Gems and yarn packages are installed into the mounted volumes.
# This will stop you from needing to rebuild the whole Docker image every time you change the Gemfile or package.json.

COPY . $APP/

CMD ["yarn", "run", "dev"]
</code></pre>

<p><code>.dockerignore</code> 避免 Docker 在 build 的時候，一併複製過去</p>

<pre><code class="ruby"># autheg/autheg-frontend/.dockerignore
/node_modules/
</code></pre>

<h3>all</h3>

<pre><code class="ruby"># autheg/docker-compose.yml

version: '3' # dockerfile 版本
services:
  db: # 對應 rails database.yml 的 host
    image: postgres
    ports:
      - "5432"
  backend: # 會變成 REPOSITORY name autheg_backend
    build:
      context: autheg-backend # 要 build 的資料夾位置
      args:
        UID: ${UID:-1001}
    volumes:
      - ./autheg-backend:/usr/src/app
      # 放哪裡沒有一定 /var/www/html,  /usr/src/app,  /home 都有人放
    ports:
      - "8080:8080"
    depends_on:
      - db
    user: rails # 對應到 adduser 的名稱
  frontend: # 會變成 REPOSITORY name autheg_frontend
    build:
      context: autheg-frontend
      args:
        UID: ${UID:-1001}
    volumes:
      - ./autheg-frontend:/usr/src/app
    ports:
      - "3000:3000"
    user: frontend # 對應到 adduser 的名稱
</code></pre>

<p>接下來執行</p>

<pre><code>docker-compose build
</code></pre>

<pre><code class="ruby"># docker images
REPOSITORY          TAG                 IMAGE ID            CREATED              SIZE
autheg_frontend     latest              18b1178326a7        About a minute ago   890MB
autheg_backend      latest              528bfe5bf6d6        2 minutes ago        1.03GB
</code></pre>

<pre><code>docker-compose run -u root backend bundle
</code></pre>

<pre><code class="ruby"># docker ps -a
CONTAINER ID        IMAGE               COMMAND                  CREATED              STATUS                          PORTS                     NAMES
a11609898c96        autheg_backend      "bundle"                 About a minute ago   Exited (0) About a minute ago                             autheg_backend_run_1
f088297e9b9b        postgres            "docker-entrypoint.s…"   About a minute ago   Up About a minute               0.0.0.0:32783-&gt;5432/tcp   autheg_db_1

docker volume ls
# DRIVER              VOLUME NAME
# local               64117d4ab46a1d0575cc7136e745cc70bf568cfb3e200c80c69ae035cde89085
</code></pre>

<pre><code>docker-compose run frontend yarn
</code></pre>

<pre><code class="ruby"># docker ps -a
CONTAINER ID        IMAGE               COMMAND                  CREATED                  STATUS                     PORTS                     NAMES
d51e53bd1370        autheg_frontend     "yarn"                   Less than a second ago   Exited (0) 3 seconds ago                             autheg_frontend_run_1
a11609898c96        autheg_backend      "bundle"                 3 minutes ago            Exited (0) 3 minutes ago                             autheg_backend_run_1
f088297e9b9b        postgres            "docker-entrypoint.s…"   3 minutes ago            Up 3 minutes               0.0.0.0:32783-&gt;5432/tcp   autheg_db_1
</code></pre>

<p>要再跑 bundle &amp; yarn 是因為有做 volumes，因此利用 docker 所建立的環境，跑 host 的 bundle &amp; yarn，讓兩邊一致</p>

<blockquote><p>The reason you need to run bundle and yarn after building is because your docker-compose file mounts your host volumes into the containers so you need to install the packages into the host volumes as well as the images that are used to create the containers</p></blockquote>

<h3>編輯 database.yml &amp; package.json</h3>

<pre><code class="diff"> default: &amp;default
   adapter: postgresql
   encoding: unicode
+  host: db
+  username: postgres
</code></pre>

<pre><code class="diff">   "private": true,
   "scripts": {
-    "dev": "nuxt",
+    "dev": "HOST=0.0.0.0 nuxt",
     "build": "nuxt build",
     "start": "nuxt start",
     "generate": "nuxt generate",
</code></pre>

<p><code>HOST=0.0.0.0 nuxt</code> so it’s visible on your host machine</p>

<p>再啟動一個 container 用來建立新資料庫</p>

<pre><code>docker-compose run backend bin/rails db:create
</code></pre>

<p>此時 db 會 create 在，一開始設定的 db container <code>autheg_db_1</code> 裡面，可以</p>

<pre><code class="ruby">docker exec -it autheg_db_1 bash
su - postgres
psql -ls
# 就會看到 create 好的 database
</code></pre>

<p>看一下目前產生的 container</p>

<pre><code class="ruby"># docker ps -a
CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS                     PORTS                     NAMES
85d3ec81e943        autheg_backend      "bin/rails db:create"    6 minutes ago       Exited (0) 6 minutes ago                             autheg_backend_run_2
6e1f7b406a70        autheg_frontend     "yarn"                   7 minutes ago       Exited (0) 7 minutes ago                             autheg_frontend_run_1
55ff63bb46e9        autheg_backend      "bundle"                 25 minutes ago      Exited (0) 8 minutes ago                             autheg_backend_run_1
e889c2e713d0        postgres            "docker-entrypoint.s…"   25 minutes ago      Up 25 minutes              0.0.0.0:32770-&gt;5432/tcp   autheg_db_1
</code></pre>

<p>將所有 container 啟動</p>

<pre><code class="ruby">docker-compose up
# docker-compose stop
# docker-compose down
</code></pre>

<p>就能看到</p>

<ul>
<li>rails : <code>http://localhost:8080/</code></li>
<li>nuxt : <code>http://localhost:3000/</code></li>
</ul>


<p><img src="https://cdn-images-1.medium.com/max/1600/1*hoai7Zion_e9-0uZQGr1Sw.png" alt="" />
<em>from <a href="https://medium.com/@fishpercolator/how-to-separate-frontend-backend-with-rails-api-nuxt-js-and-devise-jwt-cf7dd9da9d16">How to separate frontend + backend with Rails API, Nuxt.js and Devise-JWT</a></em></p>

<h1><span id="part2">Part 2: Getting them talking to each other</span></h1>

<p>新增 table, model, controller</p>

<pre><code class="ruby">docker-compose run backend bash
&gt; bin/rails g resource example name:string colour:string
&gt; bin/rails db:migrate
&gt; bin/rails c
&gt; &gt; {"foo" =&gt; "green", "bar" =&gt; "red", "baz" =&gt; "purple"}.each {|n,c| Example.create!(name: n, colour: c)}
</code></pre>

<p>編輯 controller</p>

<pre><code class="ruby"># autheg-backend/app/controllers/examples_controller.rb
class ExamplesController &lt; ApplicationController
  def index
    examples = Example.all.select(:id, :name, :colour)
    render json: examples
  end
end
</code></pre>

<pre><code class="ruby"># autheg-backend/config/routes.rb
Rails.application.routes.draw do
  scope :api, defaults: { format: :json } do
    resources :examples
  end
end
</code></pre>

<p>這個步驟目前先不做，要等後面安裝 <code>devise</code> 才需要</p>

<pre><code class="ruby"># autheg-backend/app/controllers/application_controller.rb
class ApplicationController &lt; ActionController::API
  include ActionController::MimeResponds
  respond_to :json
end
</code></pre>

<p>現在打 <code>http://localhost:8080/api/examples</code> 就會看到</p>

<p><img src="https://cdn-images-1.medium.com/max/1600/1*76hf6XcYJM_xLdpbd0jZGw.png" alt="" />
<em>from <a href="https://medium.com/@fishpercolator/how-to-separate-frontend-backend-with-rails-api-nuxt-js-and-devise-jwt-cf7dd9da9d16">How to separate frontend + backend with Rails API, Nuxt.js and Devise-JWT</a></em></p>

<p>接著安裝 <a href="https://github.com/axios/axios">axios</a> &amp; <a href="https://vuetifyjs.com/en/">vuetify</a></p>

<pre><code class="ruby">docker-compose run frontend yarn add @nuxtjs/axios @nuxtjs/vuetify
</code></pre>

<p>這邊是 hardcode 在上面，正式機不應該這樣寫</p>

<pre><code class="js">// autheg-frontend/nuxt.config.js
  modules: [
    '@nuxtjs/vuetify',
    '@nuxtjs/axios'
  ],
  axios: {
    host: 'localhost',
    port: 8080,
    prefix: '/api'
  }
</code></pre>

<p>更改畫面</p>

<p>The <code>nuxt</code> option to the link tells it to use Nuxt’s router to handle the link, rather than doing it in the browser.</p>

<pre><code class="js">// autheg-frontend/layouts/default.vue
&lt;template&gt;
  &lt;div id="app"&gt;
    &lt;v-app&gt;
      &lt;v-toolbar app dark&gt;
        &lt;v-toolbar-title&gt;Auth example&lt;/v-toolbar-title&gt;
        &lt;v-spacer /&gt;
        &lt;v-btn icon nuxt href="https://mgleon08.github.io/"&gt;&lt;v-icon&gt;home&lt;/v-icon&gt;&lt;/v-btn&gt;
      &lt;/v-toolbar&gt;
      &lt;v-content&gt;
        &lt;v-container fluid&gt;
          &lt;nuxt/&gt;
        &lt;/v-container&gt;
      &lt;/v-content&gt;
    &lt;/v-app&gt;
  &lt;/div&gt;
&lt;/template&gt;
</code></pre>

<p><code>mounted()</code> 會在 template 初始化的時候呼叫，並且會 call <code>updateExamples()</code> method，去 call <code>/examples</code> API 拿資料回來</p>

<p>```js
// autheg-frontend/pages/index.vue
<template>
  <v-layout>
    <v-flex>
      <v-list>
        <v-list-tile v-for="example in examples" :key="example.id" :class="example.colour">
          <v-list-tile-content>{{example.name}}</v-list-tile-content>
        </v-list-tile>
      </v-list>
    </v-flex>
  </v-layout>
</template></p>

<script>
export default {
  data () {
    return {
      examples: []
    }
  },
  methods: {
    async updateExamples() {
      this.examples = await this.$axios.$get('/examples')
    }
  },
  mounted () {
    this.updateExamples()
  }
}
</script>


<pre><code>
接著會看到 browser console 會 error，主要是因為 [CROS](https://en.wikipedia.org/wiki/Cross-origin_resource_sharing) 的原因

&gt; JavaScript isn’t allowed to query endpoints on other domains unless those domains set the CORS headers appropriately

![](https://cdn-images-1.medium.com/max/1600/1*5PhACGlQd7cfjiA-DqksuA.png)
*from [How to separate frontend + backend with Rails API, Nuxt.js and Devise-JWT](https://medium.com/@fishpercolator/how-to-separate-frontend-backend-with-rails-api-nuxt-js-and-devise-jwt-cf7dd9da9d16)*

接著要去 `backend` 新增 `cros` 的設定，讓 `frontend` 可以 call

先將 Gemfile 的 comment 打開
</code></pre>

<h1>autheg-backend/Gemfile</h1>

<p>gem &lsquo;rack-cors&rsquo;</p>

<h1>autheg-backend/config/initializers/cors.rb</h1>

<p>Rails.application.config.middleware.insert_before 0, Rack::Cors do
  allow do
    origins &lsquo;localhost:3000&rsquo; # 也可以 * 就是所有 domain 都可以打進來</p>

<pre><code>resource '*',
  headers: :any,
  methods: [:get, :post, :put, :patch, :delete, :options, :head]
</code></pre>

<p>  end
end
```</p>

<p>接著跑</p>

<pre><code>docker-compose run -u root backend bundle
</code></pre>

<p>然後重新起動 container</p>

<pre><code>ctrl + c
docker-compose up
</code></pre>

<p><img src="https://cdn-images-1.medium.com/max/1600/1*LUreZEc1i0c5WfhoDCLxSQ.png" alt="" />
<em>from <a href="https://medium.com/@fishpercolator/how-to-separate-frontend-backend-with-rails-api-nuxt-js-and-devise-jwt-cf7dd9da9d16">How to separate frontend + backend with Rails API, Nuxt.js and Devise-JWT</a></em></p>

<h1><span id="part3">Part 3: Authentication with Devise-JWT</span></h1>

<p>這次要加上 devise 加上 JWT</p>

<ul>
<li><a href="https://jwt.io/">JWT</a></li>
<li><a href="https://github.com/plataformatec/devise">devise</a></li>
<li><a href="https://github.com/waiting-for-dev/devise-jwt">devise-jwt</a></li>
</ul>


<p>先在 Gemfile 新增</p>

<pre><code class="ruby"># autheg-backend/Gemfile
gem 'devise'
gem 'devise-jwt'
</code></pre>

<p>bundle</p>

<pre><code class="ruby">docker-compose run -u root backend bundle
</code></pre>

<p>接著先安裝 devise 參考 <a href="https://github.com/plataformatec/devise#getting-started">getting-started</a></p>

<pre><code class="ruby"># 開新的 container 安裝 devise
docker-compose run backend bash
bin/rails g devise:install
bin/rails g devise user
bin/rails db:migrate
</code></pre>

<p>到這個步驟都還沒用到 <a href="https://jwt.io/">JWT</a>，接下來要要決定如何使令牌無效，原文選擇用 <code>黑名單</code> 的方式</p>

<pre><code class="ruby">bin/rails g model jwt_blacklist jti:string:index exp:datetime
</code></pre>

<p>並將欄位加上 <code>null: false</code> 和移除 <code>t.timestamps</code></p>

<pre><code class="ruby">def change
  create_table :jwt_blacklists do |t|
    t.string :jti, null: false
    t.datetime :exp, null: false
  end
  add_index :jwt_blacklists, :jti
end
</code></pre>

<p>在 model 加上 <code>include Devise::JWT::RevocationStrategies::Blacklist</code></p>

<pre><code class="ruby"># autheg-backend/app/models/jwt_blacklist.rb
class JwtBlacklist &lt; ApplicationRecord
  include Devise::JWT::RevocationStrategies::Blacklist
end
</code></pre>

<h3>secret setting</h3>

<blockquote><p>在這裡遇到個問題 <a href="https://github.com/waiting-for-dev/devise-jwt/issues/56">No implicit conversion of nil into String</a>，主要是用的 rails 版本，與原文章的 ralis(5.1) 不同，導致遇到在 5.2 版本時已經沒有 <code>secrets.yml</code>&hellip; 轉而改用 <code>credentials.yml.enc</code>，所以在這裡記錄一下兩個版本的設定</p></blockquote>

<h3>Before rails 5.2</h3>

<p>接著產生一組 secret，做設定</p>

<pre><code class="ruby">bin/rails secret
# 9dd044df628a496e83c668f..
</code></pre>

<pre><code class="ruby"># autheg-backend/config/secrets.yml
development:
  secret_key_base: xxx
  jwt_secret: 9dd044df628a496e83c668f..

test:
  secret_key_base: xxx
  jwt_secret: 9dd044df628a496e83c668f..

production:
  secret_key_base: &lt;%= ENV["SECRET_KEY_BASE"] %&gt;
  jwt_secret: &lt;%= ENV["JWT_SECRET"] %&gt;
</code></pre>

<pre><code class="ruby"># autheg-backend/config/initializers/devise.rb
config.jwt do |jwt|
  jwt.secret = Rails.application.secrets.jwt_secret
end
</code></pre>

<h3>After rails 5.2</h3>

<ul>
<li><a href="https://medium.com/cedarcode/rails-5-2-credentials-9b3324851336">Rails 5.2 credentials</a></li>
<li><a href="https://www.viget.com/articles/storing-secret-credentials-in-rails-5-2-and-up/">Storing Secret Credentials in Rails 5.2 and Up</a></li>
<li><a href="https://keithpblog.org/post/encrypted-secrets/">Rails 5.2: encrypted secrets</a></li>
</ul>


<pre><code class="ruby">bin/rails secret
# 9dd044df628a496e83c668f..
</code></pre>

<p>這時必須在 console執行 <code>EDITOR="vim" rails credentials:edit</code>，但是在 container 並沒有 <code>vim</code> 和 <code>sudo</code> 這個指令，因此要先切換成 root 去安裝 <code>vim</code> 才有辦法執行</p>

<blockquote><p>如果無法順利執行的話可以刪掉 <code>config/credentials.yml.enc</code> 在執行 <code>EDITOR="vim" rails credentials:edit</code> 一次</p></blockquote>

<pre><code class="ruby">docker-compose run -u root backend bash
apt-get update
apt-get install vim -y # 安裝 vim
EDITOR="vim" bin/rails credentials:edit

# 接著編輯
secret_key_base: xxx
jwt_secret: 9dd044df628a496e83c668f..
</code></pre>

<pre><code class="ruby"># autheg-backend/config/initializers/devise.rb
config.jwt do |jwt|
  jwt.secret = Rails.application.credentials[:jwt_secret]
end
</code></pre>

<p>上面 secret 設定好就可以繼續</p>

<p>設定 <code>response format</code></p>

<pre><code class="ruby"># autheg-backend/app/controllers/application_controller.rb
class ApplicationController &lt; ActionController::API
  include ActionController::MimeResponds
  respond_to :json
end
</code></pre>

<pre><code class="ruby"># autheg-backend/app/models/user.rb
class User &lt; ApplicationRecord
  # Include default devise modules. Others available are:
  # :confirmable, :lockable, :timeoutable and :omniauthable
  devise :database_authenticatable, :registerable,
         :recoverable, :rememberable, :trackable, :validatable,
         :jwt_authenticatable, jwt_revocation_strategy: JwtBlacklist
end
</code></pre>

<p>設定好跑</p>

<pre><code class="ruby">bin/rails db:migrate
</code></pre>

<p>將 router 的 <code>devise_scope :user</code> 移到 api scope 裡面</p>

<pre><code class="ruby">Rails.application.routes.draw do
  # For details on the DSL available within this file, see http://guides.rubyonrails.org/routing.html
  scope :api, defaults: { format: :json } do
    resources :examples
    devise_for :users
  end
end
</code></pre>

<p>restart containers</p>

<pre><code>ctrl + c
docker-compose up
</code></pre>

<p>console 新增一個 User</p>

<pre><code class="ruby">bin/rails c
User.create!(email: 'test@example.com', password: 'password')
</code></pre>

<p>接下來就可以來測試 <code>user login</code> 原文推薦使用 <a href="http://yet-another-rest-client.com/">YARC</a> 不過個人偏好 <a href="https://www.getpostman.com/">Postman</a>，都可以</p>

<pre><code class="ruby">POST /api/users/sign_in

{
   "user":{
      "email":"test@example.com",
      "password":"password"
   }
}
</code></pre>

<p><img src="https://cdn-images-1.medium.com/max/1600/1*2cTvgN1s2-6VkCLknzuwXQ.png" alt="" />
<em>from <a href="https://medium.com/@fishpercolator/how-to-separate-frontend-backend-with-rails-api-nuxt-js-and-devise-jwt-cf7dd9da9d16">How to separate frontend + backend with Rails API, Nuxt.js and Devise-JWT</a></em></p>

<p>這裡可以看到 Response Headers 多了一個欄位</p>

<pre><code class="ruby"># 原本

{
  "x-runtime": "0.496080",
  "etag": "W/\"9a9c93785c7d5e5890c3189efa33ca10\"",
  "vary": "Origin",
  "content-type": "application/json; charset=utf-8",
  "location": "/",
  "cache-control": "max-age=0, private, must-revalidate",
  "transfer-encoding": "chunked",
  "x-request-id": "c6a59d67-2551-496f-8f99-f69c5b79bd75",
  "status": 201
}

# 加上 jwt

{
  "x-runtime": "0.998534",
  "etag": "W/\"d2403cf91d814bea7a094efecd1e0ae9\"",
  "authorization": "Bearer eyJhbGciOiJIUzI1NiJ9.eyJzdWIiOiIxIiwic2NwIjoidXNlciIsImF1ZCI6bnVsbCwiaWF0IjoxNTMxNjY2NjA0LCJleHAiOjE1MzE2NzAyMDQsImp0aSI6ImYzMjkxMWViLTY0ZDEtNDU0NS1iNGJjLTQ5MjE2NjQwMDc1OCJ9.nP5vGhbiPfC5acnQOusY_bEZCAWF2TZ29vq28SMUX2U",
  "vary": "Origin",
  "content-type": "application/json; charset=utf-8",
  "location": "/",
  "cache-control": "max-age=0, private, must-revalidate",
  "transfer-encoding": "chunked",
  "x-request-id": "4eec0e2f-5cb5-4c4d-9ed9-be9385c79a5d",
  "status": 201
}
</code></pre>

<p>接著要來覆蓋掉 devise 原本的 session controller，讓我們可以將 jwt 加進去</p>

<p>先 generate devise 內建的 sessino controller</p>

<pre><code class="ruby">bin/rails generate devise:controllers users -c=sessions
</code></pre>

<p>並且新增一個 router，已便可以拿到 user 的 detail 資訊</p>

<blockquote><p>這裡跟原文章不太一樣，這邊是藉由 devise 內建的 generate 產生 session controller file，是放在 app/controller/users/sessions_controller.rb，原文章應該是自行建立的檔案放在 app/controller/sessions_controller.rb，因此底下的 router 設定也會有稍微不同</p></blockquote>

<pre><code class="ruby"># autheg-backend/config/routes.rb
Rails.application.routes.draw do
  scope :api, defaults: { format: :json } do
    resources :examples
    devise_for :users, controllers: { sessions: 'users/sessions' }
    devise_scope :user do
      get 'users/current', to: 'users/sessions#show'
    end
  end
end
</code></pre>

<p>將 Gemfile 裡的 <code>jbuilder</code> gem 打開</p>

<pre><code class="ruby"># Gemfile
gem 'jbuilder', '~&gt; 2.5'
</code></pre>

<pre><code class="ruby">docker-compose run -u root backend bundle
# restart containers
docker-compose up
</code></pre>

<pre><code class="ruby"># autheg-backend/app/controllers/users/sessions_controller.rb
class Users::SessionsController &lt; Devise::SessionsController
  def create
    super { @token = current_token }
  end

  def show
  end

  private

  def current_token
    request.env['warden-jwt_auth.token']
  end
end
</code></pre>

<pre><code class="ruby"># autheg-backend/app/views/users/create.json.jbuilder
json.token @token
</code></pre>

<pre><code class="ruby"># autheg-backend/app/views/users/show.json.jbuilder
if user_signed_in?
  json.user do
    json.(current_user, :id, :email)
  end
end
</code></pre>

<p>接下來可以測試 login 了</p>

<pre><code class="ruby"># 登入拿 token
POST /api/users/sign_in

{
   "user":{
      "email":"test@example.com",
      "password":"password"
   }
}

# 在 Header 加上剛剛登入拿到的 token
# "authorization": "Bearer eyJhbGciOiJIUzI1NiJ9.eyJzdW ..."
GET /api/users/current

# 登出，記得也要帶 token 才知道誰要登出
# "authorization": "Bearer eyJhbGciOiJIUzI1NiJ9.eyJzdW ..."
DELETE /api/users/sign_out
</code></pre>

<p>測試 ok 後，接下來在 <code>ExamplesController</code> 加上 <code>authentication</code></p>

<pre><code class="ruby"># autheg-backend/app/controllers/examples_controller.rb
class ExamplesController &lt; ApplicationController
  before_action :authenticate_user!

  def index
    examples = Example.all.select(:id, :name, :colour)
    render json: examples
  end
end
</code></pre>

<p>這時 <code>GET /api/examples</code> 就必須帶 <code>token</code> 否則會 <code>error</code></p>

<pre><code class="ruby">GET /api/examples

{
  "error": "You need to sign in or sign up before continuing."
}
</code></pre>

<p>接下來回到 frontend，會發現 <code>401 Unauthorized error</code> 所以要在 frontend 加上 <code>authentication</code></p>

<p>新增後端 <code>sign_in</code> <code>sign_out</code> <code>detail</code> API &amp; <code>@nuxtjs/auth</code></p>

<pre><code>docker-compose run frontend yarn add @nuxtjs/auth
</code></pre>

<pre><code class="js">// autheg-frontend/nuxt.config.js
modules: [
  '@nuxtjs/vuetify',
  '@nuxtjs/axios',
  '@nuxtjs/auth'
],
auth: {
  endpoints: {
    login:  { url: '/users/sign_in' },
    logout: { url: '/users/sign_out', method: 'delete' },
    user:   { url: '/users/current' }
  }
}
</code></pre>

<pre><code class="js">// autheg-frontend/store/index.js
export default {
  state: () =&gt; ({
  })
}
</code></pre>

<p>restart container 讓 frontend 吃到剛剛的設定</p>

<p>```js
// autheg-frontend/pages/login.vue</p>

<p><template>
  <v-layout>
    <v-flex>
      <v-card v-if="$auth.state.loggedIn">
        <v-alert type="error" :value="error">{{error}}</v-alert>
        <v-card-text>
          Logged in as {{$auth.state.user.email}}
        </v-card-text>
        <v-card-actions>
          <v-btn @click="logout">Log out</v-btn>
        </v-card-actions>
      </v-card>
      <v-card v-else>
        <v-alert type="error" :value="error">{{error}}</v-alert>
        <v-card-text>
          <v-form>
            <v-text-field v-model="email" label="Email" />
            <v-text-field v-model="password" label="Password" type="password" />
          </v-form>
          <v-card-actions>
            <v-btn @click="login">Log in</v-btn>
          </v-card-actions>
        </v-card-text>
      </v-card>
    </v-flex>
  </v-layout>
</template></p>

<script>
export default {
  data () {
    return {
      email: '',
      password: '',
      error: null
    }
  },
  methods: {
    login: function () {
      this.$auth.login({
        data: {
          user: {
            email: this.email,
            password: this.password
          }
        }
      }).catch(e => {this.error = e + ''})
    },
    logout: function () {
      this.$auth.logout().catch(e => {this.error = e + ''})
    }
  }
}
</script>


<pre><code>
現在可以到 `/login` 試試看登入了

如果想要讓 user 沒有 login 的狀態下都 redirect 到 `login page` 就加上
</code></pre>

<p>// autheg-frontend/pages/index.vue
<template>
  <v-layout>
    <v-flex>
      <v-list>
        <v-list-tile v-for="example in examples" :key="example.id" :class="example.colour">
          <v-list-tile-content>{{example.name}}</v-list-tile-content>
        </v-list-tile>
      </v-list>
    </v-flex>
  </v-layout>
</template></p>

<script>
export default {
  middleware: ['auth'],
  data () {
    return {
      examples: []
    }
  },
  methods: {
    async updateExamples() {
      this.examples = await this.$axios.$get('/examples')
    }
  },
  mounted () {
    this.updateExamples()
  }
}
</script>


<p>```</p>

<p>現在可以 try 一下</p>

<p><img src="https://cdn-images-1.medium.com/max/1600/1*012-LUDxJttnF6Jtn0Cm7A.png" alt="" />
<em>from <a href="https://medium.com/@fishpercolator/how-to-separate-frontend-backend-with-rails-api-nuxt-js-and-devise-jwt-cf7dd9da9d16">How to separate frontend + backend with Rails API, Nuxt.js and Devise-JWT</a></em></p>

<p><img src="https://cdn-images-1.medium.com/max/1600/1*X7EYUzlYqfSEDGUlTaK7vQ.png" alt="" />
<em>from <a href="https://medium.com/@fishpercolator/how-to-separate-frontend-backend-with-rails-api-nuxt-js-and-devise-jwt-cf7dd9da9d16">How to separate frontend + backend with Rails API, Nuxt.js and Devise-JWT</a></em></p>

<p>參考文件</p>

<ul>
<li><a href="https://medium.com/@fishpercolator/how-to-separate-frontend-backend-with-rails-api-nuxt-js-and-devise-jwt-cf7dd9da9d16">How to separate frontend + backend with Rails API, Nuxt.js and Devise-JWT</a></li>
<li><a href="https://medium.com/@fishpercolator/deploying-your-nuxt-rails-api-app-to-production-with-heroku-54efd09eec22">Deploying your Nuxt+Rails API app to production with Heroku</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Docker - Docker Volumn]]></title>
    <link href="https://mgleon08.github.io/blog/2016/11/27/docker-volumn/"/>
    <updated>2016-11-27T16:28:35+08:00</updated>
    <id>https://mgleon08.github.io/blog/2016/11/27/docker-volumn</id>
    <content type="html"><![CDATA[<p>Docker Volume 是個介於主機與容器間的共享資料夾，可用來匯入或匯出容器內的資料，或者共享容器間的資料</p>

<!-- more -->


<ul>
<li>Docker image 由多個 read-only 的 file system 疊加而成一個 stack，這些組合稱為 Union File System。</li>
<li>啟動 container 的時候，會在 stack 上方新增一個 read-write layer，更動都在這邊，砍掉 container 這邊也就沒了</li>
<li>Volume 是為了要解決 container 之間資料共享與資料保存而提出的</li>
<li>Volume 就是目錄或是檔案，可以繞過 UFS 以正常的檔案或目錄的方式存在 host 本機上</li>
<li>啟動 Container 的時候產生 volume，如果 Volume 掛載的目標路徑已經有檔案存在於 Image 上面，則 Image 上面的檔案會 copy 到 volume 上，但不包括 host directory</li>
</ul>


<p><img src="https://docs.docker.com/storage/images/types-of-mounts-volume.png" alt="" /></p>

<pre><code class="ruby"># 建立 volume，沒指定名稱會給個亂數
docker volume create --name db-data

# 列出所有的 volume
docker volume ls

# 列出所有沒有被關聯到 container 的 volume 的 VOLUME NAME
docker volume ls -qf dangling=true

# 一次刪除所有 volume
docker volume rm $(docker volume ls -qf dangling=true)

# 查看 volume 的資訊
docker volume inspect volume_name

# 查看某一個 container 的 volume 狀況
docker inspect -f '{{.Mounts}}' 825005afab43
</code></pre>

<h3>實戰範例 named volume 1</h3>

<blockquote><p>先 create 再使用的 volume 稱作 named volume</p></blockquote>

<p>建立新的 volume</p>

<pre><code class="ruby">docker volume create --name db-data
docker volume ls # 查看是否建立成功
</code></pre>

<p>使用 volume</p>

<pre><code class="ruby"># 將剛剛建立的 volume 掛載到 container 裡面的 /db/data
# 確認一開始資料夾是空的
docker run --rm -v db-data:/db/data -it ubuntu:14.04 ls -l /db/data
# 在 container 建立新的檔案
docker run --rm -v db-data:/db/data -it ubuntu:14.04 touch /db/data/file
在查看一次是否有檔案
docker run --rm -v db-data:/db/data -it ubuntu:14.04 ls -l /db/data
</code></pre>

<p>以上都是個別開 container 去操作，因此可以發現每次新的 container 資料還是會存在這，因為都是掛載同樣的 volume</p>

<h3>實戰範例 named volume 2</h3>

<p><code>named volume</code> 沒有指定 loacl 的路徑，檔案會去哪裡?</p>

<pre><code class="ruby">docker run -it -v /volume-test ubuntu:14.04 /bin/bash
docker volume ls

# 發現多了一個，因為沒指定名稱所以就產生亂碼
DRIVER              VOLUME NAME
local               c449638e58fe0c03961ce48411f31995b080f8cd4b13e8d67787cf775b1aa20a
</code></pre>

<pre><code class="ruby"># 尋找 container 的 loacl volume, 825005afab43 是 container id
docker inspect -f '{{.Mounts}}' 825005afab43
[{volume c449638e58fe0c03961ce48411f31995b080f8cd4b13e8d67787cf775b1aa20a /var/lib/docker/volumes/c449638e58fe0c03961ce48411f31995b080f8cd4b13e8d67787cf775b1aa20a/_data /vo-test local  true }]
</code></pre>

<p>透過上面指令就可以找到 local 的檔案，照理說可以 cd 到 <code>/var/lib/docker/volumes/c449638e58fe0c03961ce48411f31995b080f8cd4b13e8d67787cf775b1aa20a/_data /vo-test</code>，但是 mac 無法，有找到以下有人也在詢問</p>

<ul>
<li><a href="https://forums.docker.com/t/host-path-of-volume/12277">Host path of volume</a></li>
</ul>


<h3>實戰範例 host volume 1</h3>

<p><code>Host Volume</code> 指定 host 的資料夾</p>

<pre><code class="ruby"># 讓 local /app dir 連結到 container 裡面的 /app
docker run --rm  -v ~/app:/app --workdir /app node yarn init -y
</code></pre>

<p>在 container 新增新的 <code>package.json</code> 在 local 的 <code>~/app</code> 就會產生一樣的檔案</p>

<h3>實戰範例 host volume 2</h3>

<pre><code class="ruby">cd ~
mkdir volume-test
# 測試發現即使一開始沒新增 volume-test，執行指令後也是會在 local 新增這個檔案 
docker run -it -v /Users/leon/volume-test:/volume-test ubuntu:14.04 /bin/bash
# 會發現裡面也會有一個資料夾 volume-test，不管在 docker 的 /volume-test 或是 local /Users/leon/volume-test，新增檔案，另一邊都會同步
exit
# 離開了 container，會發現 /Users/leon/volume-test 裡面的檔案還是保留在裡面
docker run -it -v /Users/leon/volume-test:/volume-test ubuntu:14.04 /bin/bash
# 即使在開新的 container 檔案還是一樣會在
</code></pre>

<h3>Example 3.</h3>

<p>讓 Container 和 Container 之間的資料共享</p>

<pre><code class="ruby">docker run -it -v /data --name=container1 ubuntu:14.04 /bin/bash
docker run -it --volumes-from container1 --name=container2 ubuntu:14.04 /bin/bash

# 舊版參數
# --volumes-from 參數指定 Container Name 為 Container1 的 Volume 資料和Container2 做共享
</code></pre>

<h3>Example 4.</h3>

<p>Dockerfile 指定</p>

<pre><code class="ruby">FROM ubuntu:14.04
VOLUME /data
</code></pre>

<p>docker-compose.yml 指定</p>

<pre><code class="ruby">version: '3'
services:
  db:
    image: postgres
    ports:
      - "5432"
  backend:
    build:
      context: test-backend
      args:
        UID: ${UID:-1001}
    volumes:
      - ./test-backend:/usr/src/app
    ports:
      - "8080:8080"
    depends_on:
      - db
    user: rails
  frontend:
    build:
      context: test-frontend
      args:
        UID: ${UID:-1001}
    volumes:
      - ./test-frontend:/usr/src/app
    ports:
      - "3000:3000"
    user: frontend
</code></pre>

<h3>查看 volume 實際存取路徑</h3>

<pre><code class="ruby"># 查看名稱
docker volume ls

# 查看路徑
docker volume inspect --format '{{ .Mountpoint }}' volumeName
</code></pre>

<p>參考文件</p>

<ul>
<li><a href="https://docs.docker.com/storage/volumes/">Use volumes</a></li>
<li><a href="https://deepzz.com/post/the-docker-volumes-basic.html">docker volume 容器卷的那些事（一）</a></li>
<li><a href="https://julianchu.net/2016/04/19-docker.html">Docker volume 簡單用法</a></li>
<li><a href="https://larrylu.blog/using-volumn-to-persist-data-in-container-a3640cc92ce4">Docker 實戰系列（三）：使用 Volume 保存容器內的數據</a></li>
<li><a href="https://ithelp.ithome.com.tw/articles/10192397">Day17：使用 Docker Volume 的功能 (一)</a></li>
<li><a href="https://ithelp.ithome.com.tw/articles/10192703">Day18：使用 Docker Volume 的功能 (二)</a></li>
<li><a href="http://blog.maxkit.com.tw/2017/03/docker-volume.html">Docker Volume 初步閱讀與學習紀錄</a></li>
<li><a href="https://ruby-china.org/topics/32459">部署 長文慎入：將 Rails 程序部署到 Docker 容器中</a></li>
<li><a href="https://5xruby.tw/en/posts/rails-docker-image">2018 年的 Rails 應用 Docker Image 包裝範例</a></li>
<li><a href="https://forums.docker.com/t/host-path-of-volume/12277">Host path of volume</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
