<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Http | Leon's Blogging]]></title>
  <link href="http://mgleon08.github.com/blog/categories/http/atom.xml" rel="self"/>
  <link href="http://mgleon08.github.com/"/>
  <updated>2018-08-25T17:28:59+08:00</updated>
  <id>http://mgleon08.github.com/</id>
  <author>
    <name><![CDATA[LeonJi]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[HTTP Benchmark 工具 Wrk]]></title>
    <link href="http://mgleon08.github.com/blog/2018/04/09/http-benchmark/"/>
    <updated>2018-04-09T17:09:37+08:00</updated>
    <id>http://mgleon08.github.com/blog/2018/04/09/http-benchmark</id>
    <content type="html"><![CDATA[<p>wrk 可以預先模擬多人來網站時，效能會如何!</p>

<!-- more -->


<p>這類的工具有很多，大概如下</p>

<ul>
<li>複雜

<ul>
<li>jmeter</li>
<li>LoadRunner</li>
</ul>
</li>
<li>簡單

<ul>
<li>wrk</li>
<li>ab</li>
</ul>
</li>
</ul>


<p>那這次主要介紹是 wrk</p>

<h1>安裝</h1>

<pre><code class="ruby">brew install wrk
</code></pre>

<h1>Command</h1>

<pre><code class="ruby"># 跟服務器建立並保持的TCP連接數量 
-c, --connections: total number of HTTP connections to keep open with
                   each thread handling N = connections/threads
# 壓測時間
-d, --duration:    duration of the test, e.g. 2s, 2m, 2h

# 使用多少個線程進行壓測   
-t, --threads:     total number of threads to use

# 指定Lua腳本路徑
-s, --script:      LuaJIT script, see SCRIPTING

# 為每一個HTTP請求添加HTTP頭
-H, --header:      HTTP header to add to request, e.g. "User-Agent: wrk"
# 在壓測結束後，打印延遲統計信息
    --latency:     print detailed latency statistics
# 超時時間
    --timeout:     record a timeout if a response is not received within
                   this amount of time.
</code></pre>

<h1>Exmple</h1>

<pre><code class="ruby">wrk -t12 -c400 -d30s -T30s --latency http://localhost:3000
# -t12 用 12 個線程
# -c400 模擬 400 個併發連接
# -d30s 持續 30 秒
# -T30s 設定超過 30 秒就算連接超時 
# --latency 響應時間的分佈情況
</code></pre>

<pre><code class="ruby">Running 30s test @ http://localhost:3000
  4 threads and 1000 connections
  Thread Stats   Avg      Stdev     Max   +/- Stdev
    Latency     1.38ms    1.09ms  84.91ms   91.92%
    Req/Sec     3.62k   555.58     4.48k    81.00%
  Latency Distribution
     50%    1.22ms
     75%    1.69ms
     90%    2.27ms
     99%    3.93ms
  108206 requests in 30.08s, 118.88MB read
  Socket errors: connect 0, read 883, write 1, timeout 0
Requests/sec:   3597.39
Transfer/sec:      3.95MB
</code></pre>

<ul>
<li><code>Latency</code>: 響應時間</li>
<li><code>Req/Sec</code>: 每個線程每秒鐘的完成的請求數</li>
<li><code>Avg</code>: 平均值</li>
<li><code>Stdev (Standard Deviation)</code>: 即標準偏差，是統計學的一個名詞，這裡表示請求響應時間的離散程度，值越大代表請求響應時間的差距越大，系統的響應約不穩定。</li>
<li><code>Max</code>: 最大值</li>
<li><code>+/- Stdev</code>: 正負一個標準差佔比</li>
<li><code>Latency Distribution</code>: 50% 在 1.22ms 以內完成 / 99% 在 3.93ms 以內完成</li>
<li><code>Socket errors</code>: 分為 <code>連接錯誤</code>, <code>讀取錯誤</code>, <code>寫入錯誤</code>, <code>超時錯誤</code></li>
<li><code>Requests/sec</code>: 每秒請求數量，也就是並發能力</li>
</ul>


<h1>腳本 scroipt 測試複雜場景</h1>

<p>wrk 支援 <code>lua</code> 的腳本</p>

<p>先建立一個 <code>test.lua</code> 的 file</p>

<pre><code class="lua">-- example HTTP POST script which demonstrates setting the
-- HTTP method, body, and adding a header

wrk.method = "POST"
wrk.body   = "foo=bar&amp;baz=quux"
wrk.headers["Content-Type"] = "application/x-www-form-urlencoded"
</code></pre>

<p>執行</p>

<pre><code class="ruby">wrk -t12 -c100 -d30s -T30s --script=post.lua --latency http://localhost:3000 
</code></pre>

<h3>wrk 接受的屬性</h3>

<pre><code class="ruby">local wrk = {  
   scheme  = "http",  
   host    = "localhost",  
   port    = nil,  
   method  = "GET",  
   path    = "/",  
   headers = {},  
   body    = nil,  
   thread  = nil,  
}  
</code></pre>

<h3>wrk 提供的 hook 函數</h3>

<ul>
<li>setup 函數</li>
</ul>


<p>這個函數在目標 IP 地址已經解析完, 並且所有 thread 已經生成, 但是還沒有開始時被調用. 每個線程執行一次這個函數.
可以通過thread:get(name),  thread:set(name, value)設置線程級別的變量.</p>

<ul>
<li>init 函數</li>
</ul>


<p>每次請求發送之前被調用.
可以接受 wrk 命令行的額外參數. 通過 &ndash; 指定.</p>

<ul>
<li>delay函數</li>
</ul>


<p>這個函數返回一個數值, 在這次請求執行完以後延遲多長時間執行下一個請求. 可以對應 thinking time 的場景.</p>

<ul>
<li>request函數</li>
</ul>


<p>通過這個函數可以每次請求之前修改本次請求的屬性. 返回一個字符串. 這個函數要慎用, 會影響測試端性能.</p>

<ul>
<li>response</li>
</ul>


<p>每次請求返回以後被調用，可以根據響應內容做特殊處理，比如遇到特殊響應停止執行測試，或輸出到控制台等等。</p>

<pre><code class="lua">-- 實現每個請求前會有隨機的延遲
-- example script that demonstrates adding a random
-- 10-50ms delay before each request
function delay()
   return math.random(10, 50)
end
</code></pre>

<pre><code class="lua">-- 每個線程要先進行認證，認證之後獲取token以進行壓測
token = nil
path  = "/authenticate"

request = function()
   return wrk.format("GET", path)
end

response = function(status, headers, body)
   if not token and status == 200 then
      token = headers["X-Token"]
      path  = "/resource"
      wrk.headers["X-Token"] = token
   end
end
</code></pre>

<pre><code class="lua">-- 壓測支持HTTP pipeline的服務
-- 通過在init方法中將三個HTTP request請求拼接在一起，實現每次發送三個請求，以使用HTTP pipeline。
init = function(args)
   local r = {}
   r[1] = wrk.format(nil, "/?foo")
   r[2] = wrk.format(nil, "/?bar")
   r[3] = wrk.format(nil, "/?baz")

   req = table.concat(r)
end

request = function()
   return req
end
</code></pre>

<ul>
<li><a href="https://github.com/wg/wrk/tree/master/scripts">更多 scripts 範本</a></li>
</ul>


<p>參考文件：</p>

<ul>
<li><a href="https://github.com/wg/wrk">wrk git</a></li>
<li><a href="https://www.restran.net/2016/09/27/wrk-http-benchmark/">使用 wrk 來測試 HTTP 性能</a></li>
<li><a href="http://zjumty.iteye.com/blog/2221040">wrk &ndash; 小巧輕盈的 http 性能測試工具</a></li>
<li><a href="https://yq.aliyun.com/articles/35251">使用ab和wrk對OSS進行benchmark測試</a></li>
<li><a href="https://coolshell.cn/articles/17381.html">性能測試應該怎麼做？</a></li>
<li><a href="http://zhaox.github.io/benchmark/2016/12/28/wrk-guidelines">Http壓測工具wrk使用指南</a></li>
<li><a href="https://github.com/wg/wrk/tree/master/scripts">更多 scripts 範本</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Http Websocket Bot]]></title>
    <link href="http://mgleon08.github.com/blog/2017/10/06/http-websocket-bot/"/>
    <updated>2017-10-06T12:09:51+08:00</updated>
    <id>http://mgleon08.github.com/blog/2017/10/06/http-websocket-bot</id>
    <content type="html"><![CDATA[<p>簡單的 <code>Http</code> <code>Websocket</code> <code>Bot</code> 介紹</p>

<!-- more -->


<ul>
<li>HTTP is hypertext transfer protocol</li>
<li>HTTP is an application protocol</li>
<li>HTTP is the foundation of data communication for the World Wide Web.</li>
</ul>


<blockquote><p>HTTP 是一個無狀態（Stateless）的協議，對於事務處理沒有記憶能力，伺服器不知道客戶端是什麼狀態。發送 HTTP 請求之後，伺服器根據請求，會給我們發送數據過來，但是，發送完，不會記錄任何訊息。</p></blockquote>

<ul>
<li>Http 1.0

<ul>
<li>HTTP 的生命週期透過 Request 來界定，也就是一個Request 一個Response，那麼在HTTP1.0中，這次HTTP請求就結束了</li>
</ul>
</li>
<li>Http 1.1

<ul>
<li>多出一個keep-alive，在一個HTTP連接中，可以發送多個Request，接收多個Response。</li>
<li>但是 Request = Response ， 在HTTP中永遠是這樣，也就是說一個request只能有一個response。而且這個response也是被動的，不能主動發起。</li>
</ul>
</li>
</ul>


<p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/d/d5/HTTP_persistent_connection.svg/600px-HTTP_persistent_connection.svg.png" alt="" /></p>

<p><a href="https://read01.com/ePjEn2.html">如何理解HTTP協議的「無連接，無狀態」特點?</a></p>

<h3>傳統即時性網頁技術</h3>

<ul>
<li>Polling 輪詢

<ul>
<li>瀏覽器每隔一段時間就自動送出一個 HTTP 請求給 server ，獲取最新的網頁資料</li>
<li>在 server 沒有新資料時，瀏覽器也是會自動送出請求，造成網路資源浪費</li>
</ul>
</li>
<li>Long-Polling 長時間輪詢

<ul>
<li>server 在接收到瀏覽器所送出的 HTTP 請求後， server 會等待一段時間，若在這段時間裡 server 有新的資料，它就會把最新的資料傳回給瀏覽器</li>
<li>如果等待的時間到了之後也沒有新資料的話，就會送一個回應給瀏覽器，告知瀏覽器資料沒有更新</li>
<li>如果在資料更新很頻繁的狀況下，長時間輪詢並不會比傳統的輪詢有效率，而且有時候資料量很大時，會造成連續的 polls 不斷產生，反而會更糟糕。</li>
</ul>
</li>
<li>Streaming

<ul>
<li>讓 server 在接收到瀏覽器所送出 HTTP 請求後，立即產生一個回應瀏覽器的連線，並且讓這個連線持續一段時間不要中斷，而 server 在這段時間內如果有新的資料，就可以透過這個連線將資料馬上傳送給瀏覽器。</li>
<li>由於是建立在 HTTP 協定上的一種傳輸機制，所以有可能會因為代理 server（proxy）或防火牆（firewall）將其中的資料存放在緩衝區中，造成資料回應上的延遲，因此許多使用串流的 Comet 實作會在偵測到有代理 server 的狀況時，改用 Long-Polling 的方式處理。</li>
</ul>
</li>
</ul>


<h1>WebSocket</h1>

<blockquote><p>WebSocket protocol 定義在 HTML5 標準中的一個新的網頁傳輸協議。</p></blockquote>

<ul>
<li>是一種建立在單一 TCP 連線上的全雙工（full-duplex）通訊管道，可以讓網頁應用程式與伺服器之間做即時性、雙向的資料傳遞。</li>
<li>瀏覽器與伺服器之間若要建立一條 WebSocket 連線，在一開始的交握（handshake）階段中，要先從 HTTP 協定升級為 WebSocket 協定</li>
</ul>


<h1>EventMachine</h1>

<blockquote><p><a href="https://travisliu.gitbooks.io/learn-eventmachine/content/index.html">EventMachine</a> 是一套事件驅動(event-driven IO) 的框架，基於Reactor Pattern 達到輕量化的併發處理</p></blockquote>

<ul>
<li>Reactor模式

<ul>
<li>一個處理服務請求的並發程式設計模型。多個服務請求同時發往一個服務句柄(Service Handler)。服務句柄(Service Handler)多路分用到來的請求並把它們同步轉發給相關的請求處理器。</li>
</ul>
</li>
</ul>


<p>Github：</p>

<ul>
<li><a href="https://github.com/eventmachine/eventmachine">eventmachine</a> doc <a href="http://www.rubydoc.info/github/eventmachine/eventmachine/index">rubydoc</a></li>
<li><a href="https://github.com/faye/faye-websocket-ruby">faye-websocket-ruby</a></li>
<li><a href="https://github.com/igrigorik/em-websocket">em-websocket</a></li>
<li><a href="https://api.slack.com/community">Widely-used open source libraries</a></li>
</ul>


<p>官網：</p>

<ul>
<li><a href="http://websocket.org/">websocket.org</a></li>
<li><a href="https://hubot.github.com/">hubot</a></li>
<li><a href="https://faye.jcoglan.com/">faye</a></li>
</ul>


<p>參考文件：</p>

<ul>
<li>WebSocket 介紹

<ul>
<li><a href="https://blog.gtwang.org/web-development/websocket-protocol/">WebSocket 通訊協定簡介：比較 Polling、Long-Polling 與 Streaming 的運作原理</a></li>
<li><a href="http://www.syscom.com.tw/ePaper_New_Content.aspx?id=368&amp;EPID=194&amp;TableName=sgEPArticle">WebSocket – 新一代網路傳輸技術</a></li>
<li><a href="https://www.zhihu.com/question/20215561">WebSocket 是什麼原理？為什麼可以實現持久連接？</a></li>
</ul>
</li>
<li><a href="https://travisliu.gitbooks.io/learn-eventmachine/content/index.html">learn-eventmachine</a></li>
<li><a href="https://www.sitepoint.com/building-a-slackbot-with-ruby-and-sinatra/">Building a Slackbot with Ruby and Sinatra</a></li>
<li><a href="https://zh.scribd.com/document/28253878/EventMachine-scalable-non-blocking-i-o-in-ruby">EventMachine: scalable non-blocking i/o in ruby</a></li>
<li><a href="http://blog.csdn.net/zdq0394123/article/details/7901932">EventMachine簡介</a></li>
<li><a href="http://railsfun.tw/t/rails-websocket/498">rails + websocket</a></li>
<li><a href="https://devcenter.heroku.com/articles/ruby-websockets">Using WebSockets on Heroku with Ruby</a></li>
<li><a href="https://blog.engineyard.com/2013/getting-started-with-ruby-and-websockets">Getting Started with Ruby and WebSockets</a></li>
<li><a href="http://tonytonyjan.net/2015/11/05/concurrent-ruby/">Ruby SSE Server 動手做</a></li>
<li><a href="https://www.rails365.net/articles/websocket-xu-lie-wen-zhang-mu-lu">websocket序列文章目錄</a></li>
<li><a href="https://ihower.tw/rails4/deployment.html">EventMachine和多執行序模型</a></li>
<li><a href="http://blog.hugzh.com/2016/01/05/socket.io%E6%90%AD%E5%BB%BA%E5%A4%9A%E8%81%8A%E5%A4%A9%E5%AE%A4/">socket.io搭建多聊天室</a></li>
<li><a href="https://devcenter.heroku.com/articles/ruby-websockets#functionality">Using WebSockets on Heroku with Ruby</a></li>
<li><a href="https://wearestac.com/blog/building-a-slack-slash-command-with-sinatra-finch-and-heroku">BUILDING A SLACK SLASH COMMAND WITH SINATRA, FINCH AND HEROKU</a></li>
<li><a href="http://tech.deepdevelop.com/shi-xian-ge-slack-slash-command/">實現一個 Slack Slash Command</a></li>
<li><a href="http://blog.amowu.com/2015/12/serverless-aws-slack-slash-commands.html">Serverless! 使用 AWS 開發 Slack Slash Commands</a></li>
</ul>


<h3>Video</h3>

<ul>
<li><a href="http://code.dblock.org/2016/03/11/your-first-slack-bot-service-video.html">Your First Slack Bot Service (Ruby)</a></li>
<li><a href="http://www.slideshare.net/ryudoawaru/rt28-29828529">Eventmachine Websocket 實戰</a>  <a href="https://www.youtube.com/watch?v=5X5WEFRTehE">(Video)</a></li>
<li><a href="https://www.youtube.com/watch?v=BWaTYiTbv7Q">Say Hello To Your First Slackbot (Js)</a></li>
</ul>


<h3>Hubot</h3>

<ul>
<li><a href="https://github.com/hubot-scripts">Hubot Scripts</a></li>
<li><a href="https://github.com/github/hubot-scripts">hubot-scripts</a></li>
<li><a href="http://huli.logdown.com/posts/417258-hubot-a-bot-framework">[心得] Hubot, 一套 bot framework</a></li>
<li><a href="http://blog.frost.tw/posts/2012/03/18/create-a-hubot-plurk-adapter/">製作一個 Hubot 的噗浪 Adapter</a></li>
<li><a href="http://code.kpman.cc/2016/04/18/%E5%9C%A8-slack-%E5%BB%BA%E7%AB%8B-hubot/#">在 slack 建立 hubot</a></li>
<li><a href="https://asoul.github.io/2016/04/24/create-hubot-script-and-publish-to-npm/">如何製作 Hubot Script 推上 npm</a></li>
<li><a href="https://npes87184.github.io/%E7%A0%94%E7%A9%B6%E9%9B%9C%E8%A8%98/2016/07/08/hubotExample.html">Hubot 聊天機器人簡單架設教學</a></li>
<li><a href="https://github.com/twtrubiks/mybot">使用Hubot建立屬於自己的機器人 (Build Your Own Robot With Hubot)</a></li>
<li><a href="http://www.jianshu.com/p/3ff7a48be02d">基於Hubot打造自己的聊天機器人服務</a></li>
</ul>


<h3>other</h3>

<ul>
<li><a href="http://www.inside.com.tw/2016/08/26/how-to-build-an-inside-bot">INSIDE 有隻硬塞 Bot，聊天、訂閱、搜尋樣樣行！（請勿拍打餵食）</a></li>
<li><a href="https://chatfuel.com/">chatfuel</a></li>
</ul>


<h3>deploy</h3>

<ul>
<li><a href="https://www.heroku.com/">heroku</a></li>
<li><a href="http://uptimerobot.com/">uptimerobot</a> 一直戳 heroku 防止 server 進入休眠</li>
</ul>


<pre><code class="ruby"># create new heroku project
heroku create

# push heroku
git push heroku master

# env config setting
heroku config:add SLACK_API_TOKEN=xxxxxx-xxxxxxxxx-xxxxxxxxxxx

heroku config:add SLACK_API_TOKEN=xxoxb-74720840001-leOhdqKE1mX4hYknfHAeV049

heroku config:remove SLACK_API_TOKEN

# log
heroku logs --tail

# scale
heroku ps:scale web=2
</code></pre>

<h3>實做簡易 slack bot</h3>

<ul>
<li><a href="https://github.com/mgleon08/simple_slack_bot">simple_slack_bot</a></li>
<li><a href="https://github.com/mgleon08/simple_line_bot">simple_line_bot</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
