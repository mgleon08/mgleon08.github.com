<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Javascript | Leon's Blogging]]></title>
  <link href="https://mgleon08.github.io/blog/categories/javascript/atom.xml" rel="self"/>
  <link href="https://mgleon08.github.io/"/>
  <updated>2019-10-08T23:20:02+08:00</updated>
  <id>https://mgleon08.github.io/</id>
  <author>
    <name><![CDATA[LeonJi]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Javascript Date]]></title>
    <link href="https://mgleon08.github.io/blog/2019/08/29/javascript-date/"/>
    <updated>2019-08-29T00:31:13+08:00</updated>
    <id>https://mgleon08.github.io/blog/2019/08/29/javascript-date</id>
    <content type="html"><![CDATA[<!-- more -->


<p>在 javascript 中，時間是非常神奇的東西呢! 剛好遇到時區的相關問題，就來記錄一下</p>

<ul>
<li>GMT (格林威治標準時間, 格林威治平時, Greenwich Mean Time)</li>
<li>UTC (協調世界時 Universal Time Coordinated)</li>
<li>一般情況下，GMT 和 UTC 可以互換，但是實際上，GMT 是一個時區，而 UTC 是一個時間標準</li>
</ul>


<p>在 <code>js</code> 使用 <code>-</code> 會被 Chrome 解析為格林威治標準時間(GMT)的日期，所以像台灣的「本地時間」是 GMT+8 因此顯示時間會自動加上八小時來顯示。</p>

<p>若使用 <code>/</code> 則會是顯示「本地時間」</p>

<p>當想用 「本地時間」 時，請記得要改用 <code>/</code></p>

<pre><code class="js">// 調整電腦時區，顯示會不一樣

new Date('2019-08-14')
// Wed Aug 14 2019 08:00:00 GMT+0800 (台北標準時間)

new Date('2019/08/14')
// Wed Aug 14 2019 00:00:00 GMT+0800 (台北標準時間)
</code></pre>

<p>如果拿到的 date 是 <code>2019-08-14T00:00:00.000Z</code>，則可以透過轉換，來達成不被時區影響</p>

<pre><code class="js">let date = '2019-08-14T00:00:00.000Z'
date = date.substring(0, 10).replace(/-/g, '/');
new Date(date);
</code></pre>

<p>在 <a href="http://www.ecma-international.org/ecma-262/5.1/#sec-15.9.1.15">ECMAScript® Language Specification Date Time String Format</a> 有定義一套標準格式，基於 <code>ISO 8601</code></p>

<pre><code class="js">YYYY-MM-DDTHH:mm:ss
2019-08-14T00:00:00
</code></pre>

<p>也可以只有日期 (但就是會跟著時區跑)</p>

<pre><code class="js">new Date('2019');
new Date('2019-08');
new Date('2019-08-14');
</code></pre>

<p>結論就是需要跟著時區用 <code>-</code>，不需要則用 <code>/</code></p>

<h1>Reference</h1>

<ul>
<li><a href="http://www.timeanddate.com/time/map/">所有的時區</a></li>
<li><a href="https://pansci.asia/archives/84978">到底是 GMT+8 還是 UTC+8 ? - PanSci 泛科學</a></li>
<li><a href="https://stackoverflow.com/questions/2587345/why-does-date-parse-give-incorrect-results">javascript - Why does Date.parse give incorrect results? - Stack Overflow</a></li>
<li><a href="https://stackoverflow.com/questions/17545708/parse-date-without-timezone-javascript">Parse date without timezone javascript - Stack Overflow</a></li>
<li><a href="http://www.ecma-international.org/ecma-262/5.1/#sec-15.9.1.15">ECMAScript Language Specification - ECMA-262 Edition 5.1</a></li>
<li><a href="https://blog.miniasp.com/post/2016/09/25/JavaScript-Date-usage-in-details">前端工程研究：關於 JavaScript 中 Date 型別的常見地雷與建議作法 | The Will Will Web</a></li>
<li><a href="https://blog.csdn.net/XINGXUEXX/article/details/51132026">關於“時間”的一次探索 關於js時區iso，utc等完美解答</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JavaScript - localStorage, sessionStorage, Location, Window, Date, Destructuring, Module]]></title>
    <link href="https://mgleon08.github.io/blog/2019/07/31/javascript-other/"/>
    <updated>2019-07-31T12:32:53+08:00</updated>
    <id>https://mgleon08.github.io/blog/2019/07/31/javascript-other</id>
    <content type="html"><![CDATA[<!-- more-->


<ul>
<li><a href="#localStorage">localStorage</a></li>
<li><a href="#sessionStorage">sessionStorage</a></li>
<li><a href="#location">location</a></li>
<li><a href="#window">Window</a></li>
<li><a href="#date">Date</a></li>
<li><a href="#destructuring">解構賦值 Destructuring</a></li>
<li><a href="#module">Module</a></li>
</ul>


<h1><span id="localStorage"> localStorage </span></h1>

<ul>
<li>優點：存放不會消失，不需擔心頁面關閉/重整/新開分頁等問題</li>
<li>缺點：因為永久存放(除非user手動清除)，必須加上時效性自行判斷，或特殊操作時要將其手動清除</li>
</ul>


<p><code>localStorage</code> 只能存 string</p>

<pre><code class="js">localStorage.setItem('foo', 'bar')
console.log(localStorage.getItem('foo'))
localStorage.removeItem('foo')
localStorage.clear() // delete all
</code></pre>

<p>如果要存 <code>array</code>, <code>object</code> 必須先轉成 <code>string</code></p>

<pre><code class="js">userJSON = JSON.stringify(user)
localStorage.setItem('user', userJSON)

userString = localStorage.getItem('user')
userParse = JSON.parse(userString)
console.log(`${userParse.name} and ${userParse.age}`)
</code></pre>

<ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/localStorage">localStorage</a></li>
</ul>


<h1><span id="sessionStorage"> sessionStorage </span></h1>

<ul>
<li>優點：頁籤開著時會一直存在，重新整理也不會消失，頁籤關閉時會自動銷毀被儲存的資訊</li>
<li>缺點：只存在於當前頁籤，開新分頁並不會被傳遞</li>
</ul>


<pre><code class="js">// Save data to sessionStorage
sessionStorage.setItem('key', 'value');

// Get saved data from sessionStorage
let data = sessionStorage.getItem('key');

// Remove saved data from sessionStorage
sessionStorage.removeItem('key');

// Remove all saved data from sessionStorage
sessionStorage.clear();
</code></pre>

<ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/sessionStorage">sessionStorage</a></li>
</ul>


<h1><span id="location"> location </span></h1>

<p>The Location interface represents the location (URL) of the object it is linked to</p>

<pre><code class="js">// 轉址到 google
location.assign('http://www.google.com/')

// 取得網址後面參數
location.hash.substring(1)
</code></pre>

<ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/API/Location">Location</a></li>
</ul>


<h1><span id="window"> Window </span></h1>

<p>The Window interface represents a window containing a DOM document</p>

<pre><code class="js">// 跨頁面同步資料, 透過 listen 'storage' 是否改變去做同步
window.addEventListener('storage', function (e) {
// Will fire for localStorage changes that come from a different page
})
</code></pre>

<ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/API/Window">window</a></li>
</ul>


<h1><span id="date"> Date </span></h1>

<pre><code class="js">const dateOne = new Date('March 1 2017 12:00:00')
const month = dateOne.getMonth() + 1
const day = dateOne.getDate()
const year = dateOne.getFullYear()
console.log(`${month}/${day}/${year}`)
</code></pre>

<pre><code class="js">const date = new Date('March 1 2017 12:00:00')
const timestamp = date.getTime()
console.log(timestamp) // Will print 1488387600000
</code></pre>

<pre><code class="js">const timestamp = 1488387600000
const date = new Date(timestamp)
</code></pre>

<ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date">Date</a></li>
<li><a href="https://momentjs.com/">momentjs</a></li>
</ul>


<h1><span id="destructuring"> 解構賦值 Destructuring </span></h1>

<p>透過 mapping 屬性名稱，給予賦值</p>

<p>In Object</p>

<pre><code class="js">const todo = {
  id: 'ididididididid',
  text: 'Pay the bills',
  completed: false
}
const { text: todoText, completed, details = 'No details provided', ...others } = todo
console.log(todoText) // "Pay the bills"
console.log(completed) // false
console.log(details) // "No details provided"
console.log(others) // { id: "ididididididid" }
</code></pre>

<p>In function arguments</p>

<pre><code class="js">const todo = {
  id: 'asdfpoijwermasdf',
  text: 'Pay the bills',
  completed: false
}
const printTodo = ({ text, completed }) =&gt; {
  console.log(`${text}: ${completed}`)
}
printTodo(todo)
</code></pre>

<p>In Array</p>

<pre><code class="js">const age = [65, 0, 13]
const [firstAge, ...otherAges] = age
console.log(firstAge) // 65
console.log(otherAges) // [0, 13]
</code></pre>

<p><code>Object</code> 解構是以名稱做對應，<code>Array</code> 則是以順序為對應</p>

<pre><code class="js">let [a, , c] = [1, 2, 3]
console.log(a, c) // 1, 3

let {a, ,c} = {a:1, b:2, c:3}
console.log(a,c) // Error
</code></pre>

<p>解構用於提取 json 值時，非常方便</p>

<pre><code class="js">let foo = {
  a: 1,
  b: 'bar',
  c: {
    d: 'hi',
    e: 'hello'
  }
}

let { a, b, c } = foo
console.log(a, b, c)
// 1 'bar' { d: 'hi', e: 'hello' }
</code></pre>

<ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment">Destructuring assignment</a></li>
<li><a href="https://pjchender.blogspot.com/2017/01/es6-object-destructuring.html">[筆記] JavaScript ES6 中的物件解構賦值（object destructuring）</a></li>
</ul>


<h1><span id="module"> Module </span></h1>

<h3>Named export</h3>

<pre><code class="js">// utilities.js
export const add = (a, b) =&gt; a + b
export const subtract = (a, b) =&gt; a - b

// index.js
import { add, subtract } from './utilities'
console.log(add(32, 1)) // 33
console.log(subtract(32, 1)) //  31
</code></pre>

<h3>default export</h3>

<pre><code class="js">// utilities.js
const add = (a, b) =&gt; a + b
const subtract = (a, b) =&gt; a - b
const square = (x) =&gt; x * x
export { add, subtract, square as default }
</code></pre>

<pre><code class="js">// index.js
import otherSquare, { add } from './utilities'
console.log(add(32, 1)) // 33
console.log(otherSquare(10)) // 100
</code></pre>

<ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import">import</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/export">export</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JavaScript - HTTP Request, Promise, Async/await]]></title>
    <link href="https://mgleon08.github.io/blog/2019/07/30/javascript-http-request/"/>
    <updated>2019-07-30T12:32:23+08:00</updated>
    <id>https://mgleon08.github.io/blog/2019/07/30/javascript-http-request</id>
    <content type="html"><![CDATA[<!-- more -->


<ul>
<li><a href="#XMLHttpRequest">XMLHttpRequest</a></li>
<li><a href="#promise">Promise</a></li>
<li><a href="#async_await">Async/Await</a></li>
</ul>


<p>Asynchronous(異步/非同步) vs. Synchronous(同步)</p>

<ul>
<li><code>Asynchronous</code>: 不需等待，可以繼續做別的事</li>
<li><code>Synchronous</code>: 必須等待事情完成，才能繼續做別的事</li>
</ul>


<h1><span id="XMLHttpRequest"> XMLHttpRequest </span></h1>

<pre><code class="js">const request = new XMLHttpRequest()
request.addEventListener('readystatechange', e =&gt; {
  // 4 代表已 request 完成，已經有 response
  if (e.target.readyState === 4) {
    const data = JSON.parse(e.target.responseText)
    console.log(data)
  }
})
request.open('GET', 'http://puzzle.mead.io/puzzle')
request.send()
</code></pre>

<p>透過 <code>callback function</code> 可以當 response 回來時，在執行</p>

<pre><code class="js">const getPuzzle = callback =&gt; {
  const request = new XMLHttpRequest()
  request.addEventListener('readystatechange', e =&gt; {
    if (e.target.readyState === 4 &amp;&amp; e.target.status === 200) {
      const data = JSON.parse(e.target.responseText)
      callback(undefined, data.puzzle)
    } else if (e.target.readyState === 4) {
      callback('An error has taken place', undefined)
    }
  })
  request.open('GET', 'http://puzzle.mead.io/puzzle?wordCount=3')
  request.send()
}


// callback function
getPuzzle((error, puzzle) =&gt; {
  if (error) {
    console.log(`Error: ${error}`)
  } else {
    console.log(puzzle)
  }
})
</code></pre>

<ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest">XMLHttpRequest</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Glossary/Callback_function">Callback function</a></li>
<li><a href="https://medium.com/@hyWang/%E9%9D%9E%E5%90%8C%E6%AD%A5-asynchronous-%E8%88%87%E5%90%8C%E6%AD%A5-synchronous-%E7%9A%84%E5%B7%AE%E7%95%B0-c7f99b9a298a">非同步(Asynchronous)與同步(Synchronous)的差異</a></li>
</ul>


<h1><span id="promise"> Promise </span></h1>

<p>簡單的來說，<code>Promise</code> 主要用來處理非同步狀態(async), 就是承諾當任務完成時，通知下一個任務可以開始，不會像上面一樣要一直寫 <code>callback</code> 導致一些 <code>callback hell</code></p>

<p>Promise 的生命週期</p>

<ul>
<li><code>pending</code> - 等待中的初始狀態</li>
<li><code>fulfillment</code> - 完成</li>
<li><code>rejecttion</code> - 失敗</li>
</ul>


<pre><code class="js">// Callback
const getDataCallBack = callback =&gt; {
  setTimeout(() =&gt; {
    callback(undefined, 'This is the callback data')
  }, 2000)
}

getDataCallBack((err, data) =&gt; {
  if (err) {
  } else {
    console.log(data)
  }
})

// Promise
const myPromise = new Promise((resolve, reject) =&gt; {
  setTimeout(() =&gt; {
    // 成功做什麼事
    resolve('This is the promise resolve')
    // 失敗做什麼事
    reject('This is the promise reject')
  }, 2000)
})

myPromise.then(
  data =&gt; {
    console.log(data)
  },
  err =&gt; {
    console.log(err)
  }
)
</code></pre>

<h3>Promise chain</h3>

<p>用 <code>catch</code> 取代 error handler <code>err =&gt; {}</code></p>

<pre><code class="js">const getDataPromise = num =&gt;
  new Promise((resolve, reject) =&gt; {
    setTimeout(() =&gt; {
      typeof num === 'number' ? resolve(num * 2) : reject('Number must be provided')
    }, 2000)
  })

getDataPromise(10)
  .then(data =&gt; {
    getDataPromise(data)
      .then(data =&gt; {
        console.log(data) // 40
      })
      .catch(err =&gt; {
        console.log(err)
      })
  })
  .catch(err =&gt; {
    console.log(err)
  })

// better way
getDataPromise(10)
  .then(data =&gt; {
    return getDataPromise(data)
  })
  .then(data =&gt; {
    console.log(data) // 40
  })
  .catch(err =&gt; {
    console.log(err)
  })
</code></pre>

<p>也有一些非同步模式的變體可以使用</p>

<ul>
<li><code>Promise.all</code>: 等所有都完成再進行下一步</li>
<li><code>Promise.race</code>: 只要一個先完成就進行下一步</li>
</ul>


<h3>fetch</h3>

<p><code>fetch</code> 會回傳 <code>promise object</code>，因此也可以用 <code>then</code> 去接</p>

<pre><code class="js">const fetch = require('node-fetch')

fetch('http://puzzle.mead.io/puzzle', {})
  .then(response =&gt; {
    if (response.status === 200) {
      return response.json()
    } else {
      throw new Error('Unable to fetch the puzzle')
    }
  })
  .then(data =&gt; {
    console.log(data.puzzle)
  })
  .catch(error =&gt; {
    console.log(error)
  })
</code></pre>

<ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise">Promise</a></li>
<li><a href="https://developers.google.com/web/fundamentals/primers/promises">JavaScript Promises: an Introduction</a></li>
<li><a href="https://medium.com/@xyz030206/promise-%E4%BB%8B%E7%B4%B9%E8%88%87%E4%BD%BF%E7%94%A8-66605ef56e34">Promise — 介紹與使用</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API">Fetch API</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/API/Response">Response</a></li>
<li><a href="https://cythilya.github.io/2018/10/31/promise/">你懂 JavaScript 嗎？#24 Promise</a></li>
</ul>


<h1><span id="async_await"> Async/Await </span></h1>

<p><code>async function</code> 也會回傳 Promise 的函式</p>

<ul>
<li><code>async</code>: 定義一個 <code>function</code> 為 <code>async</code></li>
<li><code>await</code>: 等待某一 <code>function</code> return 後再繼續執行，必須包在 <code>async</code> 裡面</li>
</ul>


<pre><code class="js">const test = async () =&gt; {}
test() // Promise {&lt;resolved&gt;: undefined}
</code></pre>

<pre><code class="js">const processData = async () =&gt; {
  // throw new Error('error')
  return 'hi'
}

processData()
  .then(data =&gt; {
    console.log(data)
  })
  .catch(error =&gt; {
    console.log(error)
  })
</code></pre>

<pre><code class="js">// node need to require
const fetch = require('node-fetch')

const getPuzzle = async wordCount =&gt; {
  const response = await fetch(`http://puzzle.mead.io/puzzle?wordCount=${wordCount}`)
  if (response.status === 200) {
    const data = await response.json()
    return data.puzzle
  } else {
    throw new Error('Unable to get puzzle')
  }
}
getPuzzle('2')
  .then(puzzle =&gt; {
    console.log(puzzle)
  })
  .catch(err =&gt; {
    console.log(`Error: ${err}`)
  })
</code></pre>

<ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function">async</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/await">await</a></li>
<li><a href="https://noob.tw/js-async/">我要學會 JS(三)：callback、Promise 和 async/await 那些事兒</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JavaScript - Functions, Object, Classes, This, Closures, Array]]></title>
    <link href="https://mgleon08.github.io/blog/2019/07/29/javascript-functions-object/"/>
    <updated>2019-07-29T12:31:12+08:00</updated>
    <id>https://mgleon08.github.io/blog/2019/07/29/javascript-functions-object</id>
    <content type="html"><![CDATA[<!-- more -->


<ul>
<li><a href="#default">Default function parameters</a></li>
<li><a href="#IIFE">立即函示 IIFE(Immediately Invoked Function Expression)</a></li>
<li><a href="#arrow">Arrow Function</a></li>
<li><a href="#this">this 識別字（this Identifier)</a></li>
<li><a href="#closures">Closures 閉包</a></li>
<li><a href="#object">Object</a></li>
<li><a href="#methods">Methods</a></li>
<li><a href="#prototype">Prototype Object</a></li>
<li><a href="#array">Array</a></li>
<li><a href="#constructor">Constructor</a></li>
<li><a href="#classes">Classes</a></li>
</ul>


<h1><span id="default"> Default function parameters </span></h1>

<pre><code class="js">let getScoreText = function (name = 'Anonymous', score = 0) {
  return `${name} Score: ${score}`
}
let text = getScoreText(undefined, 11)
console.log(text) // Anonymous Score: 11
</code></pre>

<ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Default_parameters">Default parameters</a></li>
</ul>


<h1><span id="IIFE"> 立即函示 IIFE(Immediately Invoked Function Expression) </span></h1>

<p>可立刻執行的函示，好處不會污染到 global，在函示後面加上 <code>()</code> 即可</p>

<pre><code class="js">(function() {
  var a = 1
  console.log(a) // 3
})()

a // a is not defined
</code></pre>

<h1><span id="arrow"> Arrow Function <span></h1>

<p>ES6 新增的寫法</p>

<pre><code class="js">const squareLong1 = function(num) {
    return num * num
}
console.log(squareLong1(3))

const squareLong2 = (num) =&gt; {
    return num * num
}
console.log(squareLong2(3))

const squareLong3 = (num) =&gt; num * num
console.log(squareLong3(3))
</code></pre>

<p>Arrow Function don&rsquo;t bind <code>arguments</code></p>

<pre><code class="js">const add1 = function() {
  return arguments[0] + arguments[1]
}

console.log(add1(1, 2)) // 3

const add2 = () =&gt; {
  return arguments[0] + arguments[1]
}

console.log(add2(1, 2))

// [object Object]function require(path) {
//     try {
//       exports.requireDepth += 1;
//       return mod.require(path);
//     } finally {
//       exports.requireDepth -= 1;
//     }
//   }
</code></pre>

<p>Arrow Function don&rsquo;t bind <code>this</code></p>

<p>因為 <code>arrow function</code> 沒有綁定 <code>this</code> 因此會 <code>undefined</code></p>

<pre><code class="js">// arrow function
const pet1 = {
  name: 'Hal',
  getGreeting: () =&gt; {
    return `Hello ${this.name}!`
  }
}
console.log(pet1.getGreeting()) // Hello undefined!

// 原本寫法
const pet2 = {
  name: 'Hal',
  getGreeting: function() {
    return `Hello ${this.name}!`
  }
}
console.log(pet2.getGreeting()) // Hello Hal!

// 原本寫法縮寫
const pet3 = {
  name: 'Hal',
  getGreeting() {
    return `Hello ${this.name}!`
  }
}
console.log(pet3.getGreeting()) // Hello Hal!
</code></pre>

<pre><code class="js">var test = {
  say: 'hi',
  citys: ['a', 'b', 'c'],
  getGreeting: function() {
    this.citys.forEach(function(city) {
        // 這裡的 this 會指向 window
      console.log(this.say);
    });
  }
};

test.getGreeting(); // undefined

var test = {
  say: 'hi',
  citys: ['a', 'b', 'c'],
  getGreeting: function() {
    that = this;
    this.citys.forEach(function(city) {
      console.log(that.say);
    });
  }
};

test.getGreeting(); // hi, hi, hi

var test = {
  say: 'hi',
  citys: ['a', 'b', 'c'],
  getGreeting: function() {
    this.citys.forEach(city =&gt; console.log(this.say));
  }
};

test.getGreeting(); // hi, hi, hi

var test = {
  say: 'hi',
  citys: ['a', 'b', 'c'],
  getGreeting() {
    this.citys.forEach(city =&gt; console.log(this.say));
  }
};
test.getGreeting(); // hi, hi, hi
</code></pre>

<ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions">Arrow_functions</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions#Shorter_functions">Shorter_functions</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Method_definitions#Description">ES6 Method definitions</a></li>
</ul>


<h1><span id="constructor"> Constructor <span></h1>

<p>constructor 的用法就是 <code>function</code> 搭配 <code>new</code> 關鍵字：</p>

<p>可以透過 <code>Constructor function</code> 達成 <code>Object-oriented programming (OOP)</code>，就像是 <code>class</code> 那樣</p>

<pre><code class="js">const Person = function(firstName, lastName, age) {
  this.firstName = firstName
  this.lastName = lastName
  this.age = age
}

const me = new Person('Leon', 'Ji', 27)
// me.[[prototype]] = Person.prototype 實際上會做此連結 hidden internal property
console.log(me) // Person {firstName: "Leon", lastName: "Ji", age: 27}
</code></pre>

<ul>
<li>建議使用大寫開頭</li>
<li>透過 <code>new</code> 建立新的 instance</li>
</ul>


<h3>new 會進行以下操作</h3>

<ul>
<li>建立一個物件（<code>{}</code>)</li>
<li>將這個新物件的 constructor 屬性設為另一個物件(<code>Person</code>)</li>
</ul>


<pre><code class="js">me.constructor == Person // true
me instanceof Person // true
</code></pre>

<ul>
<li>讓新物件繼承 <code>Person.prototype</code></li>
</ul>


<pre><code class="js">Person.prototype.say = 'hi'
me.say // hi
</code></pre>

<ul>
<li>如果該函式沒有返回物件，則返回 this</li>
</ul>


<p>這裡的 <code>this</code> 就是 <code>Person</code></p>

<ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/new">new</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Working_with_Objects#Using_a_constructor_function">Using a constructor function</a></li>
<li><a href="https://andyyou.github.io/2016/09/22/js-contrstructors-prototypes-new/">筆記 Javascript 的 constructors, prototypes, new 關鍵字</a></li>
</ul>


<h1><span id="classes"> Classes <span></h1>

<p>後來出的新語法 <code>class</code>，讓原本的 <code>function</code> 寫法更乾淨，更像 OOP 一點</p>

<pre><code class="js">class Person {
  constructor(firstName, lastName, age, likes = []) {
    this.firstName = firstName
    this.lastName = lastName
    this.age = age
    this.likes = likes
  }

  getBio() {
    let bio = `${this.firstName} is ${this.age}.`
    this.likes.forEach(like =&gt; {
      bio += ` ${this.firstName} likes ${like}.`
    })
    return bio
  }

  setName(fullName) {
    const name = fullName.split(' ')
    this.firstName = name[0]
    this.lastName = name[1]
  }
}

const me = new Person('Leon', 'Ji', 27, ['Teaching', 'Biking'])
console.log(me.getBio())
const person2 = new Person('Clancey', 'Turner', 51)
person2.setName('Leon Ji')
console.log(person2.getBio())

// Leon is 27. Leon likes Teaching. Leon likes Biking.
// Leon is 51.
</code></pre>

<h3>Subclass</h3>

<p>可以在建立一個 class，去繼承其他的 class</p>

<pre><code class="js">// stu -&gt; Student.prototype -&gt; Person.prototype -&gt; Object.prototype -&gt; null

class Student extends Person {
  constructor(firstName, lastName, age, grade, likes) {
    // super 用於 call 上層的 constructor
    super(firstName, lastName, age, likes)
    this.grade = grade
  }
  updateGrade(change) {
    this.grade += change
  }
  getBio() {
    const status = this.grade &gt;= 70 ? 'passing' : 'failing'
    return `${this.firstName} is ${status} the class.`
  }
}

const stu = new Student('Leon', 'Ji', 27, 50, ['Teaching', 'Biking'])
console.log(stu.getBio())
student.updateGrade(50)
console.log(stu.getBio())

// Leon is failing the class.
// Leon is passing the class.
</code></pre>

<h3>getter &amp; setter</h3>

<ul>
<li>The <code>get</code> syntax binds an object property to a function that will be called when that property is looked up.</li>
<li>The <code>set</code> syntax binds an object property to a function to be called when there is an attempt to set that property.</li>
</ul>


<p>執行時，就跟變數一樣，不需加上 <code>()</code></p>

<pre><code class="js">const human = {
  firstName: 'Leon',
  lastName: 'Ji',
  get name() {
    return `${this.firstName} ${this.lastName}`
  },
  set name(name) {
    const names = name.trim().split(' ')
    this.firstName = names[0]
    this.lastName = names[1]
  }
}
human.name = ' Leon Ji '
console.log(human.firstName) // Leon
console.log(human.lastName) // Ji
</code></pre>

<ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes">Classes</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes/extends">extends</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/get">getter</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/set">setter</a></li>
</ul>


<h1><span id="this"> this 識別字（this Identifier) <span></h1>

<p>this 是 function 執行時所屬的物件，而 this 是在執行時期做繫結，其值和函式在哪裡被呼叫（call-site）有關。</p>

<pre><code class="js">function foo() {
  console.log(this.bar)
}

var bar = 'global'

var obj1 = {
  bar: 'obj1',
  foo: foo
}

var obj2 = {
  bar: 'obj2'
}

foo() // 'global'
obj1.foo() // 'obj1'
foo.call(obj2) // 'obj2'
new foo() // undefined
</code></pre>

<p>匹配的優先順序由高至低排列</p>

<ol>
<li>new 繫結：<code>this</code> 會指向 <code>new</code> 出來的物件。

<ul>
<li><code>new foo()</code> sets <code>this</code> to a brand new empty object.</li>
</ul>
</li>
<li>明確繫結：使用 <code>call</code>、<code>apply</code>、<code>bind</code>，明確指出要繫結給 <code>this</code> 的物件。

<ul>
<li><code>foo.call(obj2)</code> sets <code>this</code> to the <code>obj2</code> object.</li>
</ul>
</li>
<li>隱含繫結：當函式為物件的方法（method）時，在執行階段 <code>this</code> 就會被繫結至該物件。

<ul>
<li><code>obj1.foo()</code> sets <code>this</code> to the <code>obj1</code> object.</li>
</ul>
</li>
<li>預設繫結：當其他規則都不適用時，意即沒有使用 <code>call</code>、<code>apply</code>、<code>bind</code> 或不屬於任何物件的 method，就套用預設繫結，在非嚴格模式下，瀏覽器環境 <code>this</code> 的值就是預設值全域物件 window，而在嚴格模式下，<code>this</code> 的值就是 <code>undefined</code>。</li>
</ol>


<h3>重點是誰呼叫它</h3>

<pre><code class="js">function callName() {
  console.log(this.name);
}
var name = 'global leon';
var say = {
  name: 'leon',
  callName: callName  
  // 這裡的 function 指向全域的 function，但不重要
}
callName()     // global leon
say.callName() // leon
</code></pre>

<h3>透過 bind 綁定正確的 context</h3>

<pre><code class="js">const obj = {
  name: 'foobar',
  getName() {
    return this.name;
  }
};

console.log(obj.getName()); // foobar
const getName = obj.getName;
console.log(getName()); // error
const getNameWithBind = obj.getName.bind(obj);
console.log(getNameWithBind()); // foobar
</code></pre>

<ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this">this</a></li>
<li><a href="https://cythilya.github.io/2018/10/10/intro-2/">你懂 JavaScript 嗎？#3 暖身 (๑•̀ㅂ•́)و✧ Part 2 - 變數、嚴格模式、IIFEs、閉包、模組、this、原型、Polyfill 與 Transpiler</a></li>
<li><a href="https://github.com/getify/You-Dont-Know-JS/blob/master/up%20%26%20going/ch2.md#this-identifier">this-identifier</a></li>
<li><a href="https://wcc723.github.io/javascript/2017/12/12/javascript-this/">鐵人賽：JavaScript 的 this 到底是誰？</a></li>
</ul>


<h1><span id="closures"> Closures 閉包 <span></h1>

<blockquote><p>A closure is the combination of a function and the lexical environment within which that function was declared.</p></blockquote>

<p>閉包 (Closure) 是一種特殊的函式，他能夠存取被宣告當下的環境中的變數。</p>

<pre><code class="js">const createCounter = () =&gt; {
  let count = 0
  return () =&gt; {
    return count
  }
}
const counter = createCounter()
console.log(counter()) // 0
</code></pre>

<pre><code class="js">// return 一個 function，baseTip 已被存取
const createTipper = baseTip =&gt; {
  return amount =&gt; {
    return baseTip * amount
  }
}

const tip20 = createTipper(0.2)
const tip30 = createTipper(0.3)
console.log(tip20(100)) // 20
console.log(tip20(80))  // 16
console.log(tip30(100)) // 30
</code></pre>

<pre><code class="js">var a = 100
function echo() {
  console.log(a)
}

function test() {
  var a = 200
  echo()
}

test() // 100
</code></pre>

<ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures">Closures</a></li>
<li><a href="http://shubo.io/javascript-closure/">[教學] 史上最簡單！3分鐘看懂JavaScript閉包 (Closure)</a></li>
<li><a href="https://blog.techbridge.cc/2018/12/08/javascript-closure/">所有的函式都是閉包：談 JS 中的作用域與 Closure</a></li>
</ul>


<h1><span id="object"> Object <span></h1>

<pre><code class="js">let myBook = {
    title: '1984',
    author: 'George Orwell',
    pageCount: 326
}

console.log(`${myBook.title} by ${myBook.author}`)
myBook.title = 'Leon'
console.log(myBook)
</code></pre>

<ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object">Object</a></li>
</ul>


<h1>Object Reference</h1>

<p>output 出相同的值，因為 function 裡的 object 是 reference 到同一個 memory，</p>

<pre><code class="js">let myAccount = {
    name: 'Leon',
    expenses: 0,
    income: 0
}
let addExpense = function (account, amount) {
  account.expenses = account.expenses + amount
  console.log(account) // {name: "Leon", expenses: 2000, income: 0}
}
addExpense(myAccount, 2000)
console.log(myAccount) // {name: "Leon", expenses: 2000, income: 0}
</code></pre>

<p>但是當 assign 一個新的 object 給 account，就會是不一樣的 object</p>

<pre><code class="js">// Both logs print differen things
let myAccount = {
    name: 'Leon',
    expenses: 0,
    income: 0
}
let addExpense = function (account, amount) {
    account = {}
    account.age = 1
    console.log(account) // {age: 1}
}

addExpense(myAccount, 2000)
console.log(myAccount) // {name: "Leon", expenses: 0, income: 0}
</code></pre>

<h1><span id="methods"> Methods <span></h1>

<pre><code class="js">let restaurant = {
  name: 'ASB',
  guestCapacity: 75,
  guestCount: 0,
  checkAvailability: function(partySize) {
    let seatsLeft = this.guestCapacity - this.guestCount
    return partySize &lt;= seatsLeft
  }
}
console.log(restaurant.checkAvailability(4))
</code></pre>

<p>String methods</p>

<pre><code class="js">let name = 'Leon'
console.log(name.length)
console.log(name.toUpperCase())
console.log(name.toLowerCase())

let password = 'abc123asdf098'
console.log(password.includes('password'))
</code></pre>

<p>Number &amp; Math methods</p>

<pre><code class="js">let num = 103.941
console.log(num.toFixed(2))

console.log(Math.round(num))
console.log(Math.floor(num))
console.log(Math.ceil(num))

let min = 0
let max = 1
let randomNum = Math.floor(Math.random() * (max - min + 1)) + min
</code></pre>

<ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String">String methods</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number">Number methods</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math">Math methods</a></li>
</ul>


<h1><span id="prototype"> Prototype Object <span></h1>

<p>Prototype 可說是物件的一種 fallback 機制，當在此物件找不到指定屬性時，就會透過原型鏈結（prototype link / prototype reference）追溯到其父物件上。</p>

<p>透過 <code>prototype</code> 可以 shared 給每個 <code>instance</code>，因為 <code>instance</code> 都是繼承自 <code>prototype property</code></p>

<p>以下 <code>new</code> 出來的 instance 都繼承自 <code>Person prototype</code></p>

<pre><code class="js">const Person = function(firstName, lastName, age, likes = []) {
  this.firstName = firstName
  this.lastName = lastName
  this.age = age
  this.likes = likes
}

Person.prototype.getBio = function() {
  let bio = `${this.firstName} is ${this.age}.`
  this.likes.forEach(like =&gt; {
    bio += ` ${this.firstName} likes ${like}.`
  })

  return bio
}

Person.prototype.setName = function(fullName) {
  const name = fullName.split(' ')
  this.firstName = name[0]
  this.lastName = name[1]
}

const me = new Person('Leon', 'Ji', 27, ['Teaching', 'Biking'])
// me.[[prototype]] = Person.prototype 實際上會做此連結 hidden internal property
console.log(me.getBio())
const person2 = new Person('Clancey', 'Turner', 51)
person2.setName('Leon Ji')
console.log(person2.getBio())
</code></pre>

<p>所有 object 都有 <code>hasOwnProperty</code> 是因爲都繼承自 <code>Object.prototype</code></p>

<pre><code class="js">// myObject --&gt; Object.prototype --&gt; null
const myObject = {} console.log(myObject.hasOwnProperty('doesNotExist'))

// 因為 myObject 本身並沒有 hasOwnProperty，而是繼承而來
myObject.hasOwnProperty('hasOwnProperty') // false
// __proto__ 上一層
myObject.__proto__.hasOwnProperty('hasOwnProperty') // true
</code></pre>

<p>基本型別 Primitives values 的 prototype</p>

<p><code>string</code>, <code>number</code>, <code>boolean</code>, <code>undefined</code>, <code>null</code></p>

<pre><code class="js">// Array: myArray --&gt; Array.prototype --&gt; Object.prototype --&gt; null
// Function: myFunc --&gt; Function.prototype --&gt; Object.prototype --&gt; null
// String: myString --&gt; String.prototype --&gt; Object.prototype --&gt; null
// Number: myNumber --&gt; Number.prototype --&gt; Object.prototype --&gt; null
// Boolean: myBoolean --&gt; Boolean.prototype --&gt; Object.prototype --&gt; null
</code></pre>

<ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Inheritance_and_the_prototype_chain">Inheritance and the prototype chain</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/prototype">Object prototype</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/prototype">Array.prototype</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/prototype">Function.prototype</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/prototype">String.prototype</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/prototype">Number.prototype</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean/prototype">Boolean.prototype</a></li>
</ul>


<h1><span id="array"> Array <span></h1>

<pre><code class="js">const nums = [1]
nums.push(12)
nums.unshift(3)
console.log(nums) // [3, 1, 12]

nums.pop()
console.log(nums) // [3, 1]

nums.shift()
console.log(nums) // [1]

nums.splice(1, 0, 2)
console.log(nums) // [1, 2]
nums.splice(1, 0, 3)
console.log(nums) // [1, 3, 2]
nums.splice(1, 2, 99)
console.log(nums) // [1, 99]
</code></pre>

<h3>forEach</h3>

<pre><code class="js">const todos = ['Order cat food', 'Clean kitchen', 'Buy food', 'Do work', 'Exercise']

todos.forEach(function (todo, index) {
    const num = index + 1
    console.log(`${num}. ${todo}`)
})

for (let num = 1; num &lt;= todos.length ; num++) {
  console.log(`${num}. ${todos[num]}`)
}
</code></pre>

<h3>indexOf</h3>

<pre><code class="js">const places = ['a', 'b', 'c']
const index = places.indexOf('c')
console.log(index) // 2
const index2 = places.indexOf('d')
console.log(index2) // -1

// 無法用在 object 因為 {} === {} false，兩個 object 會是不同的 memory
const testObject = [{}]
console.log(testObject.indexOf({})) // -1
</code></pre>

<h3>findIndex</h3>

<p>for object should use <code>findIndex</code></p>

<pre><code class="js">const notes = [
  {
    title: 'My next trip',
    body: 'I would like to go to Spain'
  },
  {
    title: 'Habbits to work on',
    body: 'Exercise. Eating a bit better.'
  },
  {
    title: 'Office modification',
    body: 'Get a new seat'
  }
]
const index = notes.findIndex(function(note, index) {
  return note.title === 'Habbits to work on'
})
console.log(index) // 1
</code></pre>

<h3>find</h3>

<pre><code class="js">const notes = [
  {
    title: 'My next trip',
    body: 'I would like to go to Spain'
  },
  {
    title: 'Habbits to work on',
    body: 'Exercise. Eating a bit better.'
  },
  {
    title: 'Office modification',
    body: 'Get a new seat'
  }
]
const findNote = function(notes, noteTitle) {
  return notes.find(function(note, index) {
    return note.title.toLowerCase() === noteTitle.toLowerCase()
  })
}
const note = findNote(notes, 'my next trip')
console.log(note) // Will print the first object from our array above
</code></pre>

<h3>filter</h3>

<pre><code class="js">var words = ['spray', 'limit', 'elite', 'exuberant', 'destruction', 'present'];

const result = words.filter(word =&gt; word.length &gt; 6);

console.log(result);
// expected output: Array ["exuberant", "destruction", "present"]
</code></pre>

<pre><code class="js">const todos = [
  {
    text: 'Order cat food',
    completed: false
  },
  {
    text: 'Clean kitchen',
    completed: true
  },
  {
    text: 'Do work',
    completed: false
  }
]
const getThingsToDo = function(todos) {
  return todos.filter(function(todo) {
    return !todo.completed
  })
}
console.log(getThingsToDo(todos))
</code></pre>

<h3>sorting</h3>

<pre><code class="js">var months = ['March', 'Jan', 'Feb', 'Dec']
months.sort()
console.log(months)
// expected output: Array ["Dec", "Feb", "Jan", "March"]

var array1 = [1, 30, 4, 21, 100000]
array1.sort()
console.log(array1)
// expected output: Array [1, 100000, 21, 30, 4]
</code></pre>

<pre><code class="js">const todos = [
  {
    text: 'Buy food',
    completed: true
  },
  {
    text: 'Do work',
    completed: false
  },
  {
    text: 'Exercise',
    completed: true
  }
]
const sortTodos = function(todos) {
  todos.sort(function(a, b) {
    if (!a.completed &amp;&amp; b.completed) {
      return -1
    } else if (!b.completed &amp;&amp; a.completed) {
      return 1
    } else {
      return 0
    }
  })
}
sortTodos(todos)
console.log(todos)
</code></pre>

<h3>Rest Parameter</h3>

<pre><code class="js">const calculateAverage = (...numbers) =&gt; {
  let sum = 0
  numbers.forEach(num =&gt; (sum += num))
  return sum / numbers.length
}
console.log(calculateAverage(0, 100, 88, 64)) // Will print: 63
</code></pre>

<pre><code class="js">const printTeam = (teamName, coach, ...players) =&gt; {
  console.log(`Team: ${teamName}`)
  console.log(`Coach: ${coach}`)
  console.log(`Players: ${players.join(', ')}`)
}
printTeam('Liberty', 'Casey Penn', 'Marge', 'Aiden', 'Herbert', 'Sherry')
</code></pre>

<h3>Spread Syntax</h3>

<pre><code class="js">const printTeam = (teamName, coach, ...players) =&gt; {
  console.log(`Team: ${teamName}`)
  console.log(`Coach: ${coach}`)
  console.log(`Players: ${players.join(', ')}`)
}
const team = {
  name: 'Libery',
  coach: 'Casey Penn',
  players: ['Marge', 'Aiden', 'Herbert', 'Sherry']
}
printTeam(team.name, team.coach, ...team.players)
</code></pre>

<pre><code class="js">let cities = ['Barcelona', 'Cape Town', 'Bordeaux']
let citiesClone = [...cities, 'Santiago']
console.log(cities)
console.log(citiesClone)

// [ 'Barcelona', 'Cape Town', 'Bordeaux' ]
// [ 'Barcelona', 'Cape Town', 'Bordeaux', 'Santiago' ]
</code></pre>

<ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array">Array</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/rest_parameters">Rest parameters</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax">Spread syntax</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JavaScript - Flow Control]]></title>
    <link href="https://mgleon08.github.io/blog/2019/07/28/javascript-flow-control/"/>
    <updated>2019-07-28T12:29:41+08:00</updated>
    <id>https://mgleon08.github.io/blog/2019/07/28/javascript-flow-control</id>
    <content type="html"><![CDATA[<!-- more -->


<ul>
<li><a href="#booleans">Booleans - Truthy &amp; Falsy</a></li>
<li><a href="#comparison">Comparison Operators</a></li>
<li><a href="#if">if&hellip;else</a></li>
<li><a href="#switch">switch</a></li>
<li><a href="#loop">loop</a></li>
<li><a href="#logical">邏輯運算子 Logical operators</a></li>
<li><a href="#bitwise">位元運算子 Bitwise operators</a></li>
<li><a href="#catch_error">Catching and Throwing Errors</a></li>
</ul>


<h1><span id="booleans"> Booleans - Truthy &amp; Falsy <span></h1>

<p>以下 6 個為 <code>Falsy</code> 其他都是 <code>Truthy</code></p>

<pre><code class="js">// Falsy
false
0, -0
""
null
undefined
NaN
</code></pre>

<pre><code class="js">// Truthy
'Hello World'
8
[], [1, 2, 3]
{}, { name: 'leon' }
function foo() {}
true
...
</code></pre>

<p>可以用 <code>!!</code> 來做確認</p>

<pre><code class="js">!!""
// false
!![]
// true
!!0
// false
</code></pre>

<ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean">Boolean</a></li>
</ul>


<h1><span id="comparison"> Comparison Operators <span></h1>

<ul>
<li><code>===</code>：不做轉型，因此型別對比較是有影響的。</li>
<li><code>==</code>：會強制轉型

<ul>
<li>布林轉數字</li>
<li>字串轉數字</li>
<li>使用 <code>valueOf()</code> 或 <code>toString()</code> 將物件取得基本型別的值，再做比較</li>
</ul>
</li>
</ul>


<pre><code class="js">1 == 1.0          // true
'1' == 1          // true
'1' == 1.0        // true
null == undefined // true
NaN == NaN        // false
{} == {}          // false
[] == []          // false

1 === 1.0          // true
'1' === 1          // false
'1' === 1.0        // false
null === undefined // false
NaN === NaN        // false
{} === {}          // false
[] === []          // false

// reference same memory (object, array)
a = {}
b = a
a == b // true
a === b // true
</code></pre>

<pre><code class="js">// 字串以字典的字母順序為主
'ab' &lt; 'cd' // true
// 字串 '99' 被強制轉型為數字 99
'99' &gt; 98 // true
// 字串 'Hello World' 無法轉為數字，變成 NaN
'Hello World' &gt; 1 // false
</code></pre>

<ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Comparison_Operators">Comparison operators</a></li>
</ul>


<h1><span id="if"> if&hellip;else <span></h1>

<pre><code class="js">let age = 26
let isChild = age &lt;= 7
let isSenior = age &gt;= 65

if (isChild) {
  console.log('Welcome! You are free.')
} else if (isSenior) {
  console.log('Welcome! You get a discount.')
} else {
  console.log('Welcome!')
}
</code></pre>

<h3>三元運算 Condition Ternary Operator</h3>

<pre><code class="js">function getFee(isMember) {
  return isMember ? '$2.00' : '$10.00'
}

console.log(getFee(true)) // "$2.00"
console.log(getFee(false)) // "$10.00"
console.log(getFee(1)) // "$2.00"
</code></pre>

<ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/if...else">if&hellip;else</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Conditional_Operator">Conditional Operator</a></li>
</ul>


<h1><span id="switch"> switch <span></h1>

<ul>
<li><code>break</code> - 如果不加的話會繼續執行下去</li>
<li><code>default</code> - 如果上面都沒有執行，就會執行這行</li>
</ul>


<pre><code class="js">var expr = 'Papayas'
switch (expr) {
  case 'Oranges':
    console.log('Oranges are $0.59 a pound.')
    break
  case 'Mangoes':
  case 'Papayas':
    console.log('Mangoes and papayas are $2.79 a pound.')
    // expected output: "Mangoes and papayas are $2.79 a pound."
    break
  default:
    console.log('Sorry, we are out of ' + expr + '.')
}
</code></pre>

<ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/switch">switch</a></li>
</ul>


<h1><span id="loop"> loop <span></h1>

<h3>for</h3>

<pre><code class="js">let str = ''

for (var i = 0; i &lt; 9; i++) {
  str = str + i
}

console.log(str) // "012345678"
</code></pre>

<h3>for..in</h3>

<pre><code class="js">var string1 = ''
var object1 = { a: 1, b: 2, c: 3 }

for (var property1 in object1) {
  string1 += object1[property1]
}

console.log(string1) // "123"
</code></pre>

<h3>while</h3>

<pre><code class="js">var n = 0

while (n &lt; 3) {
  n++
}

console.log(n) // 3
</code></pre>

<h3>do..while</h3>

<pre><code class="js">var result = ''
var i = 0

do {
  i = i + 1
  result = result + i
} while (i &lt; 5)

console.log(result) // "12345"
</code></pre>

<ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for">for</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...in">for&hellip;in</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/while">while</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/do...while">do&hellip;while</a></li>
</ul>


<h1><span id="logical"> 邏輯運算子 Logical operators <span></h1>

<pre><code class="js">var a = 3
var b = -2

console.log(a &gt; 0 &amp;&amp; b &gt; 0) // false
console.log(a &gt; 0 || b &gt; 0) // true
console.log(!(a &gt; 0 || b &gt; 0)) // false
</code></pre>

<ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Logical_Operators">Logical operators</a></li>
</ul>


<h1><span id="bitwise"> 位元運算子 Bitwise operators <span></h1>

<p>將運算元轉乘 32 位元的 0 和 1，<code>&amp;</code> 兩個都是 1 就是 1，<code>|</code> 一個是 1 才是 1，最後在轉換成數字</p>

<pre><code class="js">console.log(5 &amp; 13) // 0101 &amp; 1101 = 0101
// 5

console.log(parseInt('0101', 2) &amp; parseInt('1101', 2))
// 5

console.log(5 &amp; 13 &amp; 3) // 0101 &amp; 1101 &amp; 0011 = 0001
// 1

console.log(5 | 13) // 0101 | 1101 = 1101
// 13
</code></pre>

<ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Bitwise_Operators">Bitwise operators</a></li>
</ul>


<h1><span id="catch_error"> Catching and Throwing Errors <span></h1>

<ul>
<li><code>try..catch</code>: 捕獲 <code>error</code>，嘗試做其他處理</li>
<li><code>throw</code>: 拋出 <code>error</code></li>
</ul>


<pre><code class="js">const getTip = amount =&gt; {
  if (typeof amount !== 'number') {
    throw Error('Argument must be a number')
  }
  return amount * 0.25
}

try {
  const result = getTip('12')
  console.log(result)
} catch (e) {
  console.log(e.message) // Argument must be a number
}
</code></pre>

<ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/try...catch">try&hellip;catch</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
