<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Ruby | Leon's Blogging]]></title>
  <link href="http://mgleon08.github.com/blog/categories/ruby/atom.xml" rel="self"/>
  <link href="http://mgleon08.github.com/"/>
  <updated>2016-07-17T20:03:23+08:00</updated>
  <id>http://mgleon08.github.com/</id>
  <author>
    <name><![CDATA[LeonJi]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Garbage Collection (GC)]]></title>
    <link href="http://mgleon08.github.com/blog/2016/06/10/garbage-collection/"/>
    <updated>2016-06-10T12:18:42+08:00</updated>
    <id>http://mgleon08.github.com/blog/2016/06/10/garbage-collection</id>
    <content type="html"><![CDATA[<p>在 ruby 當中，經常會看到 : 的符號，代表 symbol</p>

<!-- more -->


<p>跟一般 string 的差異在於</p>

<ul>
<li>同樣的 string，會產生不同的 記憶體</li>
<li>同樣的 symbol，一樣的記憶體</li>
</ul>


<pre><code class="ruby">3.times do
  puts "foo".object_id
end
#=&gt;70302331020060
#=&gt;70302331019980
#=&gt;70302331019920

3.times do
  puts :foo.object_id
end
#=&gt;1091868
#=&gt;1091868
#=&gt;1091868

#將字串 freeze 起來，object_id 也會是一樣
3.times do
  puts "foo".freeze.object_id
end
#=&gt;70172682147320
#=&gt;70172682147320
#=&gt;70172682147320
</code></pre>

<h1>Garbage Collection</h1>

<ul>
<li><p>在 ruby 2.2 之前，symbol 所佔用的記憶體沒辦法被自動回收，要釋放就必須重啟動程式，因此會造成 memory leak 的問題</p></li>
<li><p>但在 2.2 之後，Symbol GC(Garbage Collection) ，那些動態用 to_sym 或 intern 長出來的 Symbol 就可以跟一般物件一樣被回收了。</p></li>
</ul>


<h3>ruby2.1</h3>

<pre><code class="ruby"># Ruby 2.1
before = Symbol.all_symbols.size
100_000.times do |i|
  "sym#{i}".to_sym
end
GC.start
after = Symbol.all_symbols.size
puts after - before
# =&gt; 100001
</code></pre>

<h3>ruby 2.2</h3>

<pre><code class="ruby"># Ruby 2.2
before = Symbol.all_symbols.size
100_000.times do |i|
  "sym#{i}".to_sym
end
GC.start
after = Symbol.all_symbols.size
puts after - before
# =&gt; 1
</code></pre>

<p>參考文件：<br/>
<a href="http://kaochenlong.com/2016/04/25/string-and-symbol/">Ruby 語法放大鏡之「有的變數變前面有一個冒號(例如 :name)，是什麼意思?」</a><br/>
<a href="https://www.sitepoint.com/symbol-gc-ruby-2-2/">Symbol GC in Ruby 2.2</a><br/>
<a href="http://grantcss.com/blog/2015/01/26/symbol-gc-in-ruby-2-dot-2/">[译] 在 Ruby 2.2 中的 Symbol GC</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Class Macro (Ruby’s Declarative Style)]]></title>
    <link href="http://mgleon08.github.com/blog/2016/06/09/class-macro/"/>
    <updated>2016-06-09T20:14:09+08:00</updated>
    <id>http://mgleon08.github.com/blog/2016/06/09/class-macro</id>
    <content type="html"><![CDATA[<p>Class Macro 就是在 rails 的 ActiveRecord 中，經常會看到，<code>validates</code> <code>belongs_to</code> <code>hsa_manay</code> 等等的宣告</p>

<!-- more -->


<pre><code class="ruby">class User &lt; ActiveRecord::Base
  validates  :name, presence: true
  belongs_to :group
  has_many   :posts
end
</code></pre>

<p>範例:</p>

<pre><code class="ruby">module ActiveRecord
  class Base
    def self.has_many(name)
      puts "#{self} has many #{name}"

      #定義 Dynamic method
      define_method(name) do
        puts "Select * From #{name} Where.."
        puts "Return #{name}"
        []
      end
    end
  end
end

class Movie &lt; ActiveRecord::Base
  #self.has_many(:reviews)
  has_many :reviews
  has_many :genres
end

class Project &lt; ActiveRecord::Base
  has_many :tasks
end

movie = Movie.new
movie.reviews
project = Project.new
project.tasks

#=&gt;Movie has many reviews
#=&gt;Movie has many genres
#=&gt;Project has many tasks
#=&gt;Select * From reviews Where..
#=&gt;Return reviews
#=&gt;Select * From tasks Where..
#=&gt;Return tasks
</code></pre>

<p>之前有寫過
<a href="http://mgleon08.github.io/blog/2016/04/19/dynamic-classes-and-methods/">Dynamic Classes &amp; Methods</a></p>

<p>另一個範例，可以動態的將取出來的值做改變</p>

<pre><code class="ruby">module Precentage
  def transform(*columns, precentage: nil)
    columns.each do |column|
      #這裡做了 alias_method 主要是希望，如果想知道原本的價錢，還可以呼叫 xx_origin
      alias_method "#{column}_origin", column
      if precentage
        #動態產生新的 method 去取代原本
        define_method(column) do
          send(precentage) * send("#{column}_origin")
        end
      end
    end
  end
end

class Book
  extend Precentage
  attr_reader :price, :precentage

  def initialize(options)
    @price      = options[:price]
    @precentage = options[:precentage]
  end

  transform :price, precentage: :precentage
end

book = Book.new(price: 100, precentage:0.8)
puts book.precentage
puts book.price
puts book.price_origin

#=&gt; 0.8
#=&gt; 80.0
#=&gt; 100
</code></pre>

<p>參考文件：<br/>
<a href="https://pragmaticstudio.com/blog/2015/4/14/ruby-macros">How To Write &ldquo;Macros&rdquo; in Ruby</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ruby Range]]></title>
    <link href="http://mgleon08.github.com/blog/2016/06/09/ruby-range/"/>
    <updated>2016-06-09T20:13:54+08:00</updated>
    <id>http://mgleon08.github.com/blog/2016/06/09/ruby-range</id>
    <content type="html"><![CDATA[<p>經常會使用 range 去判斷某個值，是否在某個區間<br/>
ruby 也提供很多好用的方法去判斷，cover?, include? 等等</p>

<!-- more -->


<h1>Range</h1>

<pre><code class="ruby">#... 不包含結尾
(-1..-5).to_a      #=&gt; []
(-5..-1).to_a      #=&gt; [-5, -4, -3, -2, -1]
('a'..'e').to_a    #=&gt; ["a", "b", "c", "d", "e"]
('a'...'e').to_a   #=&gt; ["a", "b", "c", "d"]

(0..2) == Range.new(0,2)    #=&gt; true
(0..2) == (0...2)           #=&gt; false
</code></pre>

<h1>begin/end first/last</h1>

<pre><code class="ruby">r1 = 3..6
r2 = 3...6
r1a, r1b = r1.first, r1.last    #=&gt; 3, 6
r1c, r1d = r1.begin, r1.end     #=&gt; 3, 6
r2a, r2b = r2.begin, r2.end     #=&gt; 3, 6 (注意：不是3和5)
r1.first(2)                     #=&gt; [3, 4]
</code></pre>

<h1>step</h1>

<p>從 0..20 中取出 0，5，10，20</p>

<pre><code class="ruby">a = 0..20
a.step(5).to_a
#=&gt; [0, 5, 10, 15, 20]
</code></pre>

<h1>include?/cover?</h1>

<p>判斷值，是否在 range 當中</p>

<pre><code class="ruby">r = 1 .. 5
r.include?(1)     #=&gt; true
r.include?(0)     #=&gt; false
r.cover?(1)       #=&gt; true
r.cover?(0)       #=&gt; false

("a".."z").include?("ab")     # =&gt; false 
("a".."z").cover?("ab")       # =&gt; true 
</code></pre>

<p>主要差異是</p>

<ul>
<li>include? 會將所有值一一拿出來做比對，因此效率較差</li>
<li>cover?   只會取出開頭和結尾，去比對，值 > 開頭 &amp;&amp; 值 &lt;= 結尾，效能比較好</li>
</ul>


<p>官方文件：<br/>
<a href="http://ruby-doc.org/core-1.9.3/Range.html">ruby-doc Range</a></p>

<p>參考文件：<br/>
<a href="http://stackoverflow.com/questions/21608935/what-is-the-difference-between-rangeinclude-and-rangecover">What is the difference between Range#include? and Range#cover? ?</a>  <br/>
<a href="https://blog.8thlight.com/makis-otman/2014/09/03/setting-date-ranges-in-ruby.html">Apprentice Blog of the Week: Setting Date Ranges in Ruby</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Default Args]]></title>
    <link href="http://mgleon08.github.com/blog/2016/05/29/default-args/"/>
    <updated>2016-05-29T20:22:19+08:00</updated>
    <id>http://mgleon08.github.com/blog/2016/05/29/default-args</id>
    <content type="html"><![CDATA[<p>很常時候，需要給變數一個預設值，因此有以下方法，都可以設定預設值</p>

<!-- more -->


<h1>||</h1>

<p>只要是空值，或是 false, nil 就會回傳後面的預設值</p>

<pre><code class="ruby">h = { "a" =&gt; 100, "b" =&gt; false , 'c' =&gt; nil}
#=&gt; {"a"=&gt;100, "b"=&gt;false, "c"=&gt;nil}
h['a'] || 8
#=&gt; 100
h['b'] || 8
#=&gt; 8
h['c'] || 8
#=&gt; 8
h['d'] || 8
#=&gt; 8
</code></pre>

<h1>fetch</h1>

<p>即使是 nil, false 也會回傳，只有在空值的時候回傳預設值</p>

<pre><code class="ruby">h = { "a" =&gt; 100, "b" =&gt; false , 'c' =&gt; nil}
#=&gt; {"a"=&gt;100, "b"=&gt;false, "c"=&gt;nil}
h.fetch('a', 8)
#=&gt; 100
h.fetch('b', 8)
#=&gt; false
h.fetch('c', 8)
#=&gt; nil
h.fetch('d', 8)
#=&gt; 8
</code></pre>

<h1>merge</h1>

<p>只有在 merge 的參數裡有同樣的值，才會覆蓋掉 default 的值</p>

<pre><code class="ruby">default = { "a" =&gt; 100, "b" =&gt; false , 'c' =&gt; nil }
args    = { "a" =&gt; 8 }

default.merge(args)
#=&gt; {"a"=&gt;8, "b"=&gt;false, "c"=&gt;nil}
</code></pre>

<p>官方文件：<br/>
<a href="http://apidock.com/ruby/Hash/fetch">fetch</a><br/>
<a href="http://apidock.com/ruby/Hash/merge">merge</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Struct vs OpenStruct]]></title>
    <link href="http://mgleon08.github.com/blog/2016/05/29/struct-vs-openstruct/"/>
    <updated>2016-05-29T20:18:53+08:00</updated>
    <id>http://mgleon08.github.com/blog/2016/05/29/struct-vs-openstruct</id>
    <content type="html"><![CDATA[<p>在 ruby 當中，經常會要定義一個新的類別，如果覺得每次都要寫 <code>class xxx</code> 太麻煩，就可以用 struct &amp; OpenStruct 快速的產生出來!</p>

<!-- more -->


<h1>Class</h1>

<pre><code class="ruby">class People
  attr_accessor :name, :phone

  def initialize(name, phone)
    @name  = name
    @phone = phone
  end

  def to_ary
    [name, phone]
  end
end

a = People.new("foo", 1234)
#=&gt; #&lt;People:0x007fcaabcf5328 @name="foo", @phone=1234&gt;
a.name
#=&gt; "foo"
a.phone
#=&gt; 1234
a.to_ary
#=&gt; ["foo", 1234]
</code></pre>

<h1>Struct</h1>

<pre><code class="ruby">#method 要用 block 來傳遞，Attribute 一開始就固定了
People = Struct.new(:name, :phone) do
  def to_ary
    [name, phone]
  end
end
# =&gt; People

a = People.new("foo", 1234)
#=&gt; #&lt;struct People name="foo", phone=1234&gt;
a.name
#=&gt; "foo"
a.phone
#=&gt; 1234
a.to_ary
#=&gt; ["foo", 1234]

也可以直接用繼承的方式
class Test &lt; struct.new(:foo, :bar)
end
</code></pre>

<h3>其他取 Attribute Value 的方法</h3>

<p>Class則無法</p>

<pre><code class="ruby">a[:name]
#=&gt; "foo"
a["name"]
#=&gt; "foo"
a[0]
#=&gt; "foo"
</code></pre>

<h1>OpenStruct</h1>

<p>主要差異點是在於，比 Struct 更有彈性, 因為它可以任意增加 Attribute , 不像 Struct 要先限制好有哪些 Attribute</p>

<p>但比較可惜的是，無法定義 method</p>

<pre><code class="ruby">#在 console 記得先 require
require 'ostruct'

People = OpenStruct.new
#=&gt; #&lt;OpenStruct&gt;
or
People = OpenStruct.new(name: 'foo', phone: 1234)
#=&gt; #&lt;OpenStruct name="foo", phone=1234&gt;

可以自由新增
People.name = 'foo'
#=&gt; "foo"
People.phone = 1234
#=&gt; 1234
People.age = 18
#=&gt; 18
People
#=&gt; #&lt;OpenStruct name="foo", phone=1234, age=18&gt;

也可以直接用繼承的方式
class Test &lt; OpenStruct
end
</code></pre>

<ul>
<li>Struct: 接受的是按順序排列的初始化參數</li>
<li>Openstruct: 接受的則是散列表的參數</li>
</ul>


<h3>WHEN TO USE?</h3>

<ul>
<li>As a temporary data structure 暫時的 data 結構</li>
<li>As internal class data 內部的 class data</li>
</ul>


<blockquote><p>也許另一個 class 還不至於明確到可以獨立成一個 class，因此先暫存在別的 class 裡，直到有明確的行為，足夠讓它獨立出去</p></blockquote>

<pre><code class="ruby">class Person
  Address = Struct.new(:street_1, :street_2, :city)

  attr_accessor :name, :address

  def initialize(name, opts)
    @name = name
    @address = Address.new(opts[:street_1], opts[:street_2], opts[:city])
  end
end

leigh = Person.new("Leigh Halliday", {
  street_1: "123 Road",
  city: "Toronto",
})

puts leigh.address.inspect
# &lt;struct Person::Address street_1="123 Road", street_2=nil, city="Toronto", province="Ontario", country="Canada", postal_code="M5E 0A3"&gt;
</code></pre>

<ul>
<li>As a testing stub</li>
</ul>


<pre><code class="ruby">KCup = Struct.new(:size, :brewing_time, :brewing_temp)
colombian = KCup.new(:small, 60, 85)

brewer = Brewer.new(colombian)
expect(brewer.brew).to eq(true)
</code></pre>

<p>官方文件：<br/>
<a href="http://ruby-doc.org/core-2.2.0/Struct.html">Struct</a><br/>
<a href="http://ruby-doc.org/stdlib-2.0.0/libdoc/ostruct/rdoc/OpenStruct.html">OpenStruct</a></p>

<p>參考文件：<br/>
<a href="http://stackoverflow.com/questions/1177594/when-should-i-use-struct-vs-openstruct#answer-4459132">When should I use Struct vs. OpenStruct?</a><br/>
<a href="https://www.leighhalliday.com/ruby-struct">The simple but powerful Ruby Struct</a><br/>
<a href="http://motion-express.com/blog/20150406-ruby-struct-and-ostruct">模擬class物件：Ruby當中Struct及OpenStruct的使用</a></p>
]]></content>
  </entry>
  
</feed>
