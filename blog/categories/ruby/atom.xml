<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Ruby | Leon's Blogging]]></title>
  <link href="http://mgleon08.github.com/blog/categories/ruby/atom.xml" rel="self"/>
  <link href="http://mgleon08.github.com/"/>
  <updated>2016-04-20T00:51:53+08:00</updated>
  <id>http://mgleon08.github.com/</id>
  <author>
    <name><![CDATA[LeonJi]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Method Missing]]></title>
    <link href="http://mgleon08.github.com/blog/2016/04/19/method-missing/"/>
    <updated>2016-04-19T22:18:09+08:00</updated>
    <id>http://mgleon08.github.com/blog/2016/04/19/method-missing</id>
    <content type="html"><![CDATA[<p>當 ruby 找不到 method 就會 call 這個 method</p>

<!-- more -->


<pre><code class="ruby">class Post
  #自己建立 method_missing 呼叫
  def method_missing(method_name, *args)
    puts "You tried to call #{method_name} with these arguments: #{args}"
    super #default method_missing handling raises a NoMethodError
  end
end
Post.new.submit(1, "Here's a post.")
</code></pre>

<p>用找不到 method 會 call <code>method_missing</code> 的特性，直接自己定義 method_missing 去定義呼叫其他的 method</p>

<blockquote><p>它的執行效率並不好，所以只適合用在沒辦法預先知道方法名稱的情況下</p></blockquote>

<pre><code class="ruby">class Post
  DELEGATED_METHODS = [:username, :avatar]
  def initialize(user)
    @user = user
  end

  def method_missing(method_name, *args)
    if DELEGATED_METHODS.include?(method_name)
      @user.send(method_name, *args)
    else
      super #沒有在設定的 DELEGATED_METHODS 裡面，就呼叫 default method_missing handling raises a NoMethodError
    end
  end 
end
</code></pre>

<pre><code class="ruby">class Post
  def initialize(text)
    @text = text
  end
  def to_s
    @text
  end
  def method_missing(method_name, *args)
    match = method_name.to_s.match(/^hash_(\w+)/) #找前面是 hash_
    if match
      @text &lt;&lt; " #" + match[1]
    else
      super 
    end
  end
￼end


post = Post.new("HI")
post.hash_ruby
post.hash_metaprogramming
puts post
#=&gt; HI #ruby #metaprogramming
</code></pre>

<h3>respond_to?</h3>

<pre><code class="ruby">post = Post.new 
post.respond_to?(:to_s) # =&gt; true
post.hash_ruby #再 method_missing 有定義所以呼叫得到
post.respond_to?(:hash_ruby) # =&gt; false #但在 respond_to 卻回傳 false
</code></pre>

<p>因此必須自己定義 respond_to?</p>

<pre><code class="ruby">class Post
  def respond_to?(method_name)
    method_name =~ /^hash_\w+/ || super
  end 
end
</code></pre>

<p>但是 <code>post.method(:hash_ruby)</code> 還是會出現 <code>NameError: undefined method</code></p>

<p>所以要改成另一個 <code>respond_to_missing?</code></p>

<pre><code class="ruby">class Post
  def respond_to_missing?(method_name) 
    method_name =~ /^hash_\w+/ ||super
  end 
end
</code></pre>

<h1>￼DEFINE_METHOD REVISITED</h1>

<pre><code class="ruby">class Post
  def initialize(text)
    @text = text
  end
  def to_s
    @text
  end
  def method_missing(method_name, *args)
    match = method_name.to_s.match(/^hash_(\w+)/)
    if match #有 match 到 hash_ 就建立出新的 method
      self.class.class_eval do
        define_method(method_name) do
          @text &lt;&lt; " #" + match[1]
        end
      end 
      send(method_name) #並且呼叫 method
    else
      super #沒有就 raises a NoMethodError
    end
  end
end

#當 call post.hash_codeschool 就會定義出下面的 method 

def hash_codeschool
  @text &lt;&lt; " #" + "codeschool"
end
</code></pre>

<p>官方文件：<br/>
<a href="http://apidock.com/ruby/BasicObject/method_missing">method_missing</a><br/>
<a href="http://ruby-doc.org/core-2.2.0/MatchData.html">MatchData</a><br/>
<a href="http://ruby-doc.org/core-2.1.1/Regexp.html">Regexp</a></p>

<p>參考文件：  <br/>
<a href="https://ihower.tw/blog/archives/4797">如何設計出漂亮的 Ruby APIs</a><br/>
<a href="https://ruby-china.org/topics/3434">method_missing，一個Ruby 程序員的夢中情人</a><br/>
<a href="http://stackoverflow.com/questions/13793060/respond-to-vs-respond-to-missing">respond_to? vs. respond_to_missing?</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Dynamic Classes & Methods]]></title>
    <link href="http://mgleon08.github.com/blog/2016/04/19/dynamic-classes-and-methods/"/>
    <updated>2016-04-19T22:16:35+08:00</updated>
    <id>http://mgleon08.github.com/blog/2016/04/19/dynamic-classes-and-methods</id>
    <content type="html"><![CDATA[<p>ruby 可以很幫變的動態產生 Classes 和 Methods</p>

<!-- more -->


<h1>Struct</h1>

<pre><code class="ruby">class Post
  attr_accessor :user, :status
  def initialize(user, status)
    @user, @status = user, status
  end 

  def to_s
    "#{user}: #{status}"
  end
end

#上下相等

Post = Struct.new(:user, :status) do 
  def to_s
    "#{user}: #{status}"
  end
end
</code></pre>

<h1>send()</h1>

<pre><code class="ruby">post.say
= post.send(:say)
= post.send("say")

#也可以 call 到 private 的 method
</code></pre>

<h1>alias_method</h1>

<pre><code class="ruby">class Post
  attr_reader :foo #=&gt; return @foo
  #一定要在定義好的 method 後面還 call 得到
  alias_method :bar, :foo #=&gt; the same method 別名/原名

  def initialize(foo = [])
    @foo = foo
  end
end
</code></pre>

<h1>define_method</h1>

<pre><code class="ruby">
class Post
  def draft
    @status = :draft
  end

  def posted
    @status = :posted
  end

  def deleted
    @status = :deleted
  end
end

#上下相等

class Post
  states = [:draft, :posted, :deleted]
  states.each do |status|
    define_method status do
      @status = status
    end
  end 
end
</code></pre>

<h1>method()</h1>

<pre><code class="ruby">
class Post
  def initialize(foo)
    @posts = posts
  end
  def contents
    @foo
  end
  def show_tweet(index)
    puts @foo[index]
  end 
end
</code></pre>

<pre><code class="ruby">
foo = ['Compiling!', 'Bundling...']
post = Post.new(foo)

content_method = post.method(:contents)
content_method.call
#=&gt; ["Compiling!", "Bundling..."]

show_method = post.method(:show_tweet)

￼(0..1).each(&amp;show_method)
￼#上下相等
show_method.call(0)
show_method.call(1)
</code></pre>

<h1>EX: log_method</h1>

<pre><code class="ruby">
class MethodLogger
  def log_method(klass, method_name)
    klass.class_eval do
      alias_method "#{method_name}_original", method_name
      define_method method_name do |*args, &amp;block|
        puts "#{Time.now}: Called #{method_name}"
        send "#{method_name}_original", *args, &amp;block
      end
    end
  end
end

class Post
  def say_hi
    puts "Hi"
  end
end

logger = MethodLogger.new
logger.log_method(Post, :say_hi)
Post.new.say_hi

#=&gt; 2016-04-05 12:14:01 +0800: Called say_hi
#=&gt; Hi
</code></pre>

<p>官方文件：<br/>
<a href="http://ruby-doc.org/core-2.2.0/Struct.html">Struct</a><br/>
<a href="http://apidock.com/ruby/Object/__send__">send()</a><br/>
<a href="http://apidock.com/ruby/Module/alias_method">alias_method()</a><br/>
<a href="http://apidock.com/ruby/Module/define_method">method define_method</a></p>

<p>參考文件：<br/>
<a href="http://stackoverflow.com/questions/3337285/what-does-send-do-in-ruby">What does send() do in Ruby?</a><br/>
<a href="https://gist.github.com/plusor/6104625">alias vs alias_method</a>  <br/>
<a href="https://ihower.tw/blog/archives/4797">如何設計出漂亮的 Ruby APIs</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Module vs Class]]></title>
    <link href="http://mgleon08.github.com/blog/2016/03/26/module-and-class/"/>
    <updated>2016-03-26T09:34:18+08:00</updated>
    <id>http://mgleon08.github.com/blog/2016/03/26/module-and-class</id>
    <content type="html"><![CDATA[<p>在 ruby 中經常會使用到 <code>Class</code>，也常常看到 <code>Module</code>
那到底什麼時候要用哪個?</p>

<!-- more -->


<p>先看看兩者的差異</p>

<h1>Module</h1>

<ul>
<li>無法 instantiated（也就是沒有 new method）</li>
<li>可以被 include &amp; extend</li>
</ul>


<h1>Class</h1>

<ul>
<li>可以 instantiated</li>
<li>無法被 include</li>
</ul>


<p>簡單的來說，module 有點像是沒有 new 的 Class</p>

<p>並且可以用 <code>include</code> &amp; <code>extend</code> mixin 到 Class 裡面，變成 Class 的 <code>class method</code> or <code>instance method</code></p>

<p><a href="http://mgleon08.github.io/blog/2016/02/24/include-extend-require/">Ruby 中的 Include Extend Require Load</a></p>

<p>基本上兩種方式都有辦法達成同樣的效果，但差別就在於維護上</p>

<h1>維護</h1>

<p>用 Class 的話，勢必一定要先 new 出來，並且預設會執行 <code>initialize</code> 這個method<br/>
就可以預先設定好一些參數，看起來就會比較簡潔</p>

<pre><code class="ruby">class Pepole
  def initialize(name)
    @name = name
  end

  def hi
    "hi, #{@name}"
  end

  def yo
    "yo, #{@name}"
  end
end

p = People.new('leon')
p.hi #=&gt; 'hi leon'
p.yo #=&gt; 'yo leon'
</code></pre>

<p>用 Module 的話，就必須每次呼叫 <code>hi</code> <code>yo</code> method 時都要在傳入參數進去。</p>

<pre><code class="ruby">module Man
  def hi(name)
    "hi, #{@name}"
  end

  def yo
    "yo, #{@name}"
  end
end

Man.hi('leon') #=&gt; 'hi leon'
Man.yo('leon') #=&gt; 'yo leon'
</code></pre>

<p>另外是當 Class include 很多 module 時，都會變成 Class 的 <code>class method</code> or <code>instance method</code>，這時就很難去分辨是從哪個 module 來的 method。</p>

<p>因此使用上，看習慣，可維護性等等，去判斷要用 module or class<br/>
再細分要放在 <code>cocern</code> or <code>service object</code> or <code>lib</code></p>

<p>參考文件：<br/>
<a href="http://mgleon08.github.io/blog/2016/02/24/include-extend-require/">module include extend</a>
<a href="http://railsfun.tw/t/class-module-class/402">class與module的差異? class如何繼承</a><br/>
<a href="http://stackoverflow.com/questions/151505/difference-between-a-class-and-a-module">Difference between a class and a module</a><br/>
<a href="http://motion-express.com/blog/20141011-rails-module-model">Rails利用Module整理Model
</a><br/>
<a href="http://motion-express.com/blog/20141209-ruby-class-inheritance">Ruby class 基本的覆寫(override)及繼承(inheritance)</a><br/>
<a href="http://motion-express.com/blog/20141208-class-method-and-instance-method">Ruby當中的class method和instance method差在哪？</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[用 Concern 來整理 Code]]></title>
    <link href="http://mgleon08.github.com/blog/2016/03/26/concern/"/>
    <updated>2016-03-26T09:32:30+08:00</updated>
    <id>http://mgleon08.github.com/blog/2016/03/26/concern</id>
    <content type="html"><![CDATA[<p>當有相當多地方用到同樣的東西時，就可以用 concern 來讓 code 變得更乾淨。</p>

<!--more-->


<h1>使用時機</h1>

<ul>
<li>DRYing up model codes</li>
<li><p>Skin Fat Models.</p></li>
<li><p>將可重用的功能抽出來，讓多個 model 共用</p></li>
<li>model 太肥大，將相關的邏輯的 code 放到不同的 concern 裡</li>
<li>ActiveSupport::Concern 的風格</li>
</ul>


<h1>ActiveSupport::Concern</h1>

<p>任務是讓管理 modules 之間的 dependencies 變得容易。<br/>
也可以用 <code>include</code> 同時達成 <code>class methods</code> <code>instance methods</code>
（原本必須 include + extend 才能達成）</p>

<h1>原本作法</h1>

<pre><code class="ruby"># app/models/concerns/sample.rb

module Sample
  include Sample2
  # self.included 會在 Sample 被 include 時執行
  # base 傳入是誰哪個 Class include 了這個 module
  def self.included(base)
    base.class_eval do # 用 class_eval 在該 class 新增 Class method
      #scope :disabled, -&gt; { where(disabled: true) } 可以定義 scope
      #has_many :post 可以定義關聯
      def self.foo
          "這裡是 class 的 method"
      end
    end
  end

  def bar
     "這裡是 instance 的 method"
  end
end
</code></pre>

<pre><code class="ruby">#app/models/test.rb
class Test &lt; ActiveRecord::Base
  include Samples
end

Test.foo
=&gt; "這裡是 class 的 method"

Test.new.bar
=&gt; "這裡是 instance 的 method"
</code></pre>

<p>兩個 module 可以互相 include</p>

<pre><code class="ruby"># app/models/concerns/sample2.rb
module Sample2
  def self.included(base)
    base.class_eval do
      #do something method
    end
  end
end
</code></pre>

<pre><code class="ruby">#app/models/test.rb
class Test &lt; ActiveRecord::Base
  include Sample
  # include Sample，再透過 Sample 去 include Sample2 ,這樣就不用一次 include 兩個 module了
end
</code></pre>

<p>以上看起來蠻理想的<br/>
但因為 include <code>Sample2</code> 的是 <code>Sample</code><br/>
所以 <code>Sample2</code> 的 base 就變成了 <code>Sample</code> ， 不是我們要的 <code>Test</code></p>

<h1>更改</h1>

<pre><code class="ruby"># app/models/concerns/sample.rb
module Sample
  include Sample2
  extend ActiveSupport::Concern
    included do
      self.send(:method) # base 改成 self
    end
end
</code></pre>

<pre><code class="ruby"># app/models/concerns/sample2.rb
module Sample2
  extend ActiveSupport::Concern

  included do
    self.send(:methods)  # base 改成 self
    # 可以在這裡放當 include 時要執行的東西
    # 可以存取所有 class level 的東西
    # ex1: 宣告 shared scope
    # ex2: 可寫 shared validation
  end

#可以直接定義 ClassMethods 不需再 send(:extend, ClassMethods) 或是用 class_eval 去定義
   module ClassMethods  
      def foo
        # do something
      end
   end

#可以直接定義 InstanceMethods 不需再 send(:include, InstanceMethods)或是用 instance_eval 去定義
   module InstanceMethods  #也可以不用特別定義 module InstanceMethods
      def bar
         # do something
      end
   end
end
</code></pre>

<pre><code class="ruby">#app/models/test.rb
class Test &lt; ActiveRecord::Base
  include Sample
end
</code></pre>

<h1>concern vs service object</h1>

<ul>
<li>concern</li>
<li>簡單說就是，有許多 model 有共用的邏輯片段，可以拆出來</li>
<li>service object</li>
<li><p>與 concern 不同</p></li>
<li><p>兩個搭配使用</p></li>
<li>將許多 service object 搬到 concern</li>
</ul>


<p>官方文件：<br/>
<a href="http://api.rubyonrails.org/classes/ActiveSupport/Concern.html">ActiveSupport</a></p>

<p>參考文件：<br/>
<a href="https://ruby-china.org/topics/18401">什麼時候使用Concerns，什麼時候使用Services？</a><br/>
<a href="https://ihower.tw/blog/archives/3949">深入Rails3: ActiveSupport::Concern</a><br/>
<a href="http://stackoverflow.com/questions/14541823/how-to-use-concerns-in-rails-4">How to use concerns in Rails 4</a><br/>
<a href="https://ruby-china.org/topics/19812">ActiveSupport::Concern 小結</a><br/>
<a href="http://adz.cool/posts/210893-rails-use-case-mixin-and-concerns">rails use case - mixin &amp; concerns</a><br/>
<a href="https://www.viget.com/articles/slimming-down-your-models-and-controllers">Slimming Down Your Models and Controllers with Concerns, Service Objects, and Tableless Models</a><br/>
<a href="https://ihower.tw/rails4/activesupport.html">ActiveSupport - 工具函式庫</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[引數的傳遞 Argument Parameter]]></title>
    <link href="http://mgleon08.github.com/blog/2016/03/26/argument-parameter/"/>
    <updated>2016-03-26T09:28:59+08:00</updated>
    <id>http://mgleon08.github.com/blog/2016/03/26/argument-parameter</id>
    <content type="html"><![CDATA[<p>經常會看到 <code>argument</code> 和 <code>parameter</code> 兩個很類似，卻代表的不同意義。<br/>
另外也有許多符號 * ** &amp; 可以使用。</p>

<!-- more -->


<h1>介紹</h1>

<ul>
<li><p>argument(actual argument 實際的值) 引數<br/>
「呼叫端」傳給呼叫對象的「值」</p></li>
<li><p>parameter(formal parameter 代表參數的符號) = 參數<br/>
「被呼叫端」用來接收引數的「變數」</p></li>
</ul>


<h1>範例</h1>

<p>有預設值的 <code>parameter</code> 要相連在一起</p>

<pre><code class="ruby">def sample(a=1, b=2, c)
    puts [a, b, c]
end
</code></pre>

<p>傳入參數時，會先將值帶入沒有預設值的 <code>a</code>，在緊接著給最左邊的 <code>c</code></p>

<pre><code class="ruby">def sample(a, b=2, c=3)
  puts [a, b, c].inspect
end

sample(3)
#=&gt; [3, 2, 3]

sample(3, 1)
#=&gt; [3, 1, 3]
</code></pre>

<p>預設值的位置不同，結果也不一樣</p>

<pre><code class="ruby">def sample(a=1, b=2, c)
  puts [a, b, c].inspect
end

sample(3)
#=&gt; [1, 2, 3] #直接給沒有預設值的 c

sample(3, 1)
#=&gt; [3, 2, 1] #有兩個值，會先將第一個值給有預設值的第一個 a，第二個才補到 c
</code></pre>

<h1>* Array</h1>

<ul>
<li>當 <code>parameter</code> 前面加上 <code>*</code> 代表 <code>Array</code> 的意思</li>
</ul>


<pre><code class="ruby">#必須和有預設值得放在一起
#若要放中間，最後面不能放預設值(因為有預設值要擺在一起)，可以放變數

def sample(a=1, b=2, *c)
  puts [a, b, c].inspect
end

sample(4,5,6,7,8)
#=&gt; [4, 5, [6, 7, 8]]
</code></pre>

<pre><code class="ruby">def sample(a, *b, c)
  puts [a, b, c].inspect
end

sample(1,2) #至少兩個參數
#=&gt; [1, [], 2]

sample(1,2,3)
#=&gt; [1, [2], 3]

sample(1,2,3,4)
#=&gt; [1, [2, 3], 4]

sample(1,2,3,4,5)
#=&gt; [1, [2, 3, 4], 5]
</code></pre>

<h3>另一種用法將 Array 展開來</h3>

<pre><code class="ruby">def sample(a=1, b=2, *c)
  puts [a, b, c].inspect
end

array = [4, 5, 6, 7, 8]
sample(array)
#=&gt; [[4, 5, 6, 7, 8], 2, []] #將 numble 當成一個參數了ˊˋ

sample(*array)
#=&gt; [4, 5, [6, 7, 8]] #將 Array 給展開來
</code></pre>

<pre><code class="ruby">def sample(a=1, *b, c)
  puts [a, b, c].inspect
end

array = [4, 5, 6, 7, 8]

sample(array)
#=&gt; [1, [], [4, 5, 6, 7, 8]]
sample(*array)
#=&gt; [4, [5, 6, 7], 8]
</code></pre>

<h1>** Hash</h1>

<ul>
<li>當 <code>parameter</code> 前面加上 <code>**</code> 代表 <code>Hash</code> 的意思</li>
<li>一定要擺到最後一個</li>
<li>只能有一個</li>
<li>並且要傳入的是 <code>Hash</code></li>
<li>傳入的值若不是在最後面，要加上 <code>{}</code>,預設會將後面所有的 <code>key-value</code> 包成一個 <code>Hash</code></li>
</ul>


<blockquote><p>即使後面不加 <code>**</code> 預設也會將後面的值都包成一個 hash</p></blockquote>

<pre><code class="ruby">def sample(a=1, b=2, **c)
  puts [a, b, c].inspect
end

sample('j':4, 'q':5, 'k':6)
#=&gt; [1, 2, {:j=&gt;4, :q=&gt;5, :k=&gt;6}]

sample({'j':4, 'q':5, 'k':6}, 3, 4) # 放在前面加上 {}
#=&gt; [{:j=&gt;4, :q=&gt;5, :k=&gt;6}, 3, 4]
</code></pre>

<pre><code class="ruby"># 'b':1 傳入的值必須 key-value 並且要對到 key
def sample(a, b:2, c:3)  
  puts [a, b, c].inspect
end
sample('a':11, 'v':22, 'c':33, 's':44)
#=&gt; [{:a=&gt;11, :v=&gt;22, :c=&gt;33, :s=&gt;44}, 2, 3]

sample({'a':11, 'v':22, 'c':33, 's':44}, 'b':100)
#=&gt; [{:a=&gt;11, :v=&gt;22, :c=&gt;33, :s=&gt;44}, 100, 3]
</code></pre>

<pre><code class="ruby">def sample(a, b, **c) # sample(a, b, c)
  puts [a, b, c].inspect
end

sample(4, 'a':1) 
#=&gt; [4, {:a=&gt;1}, {}]

sample(4, 5, 'a':1, 'b':2, 'c':3)
#=&gt; [4, 5, {:a=&gt;1, :b=&gt;2, :c=&gt;3}]

sample(4, 'a':1, 'v':2, 'c':4)
#=&gt; [4, {:a=&gt;1, :v=&gt;2, :c=&gt;4}, {}]

sample({'z':5}, {'a':1, 'v':2}, 'c':4)
#=&gt; [{:z=&gt;5}, {:a=&gt;1, :v=&gt;2}, {:c=&gt;4}]

sample(4, {'a':1, 'v':2}, 'c':4)
#=&gt; [4, {:a=&gt;1, :v=&gt;2}, {:c=&gt;4}]
</code></pre>

<h3>另一種用法將 Hash 展開</h3>

<pre><code class="ruby">def sample(a, b, **c)
  puts [a, b, c].inspect
end

hash  = {:q=&gt;4, :w=&gt;5, :e=&gt;6}
hash2 = {:r=&gt;4, :t=&gt;{:y=&gt;5, :u=&gt;6}}
hash3 = {:i=&gt;4, :o=&gt;5}

sample(1,hash)
#=&gt;  [1, {:q=&gt;4, :w=&gt;5, :e=&gt;6}, {}]

sample(1,hash, hash2)
#=&gt; [1, {:q=&gt;4, :w=&gt;5, :e=&gt;6}, {:r=&gt;4, :t=&gt;{:y=&gt;5, :u=&gt;6}}]

#將兩個 hash 合併成一個
sample(1 ,**hash, **hash2)
#=&gt; [1, {:q=&gt;4, :w=&gt;5, :e=&gt;6, :r=&gt;4, :t=&gt;{:y=&gt;5, :u=&gt;6}}, {}]

#展開後，後面就可以繼續塞 hash
sample(1,2,**hash, 'foo':123, 'bar':456)
#=&gt; [1, 2, {:q=&gt;4, :w=&gt;5, :e=&gt;6, :foo=&gt;123, :bar=&gt;456}]
</code></pre>

<pre><code class="ruby">def sample(a:1, b:2, **c)
  puts [a, b, c].inspect
end

hash  = {:q=&gt;4, :w=&gt;5, :e=&gt;6}
hash2 = {:r=&gt;4, :t=&gt;{:y=&gt;5, :u=&gt;6}}
hash3 = {:i=&gt;4, :o=&gt;5}

sample(**hash, **hash2, 'b':100)
#=&gt; [1, 100, {:j=&gt;4, :q=&gt;5, :k=&gt;6, :c=&gt;{:q=&gt;5, :k=&gt;6}}]

sample(**hash, **hash2, 'test':100)
#=&gt; [1, 100, {:q=&gt;4, :w=&gt;5, :e=&gt;6, :r=&gt;4, :t=&gt;{:y=&gt;5, :u=&gt;6}}]

sample(**hash, **hash2, 'test':100, 'b':123)
#=&gt; [1, 123, {:q=&gt;4, :w=&gt;5, :e=&gt;6, :r=&gt;4, :t=&gt;{:y=&gt;5, :u=&gt;6}, :test=&gt;100}]
</code></pre>

<h1>&amp; 區塊傳遞</h1>

<p>若要調用在變數，前綴一個『&amp;』符號，並且要放在最後一個</p>

<pre><code class="ruby">class Array
  def iterate!(&amp;code)
    self.each_with_index do |n, i|
      self[i] = code.call(n)
    end
  end
end

array = [1, 2, 3, 4]

array.iterate! do |n|
  n ** 2
end

puts array.inspect
</code></pre>

<h1>綜合使用</h1>

<pre><code class="ruby">def sample(a, *b, **c, &amp;d)  
  puts "a=#{a}, b=#{b}, c=#{c}"  
  d.call(100)  
end  
sample(1,2,3,x:4,y:5) { |x| puts x }  

#=&gt; a=1, b=[2, 3], c={:x=&gt;4, :y=&gt;5}
#=&gt; 100
</code></pre>

<p>若最後面是 * 不限制長度，塞很多變數，或是後面接 hash 都不會錯</p>

<pre><code class="ruby">def sample(a, b, *c)
  puts [a, b, c].inspect
end

sample(1,2,3, 4, 5)
#=&gt; [1, 2, [3, 4, 5]]

sample(1,2,'a':1, 'b':2)
#=&gt; [1, 2, [{:a=&gt;1, :b=&gt;2}]]
</code></pre>
]]></content>
  </entry>
  
</feed>
