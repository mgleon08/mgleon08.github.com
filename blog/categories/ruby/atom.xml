<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Ruby | Leon's Blogging]]></title>
  <link href="http://mgleon08.github.com/blog/categories/ruby/atom.xml" rel="self"/>
  <link href="http://mgleon08.github.com/"/>
  <updated>2016-05-29T20:37:29+08:00</updated>
  <id>http://mgleon08.github.com/</id>
  <author>
    <name><![CDATA[LeonJi]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Default Args]]></title>
    <link href="http://mgleon08.github.com/blog/2016/05/29/default-args/"/>
    <updated>2016-05-29T20:22:19+08:00</updated>
    <id>http://mgleon08.github.com/blog/2016/05/29/default-args</id>
    <content type="html"><![CDATA[<p>很常時候，需要給變數一個預設值，因此有以下方法，都可以設定預設值</p>

<!-- more -->


<h1>||</h1>

<p>只要是空值，或是 false, nil 就會回傳後面的預設值</p>

<pre><code class="ruby">h = { "a" =&gt; 100, "b" =&gt; false , 'c' =&gt; nil}
#=&gt; {"a"=&gt;100, "b"=&gt;false, "c"=&gt;nil}
h['a'] || 8
#=&gt; 100
h['b'] || 8
#=&gt; 8
h['c'] || 8
#=&gt; 8
h['d'] || 8
#=&gt; 8
</code></pre>

<h1>fetch</h1>

<p>即使是 nil, false 也會回傳，只有在空值的時候回傳預設值</p>

<pre><code class="ruby">h = { "a" =&gt; 100, "b" =&gt; false , 'c' =&gt; nil}
#=&gt; {"a"=&gt;100, "b"=&gt;false, "c"=&gt;nil}
h.fetch('a', 8)
#=&gt; 100
h.fetch('b', 8)
#=&gt; false
h.fetch('c', 8)
#=&gt; nil
h.fetch('d', 8)
#=&gt; 8
</code></pre>

<h1>merge</h1>

<p>只有在 merge 的參數裡有同樣的值，才會覆蓋掉 default 的值</p>

<pre><code class="ruby">default = { "a" =&gt; 100, "b" =&gt; false , 'c' =&gt; nil }
args    = { "a" =&gt; 8 }

default.merge(args)
#=&gt; {"a"=&gt;8, "b"=&gt;false, "c"=&gt;nil}
</code></pre>

<p>官方文件：<br/>
<a href="http://apidock.com/ruby/Hash/fetch">fetch</a><br/>
<a href="http://apidock.com/ruby/Hash/merge">merge</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Struct vs OpenStruct]]></title>
    <link href="http://mgleon08.github.com/blog/2016/05/29/struct-vs-openstruct/"/>
    <updated>2016-05-29T20:18:53+08:00</updated>
    <id>http://mgleon08.github.com/blog/2016/05/29/struct-vs-openstruct</id>
    <content type="html"><![CDATA[<p>在 ruby 當中，經常會要定義一個新的類別，如果覺得每次都要寫 <code>class xxx</code> 太麻煩，就可以用 struct &amp; OpenStruct 快速的產生出來!</p>

<!-- more -->


<h1>Class</h1>

<pre><code class="ruby">class People
  attr_accessor :name, :phone

  def initialize(name, phone)
    @name  = name
    @phone = phone
  end

  def to_ary
    [name, phone]
  end
end

a = People.new("foo", 1234)
#=&gt; #&lt;People:0x007fcaabcf5328 @name="foo", @phone=1234&gt;
a.name
#=&gt; "foo"
a.phone
#=&gt; 1234
a.to_ary
#=&gt; ["foo", 1234]
</code></pre>

<h1>Struct</h1>

<pre><code class="ruby">#method 要用 block 來傳遞，Attribute 一開始就固定了
People = Struct.new(:name, :phone) do
  def to_ary
    [name, phone]
  end
end
# =&gt; People

a = People.new("foo", 1234)
#=&gt; #&lt;struct People name="foo", phone=1234&gt;
a.name
#=&gt; "foo"
a.phone
#=&gt; 1234
a.to_ary
#=&gt; ["foo", 1234]
</code></pre>

<h3>其他取 Attribute Value 的方法</h3>

<p>Class則無法</p>

<pre><code class="ruby">a[:name]
#=&gt; "foo"
a["name"]
#=&gt; "foo"
a[0]
#=&gt; "foo"
</code></pre>

<h1>OpenStruct</h1>

<p>主要差異點是在於，比 Struct 更有彈性, 因為它可以任意增加 Attribute , 不像 Struct 要先限制好有哪些 Attribute</p>

<p>但比較可惜的是，無法定義 method</p>

<pre><code class="ruby">#在 console 記得先 require
require 'ostruct'

People = OpenStruct.new
#=&gt; #&lt;OpenStruct&gt;
or
People = OpenStruct.new(name: 'foo', phone: 1234)
#=&gt; #&lt;OpenStruct name="foo", phone=1234&gt;

可以自由新增
People.name = 'foo'
#=&gt; "foo"
People.phone = 1234
#=&gt; 1234
People.age = 18
#=&gt; 18
People
#=&gt; #&lt;OpenStruct name="foo", phone=1234, age=18&gt;
</code></pre>

<h3>WHEN TO USE?</h3>

<ul>
<li>As a temporary data structure 暫時的 data 結構</li>
<li>As internal class data 內部的 class data</li>
</ul>


<blockquote><p>也許另一個 class 還不至於明確到可以獨立成一個 class，因此先暫存在別的 class 裡，直到有明確的行為，足夠讓它獨立出去</p></blockquote>

<pre><code class="ruby">class Person
  Address = Struct.new(:street_1, :street_2, :city)

  attr_accessor :name, :address

  def initialize(name, opts)
    @name = name
    @address = Address.new(opts[:street_1], opts[:street_2], opts[:city])
  end
end

leigh = Person.new("Leigh Halliday", {
  street_1: "123 Road",
  city: "Toronto",
})

puts leigh.address.inspect
# &lt;struct Person::Address street_1="123 Road", street_2=nil, city="Toronto", province="Ontario", country="Canada", postal_code="M5E 0A3"&gt;
</code></pre>

<ul>
<li>As a testing stub</li>
</ul>


<pre><code class="ruby">KCup = Struct.new(:size, :brewing_time, :brewing_temp)
colombian = KCup.new(:small, 60, 85)

brewer = Brewer.new(colombian)
expect(brewer.brew).to eq(true)
</code></pre>

<p>官方文件：<br/>
<a href="http://ruby-doc.org/core-2.2.0/Struct.html">Struct</a><br/>
<a href="http://ruby-doc.org/stdlib-2.0.0/libdoc/ostruct/rdoc/OpenStruct.html">OpenStruct</a></p>

<p>參考文件：<br/>
<a href="http://stackoverflow.com/questions/1177594/when-should-i-use-struct-vs-openstruct#answer-4459132">When should I use Struct vs. OpenStruct?</a><br/>
<a href="https://www.leighhalliday.com/ruby-struct">The simple but powerful Ruby Struct</a><br/>
<a href="http://motion-express.com/blog/20150406-ruby-struct-and-ostruct">模擬class物件：Ruby當中Struct及OpenStruct的使用</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Forwardable 轉發 & Delegate 委派]]></title>
    <link href="http://mgleon08.github.com/blog/2016/05/29/forwardable-and-delegate/"/>
    <updated>2016-05-29T20:15:26+08:00</updated>
    <id>http://mgleon08.github.com/blog/2016/05/29/forwardable-and-delegate</id>
    <content type="html"><![CDATA[<p>在 OO 的世界裡，經常會去用到不同 class 的 method，因此透過這個方法，可以將不同 class 的 method <code>轉發</code> 過來!</p>

<!-- more -->


<h1>Forwardable</h1>

<p>顧名思義，將訊息 <code>轉發</code> 給別的物件。</p>

<pre><code class="ruby">Account = Struct.new(:first_name, :last_name)

class User
  attr_reader :account

  def initialize(account)
    @account = account
  end

  def first_name
    account.first_name
  end

  def last_name
    account.last_name
  end

  def full_name
    "#{first_name} #{last_name}"
  end
end

user = User.new(Account.new('foo', 'bar'))

puts user.first_name
puts user.last_name
puts user.full_name
#=&gt;foo
#=&gt;bar
#=&gt;foo bar
</code></pre>

<p>上述有許多重複的 account，此時就可以使用 Forwardable 來簡化：<br/>
將 first_name、last_name <code>轉發</code> 給 account。</p>

<pre><code class="ruby">require 'forwardable'

Account = Struct.new(:first_name, :last_name)

class User
  attr_reader :account
  extend Forwardable
  def_delegators :account, :first_name, :last_name

  #若 User 不想對外開放，attr_reader :account，可以改成實例變數，如以下
  #extend Forwardable
  #def_delegators :@account, :first_name, :last_name

  def initialize(account)
    @account = account
  end

  def full_name
    "#{first_name} #{last_name}"
  end
end

user = User.new(Account.new('foo', 'bar'))

puts user.first_name
puts user.last_name
puts user.full_name
#=&gt;foo
#=&gt;bar
#=&gt;foo bar
</code></pre>

<h3>def_delegator(accessor, method, ali = method)</h3>

<p> 一次只能 &lsquo;轉發&rsquo; 一個方法，第三個參數是（可選的）別名。</p>

<pre><code class="`ruby">class MyQueue
  extend Forwardable
  attr_reader :queue
  def initialize
    @queue = []
  end

  def_delegator :@queue, :push, :mypush
end

q = MyQueue.new
q.mypush 42
q.queue    #=&gt; [42]
q.push 23  #=&gt; NoMethodError
</code></pre>

<h3>def_delegators(accessor, *methods)</h3>

<p>一次可以 &lsquo;轉發&rsquo; 多個方法。</p>

<pre><code class="ruby">def_delegators :@account, :first_name, :last_name
</code></pre>

<h3>delegate [method, method, &hellip;] => accessor</h3>

<p>接受Hash</p>

<pre><code class="ruby">delegate [:first_name, :last_name] =&gt; :account
</code></pre>

<p>看是如何 work</p>

<pre><code class="ruby">module Forwardable
  def delegate(hash)
    hash.each{ |methods, accessor|
      methods.each{ |method|
        instance_eval %{
          def #{method}(*args, &amp;block)
            #{accessor}.__send__(:#{method}, *args, &amp;block)
          end
        }
      }
    }
  end
end
</code></pre>

<h1>Other</h1>

<ul>
<li><code>instance_delegate</code> alias <code>delegate</code></li>
<li><code>def_instance_delegator</code> alias <code>def_delegator</code></li>
<li><p><code>def_instance_delegators</code> alias <code>def_delegators</code></p></li>
<li><p><a href="http://mgleon08.github.io/blog/2015/12/13/ruby-on-rails-delegate/">rails-delegate</a> 之前就有寫到，可以參考!</p></li>
</ul>


<p>官方文件：<br/>
<a href="http://apidock.com/ruby/Forwardable/instance_delegate">instance_delegate</a><br/>
<a href="http://apidock.com/ruby/Forwardable/def_instance_delegator">def_instance_delegator</a><br/>
<a href="http://apidock.com/ruby/Forwardable/def_instance_delegators">def_instance_delegators</a><br/>
<a href="http://apidock.com/ruby/Forwardable">Forwardable</a><br/>
<a href="http://ruby-doc.org/stdlib-2.0.0/libdoc/forwardable/rdoc/Forwardable.html">Forwardable</a></p>

<p>參考文件：<br/>
<a href="http://juanitofatas.com/2014/06/30/ruby-stdlib-forwardable/">Ruby 標準函式庫 Forwardable</a><br/>
<a href="http://qiita.com/xiangzhuyuan/items/409c87da8cc4a882419b">深入理解和学习Ruby的Forwardable</a><br/>
<a href="http://vaidehijoshi.github.io/blog/2015/03/31/delegating-all-of-the-things-with-ruby-forwardable/">Delegating All of the Things With Ruby Forwardable</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ruby 中的數字 & BigDecimal]]></title>
    <link href="http://mgleon08.github.com/blog/2016/05/07/ruby-math/"/>
    <updated>2016-05-07T10:42:25+08:00</updated>
    <id>http://mgleon08.github.com/blog/2016/05/07/ruby-math</id>
    <content type="html"><![CDATA[<p>在程式中的運算可能跟我們平常接觸的會不一樣，ruby 也是!因此來瞭解一下吧!</p>

<!-- more -->


<p><img src="http://ithelp.ithome.com.tw/upload/images/20141005/20141005190053543124e558797_resize_600.png" alt="" /></p>

<h1>integer</h1>

<pre><code class="ruby">1.class
#=&gt; Fixnum
(2/3).class
#=&gt; Fixnum
#20 位數會開始變成 Bignum
('1'+'0'*18).to_i.class
#=&gt; Fixnum
('1'+'0'*19).to_i.class
#=&gt; Bignum
1.2.to_i
#=&gt; 1
</code></pre>

<h1>float</h1>

<p>只要分子或分母出現浮點數，結果才會是 float</p>

<blockquote><p>兩個運算元皆為整數，則會進行截尾整數除法(truncating integer division)運算</p></blockquote>

<pre><code class="ruby">3.14.class
#=&gt; Float
1/2
#=&gt; 0
1/2.0
#=&gt; 0.5
1.0/2
#=&gt; 0.5
1.to_f
#=&gt; 1.0
</code></pre>

<h1>運算</h1>

<pre><code class="ruby">餘數
10%3
#=&gt; 1

次方
2**10
#=&gt; 1024
2**-1
#=&gt; (1/2)

絕對值
-1234.abs
#=&gt; 1234

四捨五入
(3.3).round
#=&gt; 3
(4.5).round
#=&gt; 5

回傳小於該數學的最大整數
(2.1).floor
#=&gt; 2
(-2.1).floor
#=&gt; -3

回傳大於該數學的最小整數
(2.1).ceil
#=&gt; 3
(-2.1).ceil
#=&gt; -2

#只適用於Fixnum
2.zero?
#=&gt; false
0.zero?
#=&gt; true

1.0 / 0    # Infinity
-1.0 / 0   # -Infinity
0.0 / 0.0  # NaN
</code></pre>

<h1>BigDecimal</h1>

<p>主要是用來做精確的數字</p>

<pre><code class="ruby">sum = 0
for i in (1..10000)
  sum = sum + 0.0001
end
print sum
#=&gt; 0.9999999999999062
#因為在電腦中的浮點數其實只是近似值，浮點數中的整數可能只是精確度到達一定程度而已
</code></pre>

<pre><code class="ruby">require 'bigdecimal'

sum = BigDecimal.new("0")
for i in (1..10000)
  sum = sum + BigDecimal.new("0.0001")
end
print sum
#=&gt; 0.1E1

E代表後面有幾個10的次方
0.1E1 = 0.1 * (10**1)
#=&gt; 1.0
0.2E1 = 0.2 * (10**1)
#=&gt; 2.0
0.2E2 = 0.2 * (10**2)
#=&gt; 20.0
2E3   =   2 * (10**3)
#=&gt; 2000.0
</code></pre>

<p>官方文件：<br/>
<a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/bigdecimal/rdoc/BigDecimal.html">BigDecimal</a></p>

<p>參考文件：<br/>
<a href="http://blog.annideas.com/2014/10/05/ruby-girl-5-ruby-math-intro/">Ruby的數學跟老師教的數學都不一樣？</a><br/>
<a href="https://gradyli.wordpress.com/2007/11/16/numeric-class/">[Ruby教學]Numeric Class</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Method Missing]]></title>
    <link href="http://mgleon08.github.com/blog/2016/04/19/method-missing/"/>
    <updated>2016-04-19T22:18:09+08:00</updated>
    <id>http://mgleon08.github.com/blog/2016/04/19/method-missing</id>
    <content type="html"><![CDATA[<p>當 ruby 找不到 method 就會 call 這個 method</p>

<!-- more -->


<pre><code class="ruby">class Post
  #自己建立 method_missing 呼叫
  def method_missing(method_name, *args)
    puts "You tried to call #{method_name} with these arguments: #{args}"
    super #default method_missing handling raises a NoMethodError
  end
end
Post.new.submit(1, "Here's a post.")
</code></pre>

<p>用找不到 method 會 call <code>method_missing</code> 的特性，直接自己定義 method_missing 去定義呼叫其他的 method</p>

<blockquote><p>它的執行效率並不好，所以只適合用在沒辦法預先知道方法名稱的情況下</p></blockquote>

<pre><code class="ruby">class Post
  DELEGATED_METHODS = [:username, :avatar]
  def initialize(user)
    @user = user
  end

  def method_missing(method_name, *args)
    if DELEGATED_METHODS.include?(method_name)
      @user.send(method_name, *args)
    else
      super #沒有在設定的 DELEGATED_METHODS 裡面，就呼叫 default method_missing handling raises a NoMethodError
    end
  end 
end
</code></pre>

<pre><code class="ruby">class Post
  def initialize(text)
    @text = text
  end
  def to_s
    @text
  end
  def method_missing(method_name, *args)
    match = method_name.to_s.match(/^hash_(\w+)/) #找前面是 hash_
    if match
      @text &lt;&lt; " #" + match[1]
    else
      super 
    end
  end
￼end


post = Post.new("HI")
post.hash_ruby
post.hash_metaprogramming
puts post
#=&gt; HI #ruby #metaprogramming
</code></pre>

<h3>respond_to?</h3>

<pre><code class="ruby">post = Post.new 
post.respond_to?(:to_s) # =&gt; true
post.hash_ruby #再 method_missing 有定義所以呼叫得到
post.respond_to?(:hash_ruby) # =&gt; false #但在 respond_to 卻回傳 false
</code></pre>

<p>因此必須自己定義 respond_to?</p>

<pre><code class="ruby">class Post
  def respond_to?(method_name)
    method_name =~ /^hash_\w+/ || super
  end 
end
</code></pre>

<p>但是 <code>post.method(:hash_ruby)</code> 還是會出現 <code>NameError: undefined method</code></p>

<p>所以要改成另一個 <code>respond_to_missing?</code></p>

<pre><code class="ruby">class Post
  def respond_to_missing?(method_name) 
    method_name =~ /^hash_\w+/ ||super
  end 
end
</code></pre>

<h1>￼DEFINE_METHOD REVISITED</h1>

<pre><code class="ruby">class Post
  def initialize(text)
    @text = text
  end
  def to_s
    @text
  end
  def method_missing(method_name, *args)
    match = method_name.to_s.match(/^hash_(\w+)/)
    if match #有 match 到 hash_ 就建立出新的 method
      self.class.class_eval do
        define_method(method_name) do
          @text &lt;&lt; " #" + match[1]
        end
      end 
      send(method_name) #並且呼叫 method
    else
      super #沒有就 raises a NoMethodError
    end
  end
end

#當 call post.hash_codeschool 就會定義出下面的 method 

def hash_codeschool
  @text &lt;&lt; " #" + "codeschool"
end
</code></pre>

<p>官方文件：<br/>
<a href="http://apidock.com/ruby/BasicObject/method_missing">method_missing</a><br/>
<a href="http://ruby-doc.org/core-2.2.0/MatchData.html">MatchData</a><br/>
<a href="http://ruby-doc.org/core-2.1.1/Regexp.html">Regexp</a></p>

<p>參考文件：  <br/>
<a href="https://ihower.tw/blog/archives/4797">如何設計出漂亮的 Ruby APIs</a><br/>
<a href="https://ruby-china.org/topics/3434">method_missing，一個Ruby 程序員的夢中情人</a><br/>
<a href="http://stackoverflow.com/questions/13793060/respond-to-vs-respond-to-missing">respond_to? vs. respond_to_missing?</a></p>
]]></content>
  </entry>
  
</feed>
