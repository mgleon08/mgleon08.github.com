<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Ruby | Leon's Blogging]]></title>
  <link href="http://mgleon08.github.com/blog/categories/ruby/atom.xml" rel="self"/>
  <link href="http://mgleon08.github.com/"/>
  <updated>2016-03-27T21:31:11+08:00</updated>
  <id>http://mgleon08.github.com/</id>
  <author>
    <name><![CDATA[LeonJi]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Module vs Class]]></title>
    <link href="http://mgleon08.github.com/blog/2016/03/26/module-and-class/"/>
    <updated>2016-03-26T09:34:18+08:00</updated>
    <id>http://mgleon08.github.com/blog/2016/03/26/module-and-class</id>
    <content type="html"><![CDATA[<p>在 ruby 中經常會使用到 <code>Class</code>，也常常看到 <code>Module</code>
那到底什麼時候要用哪個?</p>

<!-- more -->


<p>先看看兩者的差異</p>

<h1>Module</h1>

<ul>
<li>無法 instantiated（也就是沒有 new method）</li>
<li>可以被 include &amp; extend</li>
</ul>


<h1>Class</h1>

<ul>
<li>可以 instantiated</li>
<li>無法被 include</li>
</ul>


<p>簡單的來說，module 有點像是沒有 new 的 Class</p>

<p>並且可以用 <code>include</code> &amp; <code>extend</code> mixin 到 Class 裡面，變成 Class 的 <code>class method</code> or <code>instance method</code></p>

<p><a href="http://mgleon08.github.io/blog/2016/02/24/include-extend-require/">Ruby 中的 Include Extend Require Load</a></p>

<p>基本上兩種方式都有辦法達成同樣的效果，但差別就在於維護上</p>

<h1>維護</h1>

<p>用 Class 的話，勢必一定要先 new 出來，並且預設會執行 <code>initialize</code> 這個method<br/>
就可以預先設定好一些參數，看起來就會比較簡潔</p>

<pre><code class="ruby">class Pepole
  def initialize(name)
    @name = name
  end

  def hi
    "hi, #{@name}"
  end

  def yo
    "yo, #{@name}"
  end
end

p = People.new('leon')
p.hi #=&gt; 'hi leon'
p.yo #=&gt; 'yo leon'
</code></pre>

<p>用 Module 的話，就必須每次呼叫 <code>hi</code> <code>yo</code> method 時都要在傳入參數進去。</p>

<pre><code class="ruby">module Man
  def hi(name)
    "hi, #{@name}"
  end

  def yo
    "yo, #{@name}"
  end
end

Man.hi('leon') #=&gt; 'hi leon'
Man.yo('leon') #=&gt; 'yo leon'
</code></pre>

<p>另外是當 Class include 很多 module 時，都會變成 Class 的 <code>class method</code> or <code>instance method</code>，這時就很難去分辨是從哪個 module 來的 method。</p>

<p>因此使用上，看習慣，可維護性等等，去判斷要用 module or class<br/>
再細分要放在 <code>cocern</code> or <code>service object</code> or <code>lib</code></p>

<p>參考文件：<br/>
<a href="http://mgleon08.github.io/blog/2016/02/24/include-extend-require/">module include extend</a>
<a href="http://railsfun.tw/t/class-module-class/402">class與module的差異? class如何繼承</a><br/>
<a href="http://stackoverflow.com/questions/151505/difference-between-a-class-and-a-module">Difference between a class and a module</a><br/>
<a href="http://motion-express.com/blog/20141011-rails-module-model">Rails利用Module整理Model
</a><br/>
<a href="http://motion-express.com/blog/20141209-ruby-class-inheritance">Ruby class 基本的覆寫(override)及繼承(inheritance)</a><br/>
<a href="http://motion-express.com/blog/20141208-class-method-and-instance-method">Ruby當中的class method和instance method差在哪？</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[引數的傳遞 Argument Parameter]]></title>
    <link href="http://mgleon08.github.com/blog/2016/03/26/argument-parameter/"/>
    <updated>2016-03-26T09:28:59+08:00</updated>
    <id>http://mgleon08.github.com/blog/2016/03/26/argument-parameter</id>
    <content type="html"><![CDATA[<p>經常會看到 <code>argument</code> 和 <code>parameter</code> 兩個很類似，卻代表的不同意義。<br/>
另外也有許多符號 * ** &amp; 可以使用。</p>

<!-- more -->


<h1>介紹</h1>

<ul>
<li><p>argument(actual argument 實際的值) 引數<br/>
「呼叫端」傳給呼叫對象的「值」</p></li>
<li><p>parameter(formal parameter 代表參數的符號) = 參數<br/>
「被呼叫端」用來接收引數的「變數」</p></li>
</ul>


<h1>範例</h1>

<p>有預設值的 <code>parameter</code> 要相連在一起</p>

<pre><code class="ruby">def sample(a=1, b=2, c)
    puts [a, b, c]
end
</code></pre>

<p>傳入參數時，會先將值帶入沒有預設值的 <code>a</code>，在緊接著給最左邊的 <code>c</code></p>

<pre><code class="ruby">def sample(a, b=2, c=3)
  puts [a, b, c].inspect
end

sample(3)
#=&gt; [3, 2, 3]

sample(3, 1)
#=&gt; [3, 1, 3]
</code></pre>

<p>預設值的位置不同，結果也不一樣</p>

<pre><code class="ruby">def sample(a=1, b=2, c)
  puts [a, b, c].inspect
end

sample(3)
#=&gt; [1, 2, 3] #直接給沒有預設值的 c

sample(3, 1)
#=&gt; [3, 2, 1] #有兩個值，會先將第一個值給有預設值的第一個 a，第二個才補到 c
</code></pre>

<h1>* Array</h1>

<ul>
<li>當 <code>parameter</code> 前面加上 <code>*</code> 代表 <code>Array</code> 的意思</li>
</ul>


<pre><code class="ruby">#必須和有預設值得放在一起
#若要放中間，最後面不能放預設值(因為有預設值要擺在一起)，可以放變數

def sample(a=1, b=2, *c)
  puts [a, b, c].inspect
end

sample(4,5,6,7,8)
#=&gt; [4, 5, [6, 7, 8]]
</code></pre>

<pre><code class="ruby">def sample(a, *b, c)
  puts [a, b, c].inspect
end

sample(1,2) #至少兩個參數
#=&gt; [1, [], 2]

sample(1,2,3)
#=&gt; [1, [2], 3]

sample(1,2,3,4)
#=&gt; [1, [2, 3], 4]

sample(1,2,3,4,5)
#=&gt; [1, [2, 3, 4], 5]
</code></pre>

<h3>另一種用法將 Array 展開來</h3>

<pre><code class="ruby">def sample(a=1, b=2, *c)
  puts [a, b, c].inspect
end

array = [4, 5, 6, 7, 8]
sample(array)
#=&gt; [[4, 5, 6, 7, 8], 2, []] #將 numble 當成一個參數了ˊˋ

sample(*array)
#=&gt; [4, 5, [6, 7, 8]] #將 Array 給展開來
</code></pre>

<pre><code class="ruby">def sample(a=1, *b, c)
  puts [a, b, c].inspect
end

array = [4, 5, 6, 7, 8]

sample(array)
#=&gt; [1, [], [4, 5, 6, 7, 8]]
sample(*array)
#=&gt; [4, [5, 6, 7], 8]
</code></pre>

<h1>** Hash</h1>

<ul>
<li>當 <code>parameter</code> 前面加上 <code>**</code> 代表 <code>Hash</code> 的意思</li>
<li>一定要擺到最後一個</li>
<li>只能有一個</li>
<li>並且要傳入的是 <code>Hash</code></li>
<li>傳入的值若不是在最後面，要加上 <code>{}</code>,預設會將後面所有的 <code>key-value</code> 包成一個 <code>Hash</code></li>
</ul>


<blockquote><p>即使後面不加 <code>**</code> 預設也會將後面的值都包成一個 hash</p></blockquote>

<pre><code class="ruby">def sample(a=1, b=2, **c)
  puts [a, b, c].inspect
end

sample('j':4, 'q':5, 'k':6)
#=&gt; [1, 2, {:j=&gt;4, :q=&gt;5, :k=&gt;6}]

sample({'j':4, 'q':5, 'k':6}, 3, 4) # 放在前面加上 {}
#=&gt; [{:j=&gt;4, :q=&gt;5, :k=&gt;6}, 3, 4]
</code></pre>

<pre><code class="ruby"># 'b':1 傳入的值必須 key-value 並且要對到 key
def sample(a, b:2, c:3)  
  puts [a, b, c].inspect
end
sample('a':11, 'v':22, 'c':33, 's':44)
#=&gt; [{:a=&gt;11, :v=&gt;22, :c=&gt;33, :s=&gt;44}, 2, 3]

sample({'a':11, 'v':22, 'c':33, 's':44}, 'b':100)
#=&gt; [{:a=&gt;11, :v=&gt;22, :c=&gt;33, :s=&gt;44}, 100, 3]
</code></pre>

<pre><code class="ruby">def sample(a, b, **c) # sample(a, b, c)
  puts [a, b, c].inspect
end

sample(4, 'a':1) 
#=&gt; [4, {:a=&gt;1}, {}]

sample(4, 5, 'a':1, 'b':2, 'c':3)
#=&gt; [4, 5, {:a=&gt;1, :b=&gt;2, :c=&gt;3}]

sample(4, 'a':1, 'v':2, 'c':4)
#=&gt; [4, {:a=&gt;1, :v=&gt;2, :c=&gt;4}, {}]

sample({'z':5}, {'a':1, 'v':2}, 'c':4)
#=&gt; [{:z=&gt;5}, {:a=&gt;1, :v=&gt;2}, {:c=&gt;4}]

sample(4, {'a':1, 'v':2}, 'c':4)
#=&gt; [4, {:a=&gt;1, :v=&gt;2}, {:c=&gt;4}]
</code></pre>

<h3>另一種用法將 Hash 展開</h3>

<pre><code class="ruby">def sample(a, b, **c)
  puts [a, b, c].inspect
end

hash  = {:q=&gt;4, :w=&gt;5, :e=&gt;6}
hash2 = {:r=&gt;4, :t=&gt;{:y=&gt;5, :u=&gt;6}}
hash3 = {:i=&gt;4, :o=&gt;5}

sample(1,hash)
#=&gt;  [1, {:q=&gt;4, :w=&gt;5, :e=&gt;6}, {}]

sample(1,hash, hash2)
#=&gt; [1, {:q=&gt;4, :w=&gt;5, :e=&gt;6}, {:r=&gt;4, :t=&gt;{:y=&gt;5, :u=&gt;6}}]

#將兩個 hash 合併成一個
sample(1 ,**hash, **hash2)
#=&gt; [1, {:q=&gt;4, :w=&gt;5, :e=&gt;6, :r=&gt;4, :t=&gt;{:y=&gt;5, :u=&gt;6}}, {}]

#展開後，後面就可以繼續塞 hash
sample(1,2,**hash, 'foo':123, 'bar':456)
#=&gt; [1, 2, {:q=&gt;4, :w=&gt;5, :e=&gt;6, :foo=&gt;123, :bar=&gt;456}]
</code></pre>

<pre><code class="ruby">def sample(a:1, b:2, **c)
  puts [a, b, c].inspect
end

hash  = {:q=&gt;4, :w=&gt;5, :e=&gt;6}
hash2 = {:r=&gt;4, :t=&gt;{:y=&gt;5, :u=&gt;6}}
hash3 = {:i=&gt;4, :o=&gt;5}

sample(**hash, **hash2, 'b':100)
#=&gt; [1, 100, {:j=&gt;4, :q=&gt;5, :k=&gt;6, :c=&gt;{:q=&gt;5, :k=&gt;6}}]

sample(**hash, **hash2, 'test':100)
#=&gt; [1, 100, {:q=&gt;4, :w=&gt;5, :e=&gt;6, :r=&gt;4, :t=&gt;{:y=&gt;5, :u=&gt;6}}]

sample(**hash, **hash2, 'test':100, 'b':123)
#=&gt; [1, 123, {:q=&gt;4, :w=&gt;5, :e=&gt;6, :r=&gt;4, :t=&gt;{:y=&gt;5, :u=&gt;6}, :test=&gt;100}]
</code></pre>

<h1>&amp; 區塊傳遞</h1>

<p>若要調用在變數，前綴一個『&amp;』符號，並且要放在最後一個</p>

<pre><code class="ruby">class Array
  def iterate!(&amp;code)
    self.each_with_index do |n, i|
      self[i] = code.call(n)
    end
  end
end

array = [1, 2, 3, 4]

array.iterate! do |n|
  n ** 2
end

puts array.inspect
</code></pre>

<h1>綜合使用</h1>

<pre><code class="ruby">def sample(a, *b, **c, &amp;d)  
  puts "a=#{a}, b=#{b}, c=#{c}"  
  d.call(100)  
end  
sample(1,2,3,x:4,y:5) { |x| puts x }  

#=&gt; a=1, b=[2, 3], c={:x=&gt;4, :y=&gt;5}
#=&gt; 100
</code></pre>

<p>若最後面是 * 不限制長度，塞很多變數，或是後面接 hash 都不會錯</p>

<pre><code class="ruby">def sample(a, b, *c)
  puts [a, b, c].inspect
end

sample(1,2,3, 4, 5)
#=&gt; [1, 2, [3, 4, 5]]

sample(1,2,'a':1, 'b':2)
#=&gt; [1, 2, [{:a=&gt;1, :b=&gt;2}]]
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[用 Instance_eval & Class_eval 自己加 Method!]]></title>
    <link href="http://mgleon08.github.com/blog/2016/03/08/instance-eval-class-eval/"/>
    <updated>2016-03-08T22:46:28+08:00</updated>
    <id>http://mgleon08.github.com/blog/2016/03/08/instance-eval-class-eval</id>
    <content type="html"><![CDATA[<p>有時候會發現有些 object，沒有設定 setter &amp; getter ，剛好又需要用到，這時就可以派上用場拉。</p>

<!-- more -->


<h1>instance_eval &amp; class_eval</h1>

<p><code>instance_eval</code> Use ClassName.instance_eval to define a class method (one associated with the class object but not visible to instances).</p>

<p><code>class_eval</code> Use ClassName.class_eval to define an instance method (one that applies to all of the instances of ClassName).</p>

<p>簡單的來說，就是自己定義 class or instance 的 method</p>

<pre><code class="ruby">class MyClass
  def initialize(num)
    @num = num
  end
end

a = MyClass.new(1)
b = MyClass.new(2)
</code></pre>

<p>錯誤，因為沒有 getter or setter methods</p>

<pre><code class="ruby">a.num
#=&gt;NoMethodError: undefined method `num' for #&lt;MyClass:0x007fba5c02c858 @num="1"&gt;
</code></pre>

<p>自行加 instance method</p>

<pre><code class="ruby">a.instance_eval { @num }
#=&gt; 1
</code></pre>

<p>也可以直接定義 method，這樣就可以一直重複使用</p>

<pre><code class="ruby">a.instance_eval do
   def num
     @num
   end
end

a.num
#=&gt; 1
b.num
#NoMethodError: undefined method `num' for #&lt;MyClass:0x007fba5c08e5f8 @num="2"&gt;
</code></pre>

<p>上述指定義了 a 的 <code>instance method</code> 所以 b 會錯誤。<br/>
因此可以直接定義在 <code>class instance</code></p>

<pre><code class="ruby">MyClass.class_eval do
  def num
    @num
  end
end

a.num
#=&gt; 1
b.num
#=&gt; 2
</code></pre>

<p>參考文件：<br/>
<a href="http://web.stanford.edu/~ouster/cgi-bin/cs142-winter15/classEval.php">Understanding class_eval and instance_eval</a><br/>
<a href="http://openhome.cc/Gossip/Ruby/Eval.html">eval</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[有什麼事，就問 Ruby 吧!]]></title>
    <link href="http://mgleon08.github.com/blog/2016/03/08/ask-ruby/"/>
    <updated>2016-03-08T22:43:33+08:00</updated>
    <id>http://mgleon08.github.com/blog/2016/03/08/ask-ruby</id>
    <content type="html"><![CDATA[<p>ruby 有趣的事，什麼都可以問它XD</p>

<!-- more -->


<pre><code class="ruby">a = [1,2,3]

#問 a 的方法有哪些
a.methods
#=&gt; [:inspect, :to_s, :to_a, :to_h, :to_ary, :frozen?, :==, :eql?, :hash...]

a.public_methods    #取得實例上public方法
a.protected_methods #取得實例上protected方法
a.private_methods   #取得實例上private方法

a.instance_methods           #可取得類別或模組上定義的非private實例方法
a.public_instance_methods    #可取得類別或模組上定義的public實例方法
a.protected_instance_methods #可取得類別或模組上定義的protected實例方法
a.private_instance_methods   #可取得類別或模組上定義的private實例方法

a.instance_methods(false)
如果呼叫方法時加上false，表示僅取得類別或模組中定義的實例方法，排除繼承或含括而來的實例方法。

a.public_class_method  #取得public的模組或類別方法
a.private_class_method #取得private的模組或類別方法

local_variables    #區域變數清單
global_variables   #全域變數清單
instance_variables #物件的實例變數
class_variables    #類別或模組變數

defined? #知道變數是哪個範圍的變數 local? global?

#問它是否有這個方法
a.respond_to? :to_s
#=&gt; true

#問它的 class 是什麼
a.class
#=&gt; Array

#問爸爸的class 是什麼
Array.superclass  =&gt; Object   

#直接列出祖宗十八代
Array.ancestors
#=&gt; [Array, JSON::Ext::Generator::GeneratorMethods::Array, Enumerable, Object, ActiveSupport::Dependencies::Loadable, PP::ObjectMixin, JSON::Ext::Generator::GeneratorMethods::Object, Kernel, BasicObject]
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Double Colon(::) 是啥? 能吃嗎？]]></title>
    <link href="http://mgleon08.github.com/blog/2016/03/08/double-colon/"/>
    <updated>2016-03-08T22:42:03+08:00</updated>
    <id>http://mgleon08.github.com/blog/2016/03/08/double-colon</id>
    <content type="html"><![CDATA[<p>在 ruby 中常常會看到各種符號， 像是 <code>::</code> 在 ruby 就像是 <code>namespace</code> 的感覺。<br/>
<code>::</code> 加在最前面，就是會去參照最上面的 <code>namespace</code>。</p>

<!-- more -->


<pre><code class="ruby">MR_COUNT = 0        # constant defined on main Object class
module Foo
  MR_COUNT = 0
  ::MR_COUNT = 1    # set global count to 1
  MR_COUNT = 2      # set local count to 2
end
puts MR_COUNT       # this is the global constant
puts Foo::MR_COUNT  # this is the local "Foo" constant
</code></pre>

<pre><code class="ruby">module Foo
  # We may not know about this in real big apps
  module Rails
    class Engine 
    end
  end

  class Engine1 &lt; Rails::Engine
  end

  class Engine2 &lt; ::Rails::Engine
  end
end

Foo::Engine1.superclass
 =&gt; Foo::Rails::Engine # not what we want

Foo::Engine2.superclass
 =&gt; Rails::Engine # correct
</code></pre>

<p>參考文件：<br/>
<a href="http://blog.eddie.com.tw/2015/04/19/namespace/">Ruby 語法放大鏡之「有時候會看到有兩個冒號寫法是什麼意思?」</a><br/>
<a href="http://stackoverflow.com/questions/4819312/double-colons-before-class-names-in-ruby">Double colons before class names in Ruby?</a><br/>
<a href="http://stackoverflow.com/questions/10482772/rubys-double-colon-operator-usage-differences">Ruby&rsquo;s double colon (::) operator usage differences</a><br/>
<a href="https://cbabhusal.wordpress.com/2015/03/26/ruby-ruby-dot-and-double-colon-operators/">Ruby : Ruby dot “.” and double Colon “::” Operators</a></p>
]]></content>
  </entry>
  
</feed>
