<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Ruby | Leon's Blogging]]></title>
  <link href="http://mgleon08.github.com/blog/categories/ruby/atom.xml" rel="self"/>
  <link href="http://mgleon08.github.com/"/>
  <updated>2016-02-07T17:35:14+08:00</updated>
  <id>http://mgleon08.github.com/</id>
  <author>
    <name><![CDATA[LeonJi]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[用 Yaml 來寫文件]]></title>
    <link href="http://mgleon08.github.com/blog/2016/02/07/yaml/"/>
    <updated>2016-02-07T16:08:29+08:00</updated>
    <id>http://mgleon08.github.com/blog/2016/02/07/yaml</id>
    <content type="html"><![CDATA[<p>yaml 格式經常會在 rails 裡看到，像是 config 裡的 database.yml，或 en.yml<br/>
這種格式經常拿來寫一些固定的常數。</p>

<p>因此也可以拿來設定網頁中固定的像是選單之類的文件。</p>

<!-- more -->


<p>自訂 yaml</p>

<p><code>sample.yml</code></p>

<pre><code class="ruby">option:
  - a:  foo
    a1: bar
  - b:  foo
    b1: bar
  - c:  foo
    c1: bar
</code></pre>

<p><code>:</code> hash<br/>
<code>-</code> array</p>

<pre><code class="ruby">require "yaml"

SAMPLE = YAML.load(File.read(File.expand_path('../sample.yml', __FILE__))).freeze

#=&gt; {"option"=&gt;
#       [
#           {"a"=&gt;"foo", "a1"=&gt;"bar"}, 
#           {"b"=&gt;"foo", "b1"=&gt;"bar"}, 
#           {"c"=&gt;"foo", "c1"=&gt;"bar"}
#       ]
#   }
</code></pre>

<p>官方文件：<br/>
<a href="http://ruby-doc.org/stdlib-2.3.0/libdoc/yaml/rdoc/YAML/Store.html">Yaml</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[用 Marshal 來傳遞資料]]></title>
    <link href="http://mgleon08.github.com/blog/2016/02/07/marshal/"/>
    <updated>2016-02-07T15:44:52+08:00</updated>
    <id>http://mgleon08.github.com/blog/2016/02/07/marshal</id>
    <content type="html"><![CDATA[<p>當兩台 server 要互相傳遞資料時，都必須確保資料的正確性，因此可以透過 Marshal 解析後來傳遞。</p>

<!-- more -->


<p>一般可以用 <code>to_a</code>, <code>to_yml</code>, <code>to_s</code> 來轉成不同 <code>type</code><br/>
但這樣很可能會失真</p>

<p>因此用 Marshal 就會比較精準，並且快很多</p>

<pre><code class="ruby">h = {:a=&gt;1, "b"=&gt;2, Time.new=&gt;Class}

Marshal.dump(h)
#=&gt; "\x04\b{\b:\x06ai\x06I\"\x06b\x06:\x06ETi\aIu:\tTime\r\xE7\x04\x1D\x80r\xB6D\xC0\a:\voffseti\x02\x80p:\tzoneI\"\bCST\x06;\x06Fc\nClass"

File.open("test.txt", "w").write(Marshal.dump(h))

#在 irb 要先 exit 重開
Marshal.load(File.open("test.txt", "r").read)
#=&gt; {:a=&gt;1, "b"=&gt;2, Time.new=&gt;Class}
</code></pre>

<p>官方文件：<br/>
<a href="http://ruby-doc.org/core-2.2.0/Marshal.html">Marshal</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[用 Ruby 做網頁爬蟲]]></title>
    <link href="http://mgleon08.github.com/blog/2016/02/07/ruby-crawler/"/>
    <updated>2016-02-07T15:21:59+08:00</updated>
    <id>http://mgleon08.github.com/blog/2016/02/07/ruby-crawler</id>
    <content type="html"><![CDATA[<p>網頁爬蟲是一個蠻常聽到的名詞，簡單的來說就是可以透過程式，去分析網站頁面，將想要的資訊抓下來!</p>

<!-- more -->


<h3>wget</h3>

<p>command line 下載檔案的指令<br/>
mac 本身沒有內建要另外安裝。</p>

<pre><code>brew install wget
</code></pre>

<pre><code class="ruby">require "open-uri" #open-uri 把一個網頁當一個檔案來打開 stb-lib
require "nokogiri" #解析 html gem

html = open("http://ezprice.com.tw/").read
doc = Nokogiri::HTML(html)
ans = []

doc.search('img').each do |i|
  ans &lt;&lt; i.attr('src')
end

#將相對路徑改成絕對路徑
temp_ans = ans.map do 
  |url| url.match(/^http/) ? url : "http://ezprice.com.tw/#{url}"
end

#透過 wget 下載檔案到目前的資料夾
temp_ans.each do |full_url|
  `wget #{full_url}`
end
</code></pre>

<p><code>open-uri</code> 只能一個網址<br/>
<code>curb</code> 比較豐富</p>

<p>官方文件：<br/>
<a href="http://ruby-doc.org/stdlib-2.3.0/libdoc/open-uri/rdoc/index.html">open-uri</a><br/>
<a href="http://www.nokogiri.org/">nokogiri</a></p>

<p>參考文件：<br/>
<a href="https://www.youtube.com/watch?v=6XUnYRB0Zpo&amp;list=PLJ6M-k9dQEQ3VsyOZQwjZ5GdjaLJH3eB_">RailsFun</a><br/>
<a href="http://tonytonyjan.net/slides/2014-07-03-simple-crawler/">Ruby Crawler 輕輕鬆鬆做個 Ruby 爬蟲機器人</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Call System From Ruby]]></title>
    <link href="http://mgleon08.github.com/blog/2016/02/07/callsystem/"/>
    <updated>2016-02-07T14:31:31+08:00</updated>
    <id>http://mgleon08.github.com/blog/2016/02/07/callsystem</id>
    <content type="html"><![CDATA[<p>可以直接透過 ruby 來執行 commands 的指令。</p>

<!-- more -->


<h1>Calling shell commands from Ruby</h1>

<p>回傳的</p>

<ol>
<li>Kernel#`, commonly called backticks – <code>cmd</code></li>
</ol>


<p>Returns the result of the shell command.</p>

<pre><code class="ruby">value = `echo 'hi'`
value = `#{cmd}`
value.class
#=&gt; String 回傳結果
</code></pre>

<ol>
<li>Built-in syntax, <code>%x( cmd )</code></li>
</ol>


<p>Returns the result of the shell command, just like the backticks.</p>

<pre><code class="ruby">value = %x( echo 'hi' )
value = %x[ #{cmd} ]
</code></pre>

<ol>
<li>Kernel# <code>system</code></li>
</ol>


<p>Return: true if the command was found and ran successfully, false otherwise</p>

<pre><code class="ruby">wasGood = system( "echo 'hi'" )
wasGood = system( cmd )
wasGood.class
=&gt; TrueClass 回傳有沒有成功
</code></pre>

<ol>
<li>Kernel#exec</li>
</ol>


<p>Return: none, the current process is replaced and never continues</p>

<pre><code class="ruby">exec( "echo 'hi'" )
exec( cmd ) # Note: this will never be reached because of the line above
</code></pre>

<p>官方文件：<br/>
<a href="http://ruby-doc.org/core-2.3.0/Kernel.html">Kernel</a><br/>
<a href="http://ruby-doc.org/stdlib-2.3.0/libdoc/open3/rdoc/Open3.html#method-c-pipeline">Open3 - 可執行精密的操作</a></p>

<p>參考文件： <br/>
<a href="http://stackoverflow.com/questions/2232/calling-shell-commands-from-ruby">Calling shell commands from Ruby</a><br/>
<a href="http://tech.natemurray.com/2007/03/ruby-shell-commands.html">6 Ways to Run Shell Commands in Ruby Tuesday</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ruby 中的 Block & Yield & Proc & Lambda]]></title>
    <link href="http://mgleon08.github.com/blog/2016/02/06/block-yield-proc-lambda/"/>
    <updated>2016-02-06T10:37:37+08:00</updated>
    <id>http://mgleon08.github.com/blog/2016/02/06/block-yield-proc-lambda</id>
    <content type="html"><![CDATA[<p>在學 ruby 時，經常會搞不清楚這四個，因為都非常相像!</p>

<!-- more -->


<h1>block</h1>

<p>什麼是 block ?</p>

<p>在 ruby 中 <code>block</code> 就是只 <code>do..end</code> || <code>{}</code> 包起來的區塊，就稱為 <code>block</code>。</p>

<pre><code class="ruby">[1,2,3].each do |i|
    puts i
end
# =&gt; 1,2,3

[1,2,3].each {|i| puts i}

# =&gt; 1,2,3
</code></pre>

<p>基本上兩個是等價的，但是慣例上，一行會用 <code>{}</code> ，多行則是用 <code>do..end</code><br/>
<code>block</code> 無法單獨存在，必須放在 <code>method</code> 後面</p>

<p>另外 <code>block</code> 是可以傳遞的，用 <code>&amp;</code> 表示</p>

<h1>yield</h1>

<p><code>yield</code> 其實就是調用 <code>block</code> 的一種方式</p>

<pre><code class="ruby">class Array
  def iterate!
    self.each_with_index do |n, i|
      self[i] = yield(n)
    end
  end
end

array = [1, 2, 3, 4]

array.iterate! do |n|
  n ** 2
end

puts array.inspect

# =&gt; [1, 4, 9, 16]
</code></pre>

<p>其實就是再把 <code>&amp;block</code> 的寫法簡化</p>

<pre><code class="ruby">def test
  yield
end

def test(&amp;block)
  block.call
end
</code></pre>

<h1>procedure (proc)</h1>

<pre><code class="ruby">def who_am_i(&amp;block)
  block.class
end

puts who_am_i {}

# =&gt; Proc
</code></pre>

<p>有此理解，透過 <code>&amp;block</code> 將程式碼傳遞過去後，其實它就是 <code>proc</code>。</p>

<p>跟 <code>block</code> 不同的地方是，<code>proc</code> 是可保存的</p>

<pre><code class="ruby">pro = Proc.new {|a|  puts a}
#=&gt; &lt;Proc:0x007fcb23ad2640@(irb):1&gt;

pro = proc {|a|  puts a}
#=&gt; &lt;Proc:0x007fcb23ad2640@(irb):1&gt;

pro = Proc.new do |a|
  puts a
end

pro.call(123)
123
#=&gt;nil

pro.(123) #非正規用法
123
#=&gt;nil

pro(123)
123
#=&gt; 123
</code></pre>

<p>此時就會被 <code>p</code> 存起來，因此引用時就不需加上 <code>&amp;</code></p>

<h1>lambda</h1>

<p>lambda 與 method 用法相同，概念是一樣的<br/>
不同的是 <code>Method</code> 是有名字的method，而 <code>lambda</code> 是匿名 method</p>

<pre><code class="ruby">lam = lambda{|a| puts a}
#=&gt; &lt;Proc:0x007fcb23aa1860@(irb):1 (lambda)&gt;

lam.class
#=&gt; Proc 有此可知，lambda 的原型是 proc

lam = lambda do |a|
  puts a
end

lam(123)
#NoMethodError: undefined method `l' for main:Object

lam.(123) #非正規用法
123
#=&gt; nil

lam.call(123)
123
#=&gt; nil
</code></pre>

<p>lambda 跟 proc 非常類似，主要有兩個差異</p>

<h3>1.lambda 會檢查參數的個數</h3>

<pre><code class="ruby">def args(code)
  one, two = 1, 2
  code.call(one, two)
end

args(Proc.new{|a, b, c| puts "Give me a #{a} and a #{b} and a #{c.class}"})
# =&gt; Give me a 1 and a 2 and a NilClass

args(lambda{|a, b, c| puts "Give me a #{a} and a #{b} and a #{c.class}"})
# *.rb:8: ArgumentError: wrong number of arguments (2 for 3) (ArgumentError)
</code></pre>

<h3>2.lambda 的return 會繼續執行，proc 則會直接終止</h3>

<p><code>lambda</code> 比較像是一個 method 的 return <br/>
<code>proc</code> 則是比較像是 一整個 method 的 return</p>

<pre><code class="ruby">def proc_return
  Proc.new { return "Proc.new"}.call
  return "proc_return method finished"
end

def lambda_return
  lambda { return "lambda" }.call
  return "lambda_return method finished"
end

puts proc_return
Proc.new
#=&gt; nil

puts lambda_return
lambda_return method finished
#=&gt; nil
</code></pre>

<h3>使用時機</h3>

<p>在某些情況下，使用 <code>lambda</code> 會比 <code>proc</code> 還簡約。</p>

<pre><code class="ruby">def generic_return(code)
  one, two    = 1, 2
  three, four = code.call(one, two)
  return "Give me a #{three} and a #{four}"
end

puts generic_return(lambda { |x, y| return x + 2, y + 2 })

puts generic_return(Proc.new { |x, y| return x + 2, y + 2 })

puts generic_return(Proc.new { |x, y| x + 2; y + 2 })

puts generic_return(Proc.new { |x, y| [x + 2, y + 2] })

# =&gt; Give me a 3 and a 4
# =&gt; *.rb:9: unexpected return (LocalJumpError)
# =&gt; Give me a 4 and a
# =&gt; Give me a 3 and a 4

# proc 需再用 array 包覆起來
</code></pre>

<p>參考文件：<br/>
<a href="http://rubyer.me/blog/917/">理解Ruby的4种闭包：blocks, Procs, lambdas 和 Methods。</a><br/>
<a href="https://ruby-china.org/topics/10414">聊聊 Ruby 中的 block, proc 和 lambda</a></p>
]]></content>
  </entry>
  
</feed>
