<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Ruby | Leon's Blogging]]></title>
  <link href="http://mgleon08.github.com/blog/categories/ruby/atom.xml" rel="self"/>
  <link href="http://mgleon08.github.com/"/>
  <updated>2018-06-23T00:40:50+08:00</updated>
  <id>http://mgleon08.github.com/</id>
  <author>
    <name><![CDATA[LeonJi]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Ruby Logger]]></title>
    <link href="http://mgleon08.github.com/blog/2016/10/17/ruby-logger/"/>
    <updated>2016-10-17T17:47:38+08:00</updated>
    <id>http://mgleon08.github.com/blog/2016/10/17/ruby-logger</id>
    <content type="html"><![CDATA[<p>logger 可以方便我們去找尋問題在哪邊，因此設定好 logger 訊息是非常重要的</p>

<!-- more -->


<p>在 ruby 中，可以自定義 logger 的 level 還有 format，和輸出方式等等</p>

<pre><code class="ruby">#設定 logger 的輸出
logger = Logger.new(STDOUT)

#設定 logger level
logger.level = Logger::INFO

#設定 logger formatter
logger.formatter = proc do |severity, datetime, progname, msg|
  "#{msg}\n"
end
</code></pre>

<pre><code class="ruby"># Message in a block.
logger.fatal { "Argument 'foo' not given." }
# Message as a string.
logger.error "Argument #{@foo} mismatch."
# With progname.
logger.info('initialize') { "Initializing..." }
# With severity.
logger.add(Logger::FATAL) { 'Fatal error!' }
</code></pre>

<p>同時輸出到 terminal &amp; file</p>

<pre><code class="ruby">class Logger &lt; ::Logger
  class &lt;&lt; self
    def default(log)
      io = [STDOUT, log_file]
      logger = Logger.new(MultiIO.new(*io))
      logger.level = Logger::INFO
      logger.formatter = proc do |_severity, _datetime, _progname, msg|
        "#{msg}\n"
      end
      logger
    end

    def log_file
      time = Time.now.strftime('%Y-%m-%dT%H:%M:%S')
      FileUtils.mkdir_p('./sample')
      log_file = File.open("./sample/#{time}.log", 'a')
      log_file
    end
  end
end
</code></pre>

<pre><code class="ruby">class MultiIO
  def initialize(*targets)
    @targets = targets
  end

  def write(args)
    @targets.each { |target| target.write(args) }
  end

  def close
    @targets.each(&amp;:close)
  end
end
</code></pre>

<p>官方文件:</p>

<ul>
<li><a href="https://ruby-doc.org/stdlib-2.1.0/libdoc/logger/rdoc/Logger.html">logger</a></li>
<li><a href="http://rails.ruby.tw/debugging_rails_applications.html#logger">rails guide</a></li>
</ul>


<p>參考文件:</p>

<ul>
<li><a href="http://stackoverflow.com/questions/6407141/how-can-i-have-ruby-logger-log-output-to-stdout-as-well-as-file">How can I have ruby logger log output to stdout as well as file?</a></li>
<li><a href="http://stackoverflow.com/questions/14382252/how-to-format-ruby-logger">How to format ruby logger?</a></li>
<li><a href="https://www.sitepoint.com/rubyists-love-logging/">All Rubyists Love Logging</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Custom Config Setting]]></title>
    <link href="http://mgleon08.github.com/blog/2016/10/17/custom-config-setting/"/>
    <updated>2016-10-17T17:36:54+08:00</updated>
    <id>http://mgleon08.github.com/blog/2016/10/17/custom-config-setting</id>
    <content type="html"><![CDATA[<p>經常看到 rails 中有很多 config 的設定，像是 rspec 等等，會用一個 black 包起來就可以做設定了，那內部實作是如何?</p>

<!-- more -->


<pre><code class="ruby">module Mail
  class Configuration
    DEFAULT_VERSION  = 'v1'
    DEFAULT_API_KEY  = 'token'

    class &lt;&lt; self
      attr_writer :version, :api_key

      def configure(&amp;block)
        yield self
        self
      end

      def version
        @version ||= DEFAULT_VERSION
      end

      def api_key
        @api_key ||= DEFAULT_API_KEY
      end
    end
  end
end

Mail::Configuration.configure do |config|
  config.version = 1
  config.api_key = 2
end
</code></pre>

<p>或是另外一種寫法</p>

<pre><code class="ruby">module Mail
  module Config
    extend self

    attr_accessor :token
    attr_accessor :logger

    def reset
      self.token = nil
      self.logger = nil
    end

    reset
  end

  class &lt;&lt; self
    def configure
      block_given? ? yield(Config) : Config
    end

    def config
      Config
    end
  end
end

Mail.configure do |config|
  config.token = ENV['MAIL_API_TOKEN']
  config.logger = Logger.new(STDOUT)
  config.logger.level = Logger::INFO
  fail 'Missing ENV[MAIL_API_TOKEN]!' unless config.token
end
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[環境變數 Environment Variable]]></title>
    <link href="http://mgleon08.github.com/blog/2016/10/17/environment-variable/"/>
    <updated>2016-10-17T17:33:41+08:00</updated>
    <id>http://mgleon08.github.com/blog/2016/10/17/environment-variable</id>
    <content type="html"><![CDATA[<p>為什麼需要環境變數?</p>

<!-- more -->


<p>因為在 github 上面不會將一些敏感資料放在上面，ex: password, token..etc <br/>
所以這些資料就會在 sever 上面做設定，以免資料外漏</p>

<p>那要設定這些資料有兩種方式</p>

<h2>Config file</h2>

<p>第一種是之前有提過的，做一個 example 設定檔，在到每個server上面個別去做設定。</p>

<ul>
<li><a href="http://mgleon08.github.io/blog/2016/02/07/yaml/">用 Yaml 來寫文件, 設定檔</a></li>
</ul>


<h2>Environment variable</h2>

<p>在 <code>Unix shell</code> 直接設定環境變數</p>

<pre><code class="ruby">#通常會用全大寫，已表示固定的變數
export TOKEN=123
</code></pre>

<p>就能在 rails 中取得</p>

<pre><code class="ruby">ENV['TOKEN']
#=&gt; 123
</code></pre>

<p>但如果是在 <code>Unix shell</code> 下直接設定的話，只會存活在該 tab 底下，開新的 tab 就會消失，因此如果希望能一直存在的話，可以設定在 <code>~/.zshrc</code> or <code>~/.bashrc</code></p>

<blockquote><p>echo $SHELL 可以看是使用哪個 SHELL</p></blockquote>

<h2>Gem</h2>

<p>ruby 也有一些 gem 可以很方便的設定</p>

<ul>
<li><a href="https://github.com/laserlemon/figaro">figaro</a></li>
<li><a href="https://github.com/bkeepers/dotenv">dotenv</a></li>
</ul>


<p>參考文件：</p>

<ul>
<li><a href="http://railsapps.github.io/rails-environment-variables.html">Rails Environment Variables</a></li>
<li><a href="http://braavos.me/blog/2014/08/05/rails-env/">Rails的環境變數</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[I/O 輸入輸出]]></title>
    <link href="http://mgleon08.github.com/blog/2016/08/30/io/"/>
    <updated>2016-08-30T10:32:37+08:00</updated>
    <id>http://mgleon08.github.com/blog/2016/08/30/io</id>
    <content type="html"><![CDATA[<p>先來說說什麼是 IO</p>

<!-- more -->


<blockquote><ul>
<li>所謂「I/O」，是input/output(輸出入) 的縮寫，泛指所有的輸出入動作。</li>
<li>我們從鍵盤上輸入資料、移動滑鼠、由掃描器輸入影像、從磁碟機讀入檔案，都是屬於輸入的動作；從印表機印出報表、顯示圖形到螢幕、將執行結果存入磁碟中，都是屬於輸出的一種。</li>
<li>I/O也指磁碟機的存取、或是通訊埠的接收資料和傳送資料等動作，一般都是針對可兼做輸出和輸入的設備。</li>
</ul>
</blockquote>

<p>由以上可知，當我們鍵盤上打字，就是一種輸入的動作，再 terminal 顯示我們輸入的字，就是一種輸出的動作</p>

<h1>ruby IO</h1>

<ul>
<li>標準輸入：$stdin</li>
<li>標準輸出：$stdout</li>
<li>標準錯誤輸出：$stderr</li>
<li>命令列引數的陣列: ARGV</li>
</ul>


<h3>標準輸出 vs 標準錯誤輸出</h3>

<pre><code class="ruby">#io.rb
$stdout.print  "標準輸出"
$stderr.print  "標準錯誤輸出"

#執行 ruby io.rb &gt; log.txt，會發現 console 只會顯示 '標準錯誤輸出'，而標準輸出則會輸出到 log.txt
</code></pre>

<pre><code class="ruby">##&lt;IO:&lt;STDIN&gt;&gt;
STDIN
$stdin

##&lt;IO:&lt;STDOUT&gt;&gt;
$&gt;
STDOUT
$stdout

#雖然有很多種表示法，但是比較偏好 $stdin，因為再 ruby 全大寫通常是常數，會讓人誤會，另一個則是不懂的人難以理解
</code></pre>

<h3>輸入 input</h3>

<p><code>$stdin.gets</code></p>

<pre><code class="ruby">$stdin.gets
&gt; hello
#=&gt; "hello\n"
</code></pre>

<p><code>#chomp!</code> 去除掉 \n</p>

<pre><code class="ruby">$stdin.gets.chomp!
&gt; hello
#=&gt; "hello"
</code></pre>

<p><code>#eof?</code> 判斷是否讀到最後</p>

<pre><code class="ruby">io = File.open( 'ruby.rb' , "r" )
io.eof?
#=&gt; false
io.gets
#=&gt; "1\n"
io.eof?
#=&gt; false
io.gets
#=&gt; "2\n"
io.gets
#=&gt; nil
io.eof?
#=&gt; true
</code></pre>

<p><code>#getc</code> 每次讀取一個字元</p>

<pre><code class="ruby">io = open( 'ruby.rb' , "r" )
io.getc
#=&gt; "1"
io.getc
#=&gt; "\n"

#會被主動轉換成 ASCII 編碼，因此第二個會讀出 \n
</code></pre>

<p><code>io.read</code> 指定讀取長度，預設為全部</p>

<pre><code class="ruby">io = open( 'ruby.rb' , "r" )
io.read
#=&gt; "1\n2\n3"
io.rewind
=&gt; 0
io.read(3)
#=&gt; "1\n2"
</code></pre>

<h3>輸出 output</h3>

<pre><code class="ruby">#adds a new line character
#is an equivalent to the $stdout.puts
puts 'a'
#=&gt;a\n

#is an equivalent to the $stdout.print
printf 'a'
#a

#prints one character to the console
putc 97
#a=&gt; 97

#p calls the inspect method upon the object being printed, The method is useful for debugging.
p "a"
#=&gt; 'a'

a = StringIO.new
#=&gt; #&lt;StringIO:0x007fc9a08813e8&gt;
a.puts(123)
#=&gt; nil
a.rewind
#=&gt; 0
a.gets
#=&gt; "123\n"
</code></pre>

<h3>指標</h3>

<p>資料流的存取方法，有區分成「固定長度」與「非固定長度」</p>

<ul>
<li><p>固定長度的讀取方式</p>

<ul>
<li>優點：讀取速度快，資料都以固定的長度儲存，可以很快的找到指定的位置</li>
<li>缺點：浪費空間，即使用不到大的空間也是會空下位置</li>
</ul>
</li>
<li><p>非固定長度的讀取方式</p>

<ul>
<li>優點：省空間，有用到才會有空間</li>
<li>缺點：讀取速度慢，每次讀取資料時，都必須從頭開始讀取</li>
</ul>
</li>
</ul>


<pre><code class="ruby">io.rewind  #將指標移到最前面

io.pos     #目前指標位置

io.seek(位置, 方式) #指定位置
#方式有三種：
#SEEK_SET ： 直接移動到指定位置
#SEEK_CUR ： 移動到目前位置的相對位置
#SEEK_END ： 移動到檔尾算起的相對位置

io.truncate(0)
io.truncate(io.pos)
#引數為 0 的話，表示全部清空
#引數為 io.pos 的話，表示將目前指標後的檔案全清空
</code></pre>

<pre><code class="ruby">io = File.open("ruby.rb", 'a+')
io.write("123")
#=&gt; 3
io.read
#=&gt; ""

#因為 a 若有檔案在會寫在檔案後面，此時指標會指向最後面，因此可以用 rewind 將指標移致最前面
io.rewind
io.read
#=&gt; 123
</code></pre>

<h1>Readline</h1>

<blockquote><p>The Readline module provides interface for GNU Readline. This module defines a number of methods to facilitate completion and accesses input history from the Ruby interpreter. This module supported Edit Line(libedit) too. libedit is compatible with GNU Readline.</p></blockquote>

<p>GNU的readline是一個開源的跨平台程序庫，提供了交互式的文本編輯功能</p>

<p><a href="http://ruby-doc.org/stdlib-2.1.1/libdoc/readline/rdoc/Readline.html">Readline</a></p>

<h1>stringIO 物件</h1>

<ul>
<li><a href="http://ruby-doc.org/stdlib-2.3.0/libdoc/stringio/rdoc/StringIO.html">StringIO</a></li>
</ul>


<p>設一個能夠儲存字串的物件</p>

<blockquote><p>Pseudo I/O on String object.<br/>
Commonly used to simulate <code>$stdio</code> or <code>$stderr</code></p></blockquote>

<p>此時對 io 操作 puts 並不會真正的輸出，而是將字串存入 io 物件之中</p>

<pre><code class="ruby">io = StringIO.new
io.puts("A")
io.puts("B")
io.puts("C")
io.rewind
p io.read

#"A\nB\nC\n"
</code></pre>

<h1>檔案輸出入</h1>

<p>File 繼承自 IO</p>

<blockquote><p>File.new 與 File.open 和 IO.new 與 IO.open 幾乎一樣，只差在覆寫了 initialize 方法，使其接受的參數不再是 FD 而是檔案的路徑字串。</p></blockquote>

<ul>
<li><a href="http://ruby-doc.org/core-2.1.5/File.html">File</a></li>
<li><a href="http://mgleon08.github.io/blog/2016/01/31/ruby-file-dir/">用 Ruby 進行 File ＆ Dir 檔案操作</a></li>
</ul>


<pre><code class="ruby"># r  讀取，檔案必須存在
# w  會主動建立空檔案，檔案已存在則會被覆蓋
# a  寫入。主動建檔，檔案已存在則追加在後。
# r+ 讀取 / 寫入，不會主動建檔，將內容加在檔案最前面，會覆蓋原有內容，檔案必須存在)
# w+ 讀取 / 寫入。同 w 功能
# a+ 讀取 / 寫入。同 a 功能

#在每個模式後面加上"b"
#例如 "rb" 或 "rb+"，就可以開啟「二進位」模式 

io = File.new("ruby.rb", "w")
io = File.open("/home/work/ruby.rb")
io.close
io.closed? #檢查是否關閉
#若後面沒有 block (結束會自動關閉) 必須要再加上，io.close，關閉檔案，否則會出錯
</code></pre>

<pre><code class="ruby"># 打開檔案，並寫入文字（若沒檔案會直接新增）
File.open('langs', 'w') do |f|
  f.puts "Ruby"
  f.write "Java\n"
  f &lt;&lt; "Python\n"
end
</code></pre>

<pre><code class="ruby">#查看檔案是否存在，建立時間，檔案大小
puts File.exists? 'tempfile'

f = File.new 'tempfile', 'w'
puts File.mtime 'tempfile'
puts f.size

File.rename 'tempfile', 'tempfile2'

f.close
</code></pre>

<pre><code class="ruby">#逐一行印出
f = File.open("stones")
while line = f.gets do
    puts line
end
f.close

#逐一行顯示
File.open( "ruby.rb" , "r" ) do |f|
    while line = f.gets
      puts line
    end
end
</code></pre>

<pre><code class="ruby">#刪除檔案
File.delete("/home/work/ruby.rb")

#讀取檔案
File.read("ruby.rb")
</code></pre>

<blockquote><h3>IO 的世界相當大啊，還有很多沒有提及，以後若有機會接觸到比較深的再來研究~.~</h3></blockquote>

<ul>
<li><a href="http://mgleon08.github.io/blog/2016/01/31/ruby-file-dir/">用 Ruby 進行 File ＆ Dir 檔案操作</a></li>
<li><a href="http://mgleon08.github.io/blog/2016/02/07/callsystem/">用 Ruby 來 Calling Shell Commands</a></li>
</ul>


<p>官方文件：</p>

<ul>
<li><a href="http://ruby-doc.org/core-2.2.2/IO.html">IO</a></li>
<li><a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/stringio/rdoc/StringIO.html">StringIO</a></li>
<li><a href="http://ruby-doc.org/core-2.1.5/File.html">File</a></li>
<li><a href="https://ruby-doc.org/core-2.2.0/Dir.html">Dir</a></li>
<li><a href="http://ruby-doc.org/core-2.3.1/Kernel.html">Kernel</a></li>
<li><a href="http://ruby-doc.org/stdlib-2.1.1/libdoc/readline/rdoc/Readline.html">Readline</a></li>
</ul>


<p>參考文件：</p>

<ul>
<li><a href="http://zetcode.com/lang/rubytutorial/io/">Input &amp; output in Ruby</a></li>
<li><a href="https://blog.alphacamp.co/2016/06/30/ruby-open/">Ruby#open 知多少？</a></li>
<li><a href="http://rpg0822.pixnet.net/blog/post/2844850-ruby-%E7%AD%86%E8%A8%98---7----%E8%A9%B2%E6%AD%BB%E7%9A%84-io-">Ruby 筆記 - 7 - 該死的 IO</a></li>
<li><a href="http://stackoverflow.com/questions/4279604/what-is-the-difference-between-stdin-and-stdin-in-ruby">What is the difference between STDIN and $stdin in Ruby?</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ERB Template]]></title>
    <link href="http://mgleon08.github.com/blog/2016/08/30/erb-template/"/>
    <updated>2016-08-30T10:31:47+08:00</updated>
    <id>http://mgleon08.github.com/blog/2016/08/30/erb-template</id>
    <content type="html"><![CDATA[<p>相信學過 rails 一定知道 erb，可以很方便地將 ruby code 寫在 view 中</p>

<!-- more -->


<p>但不一定是要有 rails 才可以用 erb</p>

<pre><code class="ruby">#template.rb
require 'erb'

class Template
  def initialize(foo, bar)
    @foo = foo
    @bar = bar
  end

  def open_template
    puts ERB.new(File.read(templates_path), nil).result(binding)
  end

  def templates_path
    File.expand_path("../template.erb", __FILE__)
  end
end

Template.new('hi', 'hello').open_template
</code></pre>

<pre><code class="ruby">#template.erb
1. &lt;%= @foo %&gt;
2. &lt;%= @bar %&gt;
</code></pre>

<pre><code class="ruby">#執行
ruby template.rb
#1. hi
#2. hello
</code></pre>

<h3>也可以利用 erb 來寫設定檔</h3>

<ul>
<li><a href="http://mgleon08.github.io/blog/2016/02/07/yaml/">用 Yaml 來寫文件, 設定檔</a></li>
</ul>


<p>參考文件：</p>

<ul>
<li><a href="http://ruby-doc.org/stdlib-2.3.1/libdoc/erb/rdoc/ERB.html">ERB doc</a></li>
<li><a href="http://stackoverflow.com/questions/1338960/ruby-templates-how-to-pass-variables-into-inlined-erb">Ruby templates: How to pass variables into inlined ERB?</a></li>
<li><a href="http://stackoverflow.com/questions/8954706/render-an-erb-template-with-values-from-a-hash">Render an ERB template with values from a hash</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
