<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Ruby | Leon's Blogging]]></title>
  <link href="http://mgleon08.github.com/blog/categories/ruby/atom.xml" rel="self"/>
  <link href="http://mgleon08.github.com/"/>
  <updated>2016-05-17T20:22:26+08:00</updated>
  <id>http://mgleon08.github.com/</id>
  <author>
    <name><![CDATA[LeonJi]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Ruby 中的數字 & BigDecimal]]></title>
    <link href="http://mgleon08.github.com/blog/2016/05/07/ruby-math/"/>
    <updated>2016-05-07T10:42:25+08:00</updated>
    <id>http://mgleon08.github.com/blog/2016/05/07/ruby-math</id>
    <content type="html"><![CDATA[<p>在程式中的運算可能跟我們平常接觸的會不一樣，ruby 也是!因此來瞭解一下吧!</p>

<!-- more -->


<p><img src="http://ithelp.ithome.com.tw/upload/images/20141005/20141005190053543124e558797_resize_600.png" alt="" /></p>

<h1>integer</h1>

<pre><code class="ruby">1.class
#=&gt; Fixnum
(2/3).class
#=&gt; Fixnum
#20 位數會開始變成 Bignum
('1'+'0'*18).to_i.class
#=&gt; Fixnum
('1'+'0'*19).to_i.class
#=&gt; Bignum
1.2.to_i
#=&gt; 1
</code></pre>

<h1>float</h1>

<p>只要分子或分母出現浮點數，結果才會是 float</p>

<blockquote><p>兩個運算元皆為整數，則會進行截尾整數除法(truncating integer division)運算</p></blockquote>

<pre><code class="ruby">3.14.class
#=&gt; Float
1/2
#=&gt; 0
1/2.0
#=&gt; 0.5
1.0/2
#=&gt; 0.5
1.to_f
#=&gt; 1.0
</code></pre>

<h1>運算</h1>

<pre><code class="ruby">餘數
10%3
#=&gt; 1

次方
2**10
#=&gt; 1024
2**-1
#=&gt; (1/2)

絕對值
-1234.abs
#=&gt; 1234

四捨五入
(3.3).round
#=&gt; 3
(4.5).round
#=&gt; 5

回傳小於該數學的最大整數
(2.1).floor
#=&gt; 2
(-2.1).floor
#=&gt; -3

回傳大於該數學的最小整數
(2.1).ceil
#=&gt; 3
(-2.1).ceil
#=&gt; -2

#只適用於Fixnum
2.zero?
#=&gt; false
0.zero?
#=&gt; true

1.0 / 0    # Infinity
-1.0 / 0   # -Infinity
0.0 / 0.0  # NaN
</code></pre>

<h1>BigDecimal</h1>

<p>主要是用來做精確的數字</p>

<pre><code class="ruby">sum = 0
for i in (1..10000)
  sum = sum + 0.0001
end
print sum
#=&gt; 0.9999999999999062
#因為在電腦中的浮點數其實只是近似值，浮點數中的整數可能只是精確度到達一定程度而已
</code></pre>

<pre><code class="ruby">require 'bigdecimal'

sum = BigDecimal.new("0")
for i in (1..10000)
  sum = sum + BigDecimal.new("0.0001")
end
print sum
#=&gt; 0.1E1

E代表後面有幾個10的次方
0.1E1 = 0.1 * (10**1)
#=&gt; 1.0
0.2E1 = 0.2 * (10**1)
#=&gt; 2.0
0.2E2 = 0.2 * (10**2)
#=&gt; 20.0
2E3   =   2 * (10**3)
#=&gt; 2000.0
</code></pre>

<p>官方文件：<br/>
<a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/bigdecimal/rdoc/BigDecimal.html">BigDecimal</a></p>

<p>參考文件：<br/>
<a href="http://blog.annideas.com/2014/10/05/ruby-girl-5-ruby-math-intro/">Ruby的數學跟老師教的數學都不一樣？</a><br/>
<a href="https://gradyli.wordpress.com/2007/11/16/numeric-class/">[Ruby教學]Numeric Class</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Method Missing]]></title>
    <link href="http://mgleon08.github.com/blog/2016/04/19/method-missing/"/>
    <updated>2016-04-19T22:18:09+08:00</updated>
    <id>http://mgleon08.github.com/blog/2016/04/19/method-missing</id>
    <content type="html"><![CDATA[<p>當 ruby 找不到 method 就會 call 這個 method</p>

<!-- more -->


<pre><code class="ruby">class Post
  #自己建立 method_missing 呼叫
  def method_missing(method_name, *args)
    puts "You tried to call #{method_name} with these arguments: #{args}"
    super #default method_missing handling raises a NoMethodError
  end
end
Post.new.submit(1, "Here's a post.")
</code></pre>

<p>用找不到 method 會 call <code>method_missing</code> 的特性，直接自己定義 method_missing 去定義呼叫其他的 method</p>

<blockquote><p>它的執行效率並不好，所以只適合用在沒辦法預先知道方法名稱的情況下</p></blockquote>

<pre><code class="ruby">class Post
  DELEGATED_METHODS = [:username, :avatar]
  def initialize(user)
    @user = user
  end

  def method_missing(method_name, *args)
    if DELEGATED_METHODS.include?(method_name)
      @user.send(method_name, *args)
    else
      super #沒有在設定的 DELEGATED_METHODS 裡面，就呼叫 default method_missing handling raises a NoMethodError
    end
  end 
end
</code></pre>

<pre><code class="ruby">class Post
  def initialize(text)
    @text = text
  end
  def to_s
    @text
  end
  def method_missing(method_name, *args)
    match = method_name.to_s.match(/^hash_(\w+)/) #找前面是 hash_
    if match
      @text &lt;&lt; " #" + match[1]
    else
      super 
    end
  end
￼end


post = Post.new("HI")
post.hash_ruby
post.hash_metaprogramming
puts post
#=&gt; HI #ruby #metaprogramming
</code></pre>

<h3>respond_to?</h3>

<pre><code class="ruby">post = Post.new 
post.respond_to?(:to_s) # =&gt; true
post.hash_ruby #再 method_missing 有定義所以呼叫得到
post.respond_to?(:hash_ruby) # =&gt; false #但在 respond_to 卻回傳 false
</code></pre>

<p>因此必須自己定義 respond_to?</p>

<pre><code class="ruby">class Post
  def respond_to?(method_name)
    method_name =~ /^hash_\w+/ || super
  end 
end
</code></pre>

<p>但是 <code>post.method(:hash_ruby)</code> 還是會出現 <code>NameError: undefined method</code></p>

<p>所以要改成另一個 <code>respond_to_missing?</code></p>

<pre><code class="ruby">class Post
  def respond_to_missing?(method_name) 
    method_name =~ /^hash_\w+/ ||super
  end 
end
</code></pre>

<h1>￼DEFINE_METHOD REVISITED</h1>

<pre><code class="ruby">class Post
  def initialize(text)
    @text = text
  end
  def to_s
    @text
  end
  def method_missing(method_name, *args)
    match = method_name.to_s.match(/^hash_(\w+)/)
    if match #有 match 到 hash_ 就建立出新的 method
      self.class.class_eval do
        define_method(method_name) do
          @text &lt;&lt; " #" + match[1]
        end
      end 
      send(method_name) #並且呼叫 method
    else
      super #沒有就 raises a NoMethodError
    end
  end
end

#當 call post.hash_codeschool 就會定義出下面的 method 

def hash_codeschool
  @text &lt;&lt; " #" + "codeschool"
end
</code></pre>

<p>官方文件：<br/>
<a href="http://apidock.com/ruby/BasicObject/method_missing">method_missing</a><br/>
<a href="http://ruby-doc.org/core-2.2.0/MatchData.html">MatchData</a><br/>
<a href="http://ruby-doc.org/core-2.1.1/Regexp.html">Regexp</a></p>

<p>參考文件：  <br/>
<a href="https://ihower.tw/blog/archives/4797">如何設計出漂亮的 Ruby APIs</a><br/>
<a href="https://ruby-china.org/topics/3434">method_missing，一個Ruby 程序員的夢中情人</a><br/>
<a href="http://stackoverflow.com/questions/13793060/respond-to-vs-respond-to-missing">respond_to? vs. respond_to_missing?</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Dynamic Classes & Methods (Struct, Send(), Alias_method, Alias_attribute, Define_method)]]></title>
    <link href="http://mgleon08.github.com/blog/2016/04/19/dynamic-classes-and-methods/"/>
    <updated>2016-04-19T22:16:35+08:00</updated>
    <id>http://mgleon08.github.com/blog/2016/04/19/dynamic-classes-and-methods</id>
    <content type="html"><![CDATA[<p>ruby 可以很方便的動態產生 Classes 和 Methods</p>

<!-- more -->


<h1>Struct</h1>

<pre><code class="ruby">class Post
  attr_accessor :user, :status
  def initialize(user, status)
    @user, @status = user, status
  end 

  def to_s
    "#{user}: #{status}"
  end
end

#上下相等

Post = Struct.new(:user, :status) do 
  def to_s
    "#{user}: #{status}"
  end
end
</code></pre>

<h1>send()</h1>

<pre><code class="ruby">post.say
= post.send(:say)
= post.send("say")

#也可以 call 到 private 的 method
</code></pre>

<h1>alias_method</h1>

<pre><code class="ruby">class Post
  attr_reader :foo #=&gt; return @foo
  #一定要在定義好的 method 後面還 call 得到
  alias_method :bar, :foo #=&gt; the same method 別名/原名

  def initialize(foo = [])
    @foo = foo
  end
end
</code></pre>

<h1>alias_attribute</h1>

<pre><code class="ruby">class Content &lt; ActiveRecord::Base
  # has a title attribute
end

class Email &lt; Content
  alias_attribute :subject, :title
end

e = Email.find(1)
e.title    # =&gt; "Superstars"
e.subject  # =&gt; "Superstars"
e.subject? # =&gt; true
e.subject = "Megastars"
e.title    # =&gt; "Megastars"
</code></pre>

<h1>define_method</h1>

<pre><code class="ruby">
class Post
  def draft
    @status = :draft
  end

  def posted
    @status = :posted
  end

  def deleted
    @status = :deleted
  end
end

#上下相等

class Post
  states = [:draft, :posted, :deleted]
  states.each do |status|
    define_method status do
      @status = status
    end
  end 
end
</code></pre>

<h1>method()</h1>

<pre><code class="ruby">
class Post
  def initialize(foo)
    @posts = posts
  end
  def contents
    @foo
  end
  def show_tweet(index)
    puts @foo[index]
  end 
end
</code></pre>

<pre><code class="ruby">
foo = ['Compiling!', 'Bundling...']
post = Post.new(foo)

content_method = post.method(:contents)
content_method.call
#=&gt; ["Compiling!", "Bundling..."]

show_method = post.method(:show_tweet)

￼(0..1).each(&amp;show_method)
￼#上下相等
show_method.call(0)
show_method.call(1)
</code></pre>

<h1>EX: log_method</h1>

<pre><code class="ruby">
class MethodLogger
  def log_method(klass, method_name)
    klass.class_eval do
      alias_method "#{method_name}_original", method_name
      define_method method_name do |*args, &amp;block|
        puts "#{Time.now}: Called #{method_name}"
        send "#{method_name}_original", *args, &amp;block
      end
    end
  end
end

class Post
  def say_hi
    puts "Hi"
  end
end

logger = MethodLogger.new
logger.log_method(Post, :say_hi)
Post.new.say_hi

#=&gt; 2016-04-05 12:14:01 +0800: Called say_hi
#=&gt; Hi
</code></pre>

<p>官方文件：<br/>
<a href="http://ruby-doc.org/core-2.2.0/Struct.html">Struct</a><br/>
<a href="http://apidock.com/ruby/Object/__send__">send()</a><br/>
<a href="http://apidock.com/ruby/Module/alias_method">alias_method()</a><br/>
<a href="http://apidock.com/ruby/Module/define_method">method define_method</a></p>

<p>參考文件：<br/>
<a href="http://stackoverflow.com/questions/3337285/what-does-send-do-in-ruby">What does send() do in Ruby?</a><br/>
<a href="https://gist.github.com/plusor/6104625">alias vs alias_method</a>  <br/>
<a href="https://ihower.tw/blog/archives/4797">如何設計出漂亮的 Ruby APIs</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Module vs Class]]></title>
    <link href="http://mgleon08.github.com/blog/2016/03/26/module-and-class/"/>
    <updated>2016-03-26T09:34:18+08:00</updated>
    <id>http://mgleon08.github.com/blog/2016/03/26/module-and-class</id>
    <content type="html"><![CDATA[<p>在 ruby 中經常會使用到 <code>Class</code>，也常常看到 <code>Module</code>
那到底什麼時候要用哪個?</p>

<!-- more -->


<p>先看看兩者的差異</p>

<h1>Module</h1>

<ul>
<li>無法 instantiated（也就是沒有 new method）</li>
<li>可以被 include &amp; extend</li>
</ul>


<h1>Class</h1>

<ul>
<li>可以 instantiated</li>
<li>無法被 include</li>
</ul>


<p>簡單的來說，module 有點像是沒有 new 的 Class</p>

<p>並且可以用 <code>include</code> &amp; <code>extend</code> mixin 到 Class 裡面，變成 Class 的 <code>class method</code> or <code>instance method</code></p>

<p><a href="http://mgleon08.github.io/blog/2016/02/24/include-extend-require/">Ruby 中的 Include Extend Require Load</a></p>

<p>基本上兩種方式都有辦法達成同樣的效果，但差別就在於維護上</p>

<h1>維護</h1>

<p>用 Class 的話，勢必一定要先 new 出來，並且預設會執行 <code>initialize</code> 這個method<br/>
就可以預先設定好一些參數，看起來就會比較簡潔</p>

<pre><code class="ruby">class Pepole
  def initialize(name)
    @name = name
  end

  def hi
    "hi, #{@name}"
  end

  def yo
    "yo, #{@name}"
  end
end

p = People.new('leon')
p.hi #=&gt; 'hi leon'
p.yo #=&gt; 'yo leon'
</code></pre>

<p>用 Module 的話，就必須每次呼叫 <code>hi</code> <code>yo</code> method 時都要在傳入參數進去。</p>

<pre><code class="ruby">module Man
  def hi(name)
    "hi, #{@name}"
  end

  def yo
    "yo, #{@name}"
  end
end

Man.hi('leon') #=&gt; 'hi leon'
Man.yo('leon') #=&gt; 'yo leon'
</code></pre>

<p>另外是當 Class include 很多 module 時，都會變成 Class 的 <code>class method</code> or <code>instance method</code>，這時就很難去分辨是從哪個 module 來的 method。</p>

<p>因此使用上，看習慣，可維護性等等，去判斷要用 module or class<br/>
再細分要放在 <code>cocern</code> or <code>service object</code> or <code>lib</code></p>

<p>參考文件：<br/>
<a href="http://mgleon08.github.io/blog/2016/02/24/include-extend-require/">module include extend</a>
<a href="http://railsfun.tw/t/class-module-class/402">class與module的差異? class如何繼承</a><br/>
<a href="http://stackoverflow.com/questions/151505/difference-between-a-class-and-a-module">Difference between a class and a module</a><br/>
<a href="http://motion-express.com/blog/20141011-rails-module-model">Rails利用Module整理Model
</a><br/>
<a href="http://motion-express.com/blog/20141209-ruby-class-inheritance">Ruby class 基本的覆寫(override)及繼承(inheritance)</a><br/>
<a href="http://motion-express.com/blog/20141208-class-method-and-instance-method">Ruby當中的class method和instance method差在哪？</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[用 Concern 來整理 Code]]></title>
    <link href="http://mgleon08.github.com/blog/2016/03/26/concern/"/>
    <updated>2016-03-26T09:32:30+08:00</updated>
    <id>http://mgleon08.github.com/blog/2016/03/26/concern</id>
    <content type="html"><![CDATA[<p>當有相當多地方用到同樣的東西時，就可以用 concern 來讓 code 變得更乾淨。</p>

<!--more-->


<h1>使用時機</h1>

<ul>
<li>DRYing up model codes</li>
<li><p>Skin Fat Models.</p></li>
<li><p>將可重用的功能抽出來，讓多個 model 共用</p></li>
<li>model 太肥大，將相關的邏輯的 code 放到不同的 concern 裡</li>
<li>ActiveSupport::Concern 的風格</li>
</ul>


<h1>ActiveSupport::Concern</h1>

<p>任務是讓管理 modules 之間的 dependencies 變得容易。<br/>
也可以用 <code>include</code> 同時達成 <code>class methods</code> <code>instance methods</code>
（原本必須 include + extend 才能達成）</p>

<h1>原本作法</h1>

<pre><code class="ruby"># app/models/concerns/sample.rb

module Sample
  include Sample2
  # self.included 會在 Sample 被 include 時執行
  # base 傳入是誰哪個 Class include 了這個 module
  def self.included(base)
    base.class_eval do # 用 class_eval 在該 class 新增 Class method
      #scope :disabled, -&gt; { where(disabled: true) } 可以定義 scope
      #has_many :post 可以定義關聯
      def self.foo
          "這裡是 class 的 method"
      end
    end
  end

  def bar
     "這裡是 instance 的 method"
  end
end
</code></pre>

<pre><code class="ruby">#app/models/test.rb
class Test &lt; ActiveRecord::Base
  include Samples
end

Test.foo
=&gt; "這裡是 class 的 method"

Test.new.bar
=&gt; "這裡是 instance 的 method"
</code></pre>

<p>兩個 module 可以互相 include</p>

<pre><code class="ruby"># app/models/concerns/sample2.rb
module Sample2
  def self.included(base)
    base.class_eval do
      #do something method
    end
  end
end
</code></pre>

<pre><code class="ruby">#app/models/test.rb
class Test &lt; ActiveRecord::Base
  include Sample
  # include Sample，再透過 Sample 去 include Sample2 ,這樣就不用一次 include 兩個 module了
end
</code></pre>

<p>以上看起來蠻理想的<br/>
但因為 include <code>Sample2</code> 的是 <code>Sample</code><br/>
所以 <code>Sample2</code> 的 base 就變成了 <code>Sample</code> ， 不是我們要的 <code>Test</code></p>

<h1>更改</h1>

<pre><code class="ruby"># app/models/concerns/sample.rb
module Sample
  include Sample2
  extend ActiveSupport::Concern
    included do
      self.send(:method) # base 改成 self
    end
end
</code></pre>

<pre><code class="ruby"># app/models/concerns/sample2.rb
module Sample2
  extend ActiveSupport::Concern

  included do
    self.send(:methods)  # base 改成 self
    # 可以在這裡放當 include 時要執行的東西
    # 可以存取所有 class level 的東西
    # ex1: 宣告 shared scope
    # ex2: 可寫 shared validation
  end

#可以直接定義 ClassMethods 不需再 send(:extend, ClassMethods) 或是用 class_eval 去定義
   module ClassMethods  
      def foo
        # do something
      end
   end

#可以直接定義 InstanceMethods 不需再 send(:include, InstanceMethods)或是用 instance_eval 去定義
   module InstanceMethods  #也可以不用特別定義 module InstanceMethods
      def bar
         # do something
      end
   end
end
</code></pre>

<pre><code class="ruby">#app/models/test.rb
class Test &lt; ActiveRecord::Base
  include Sample
end
</code></pre>

<h1>concern vs service object</h1>

<ul>
<li>concern</li>
<li>簡單說就是，有許多 model 有共用的邏輯片段，可以拆出來</li>
<li>service object</li>
<li><p>與 concern 不同</p></li>
<li><p>兩個搭配使用</p></li>
<li>將許多 service object 搬到 concern</li>
</ul>


<p>官方文件：<br/>
<a href="http://api.rubyonrails.org/classes/ActiveSupport/Concern.html">ActiveSupport</a></p>

<p>參考文件：<br/>
<a href="https://ruby-china.org/topics/18401">什麼時候使用Concerns，什麼時候使用Services？</a><br/>
<a href="https://ihower.tw/blog/archives/3949">深入Rails3: ActiveSupport::Concern</a><br/>
<a href="http://stackoverflow.com/questions/14541823/how-to-use-concerns-in-rails-4">How to use concerns in Rails 4</a><br/>
<a href="https://ruby-china.org/topics/19812">ActiveSupport::Concern 小結</a><br/>
<a href="http://adz.cool/posts/210893-rails-use-case-mixin-and-concerns">rails use case - mixin &amp; concerns</a><br/>
<a href="https://www.viget.com/articles/slimming-down-your-models-and-controllers">Slimming Down Your Models and Controllers with Concerns, Service Objects, and Tableless Models</a><br/>
<a href="https://ihower.tw/rails4/activesupport.html">ActiveSupport - 工具函式庫</a></p>
]]></content>
  </entry>
  
</feed>
