<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Ruby | Leon's Blogging]]></title>
  <link href="https://mgleon08.github.io/blog/categories/ruby/atom.xml" rel="self"/>
  <link href="https://mgleon08.github.io/"/>
  <updated>2020-04-23T22:29:33+08:00</updated>
  <id>https://mgleon08.github.io/</id>
  <author>
    <name><![CDATA[LeonJi]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Ruby - Unary Operator]]></title>
    <link href="https://mgleon08.github.io/blog/2019/03/15/ruby-unary-operator/"/>
    <updated>2019-03-15T23:11:38+08:00</updated>
    <id>https://mgleon08.github.io/blog/2019/03/15/ruby-unary-operator</id>
    <content type="html"><![CDATA[<!-- more -->


<blockquote><p>In Ruby, a unary operator is an operator which only takes a single &lsquo;argument&rsquo; in the form of a receiver.</p></blockquote>

<p><code>unary operator</code> likes <code>+</code> <code>-</code> <code>!</code> <code>~</code> <code>&amp;</code> <code>*</code>..</p>

<pre><code class="ruby">-8
# =&gt; -8

# 2.2.3 Ruby
-'test'
# NoMethodError: private method `-@' called for "test":String

# 2.4.1 之後似乎就不會有 error
-'test'
# =&gt; "test"
</code></pre>

<p>Add <code>-@</code> method to String class</p>

<pre><code class="ruby">class String
  def -@
     self + " hello"
    end
end
# =&gt; :-@

-'test'
# =&gt; "test hello"
</code></pre>

<h3>Full Example</h3>

<pre><code class="ruby">class MagicString &lt; String
  def +@
    upcase
  end

  def -@
    downcase
  end

  def ~
    # Do a ROT13 transformation - http://en.wikipedia.org/wiki/ROT13
    tr 'A-Za-z', 'N-ZA-Mn-za-m'
  end

  def to_proc
    Proc.new { self + " hello" }
  end

  def to_a
    [self.reverse]
  end

 def !
   swapcase
 end
end

str = MagicString.new("This is my string!")
p +str                   # =&gt; "THIS IS MY STRING!"
p ~str                   # =&gt; "Guvf vf zl fgevat!"
p +~str                  # =&gt; "GUVF VF ZL FGEVAT!"
p %w(a b).map(&amp;str)      # =&gt; ["This is my string! hello", "This is my string! hello"]
p *str                   # =&gt; "!gnirts ym si sihT"

p !str                   # =&gt; "tHIS IS MY STRING!"
p (not str)              # =&gt; "tHIS IS MY STRING!"
p !(~str)                # =&gt; "gUVF VF ZL FGEVAT!"
</code></pre>

<p>Reference</p>

<ul>
<li><a href="http://www.rubyinside.com/rubys-unary-operators-and-how-to-redefine-their-functionality-5610.html">Ruby’s Unary Operators and How to Redefine Their Functionality</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ruby - (&.) the Safe Navigation Operator Like Rails Try!]]></title>
    <link href="https://mgleon08.github.io/blog/2019/02/15/ruby-the-safe-navigation-operator/"/>
    <updated>2019-02-15T20:46:20+08:00</updated>
    <id>https://mgleon08.github.io/blog/2019/02/15/ruby-the-safe-navigation-operator</id>
    <content type="html"><![CDATA[<!-- more -->


<p><code>ruby 2.3.0</code> 之後有提供一個方法 <code>&amp;.</code> 跟 rails 的 try! 一樣（是有 <code>!</code> 驚嘆號的）</p>

<p><code>try!</code> 跟 <code>try</code> 比起來比較嚴謹，會去 check receiver 是否為 <code>nil</code>，如果都用只用 <code>try</code>，反而會導致都回傳 <code>nil</code> 而發生錯誤時也不知道在哪</p>

<pre><code class="ruby">def try(*a, &amp;b)
  if a.empty? &amp;&amp; block_given?
    yield self
  else
    __send__(*a, &amp;b)
  end
end
</code></pre>

<pre><code class="ruby">def try!(*a, &amp;b)
  if a.empty? &amp;&amp; block_given?
    yield self
  else
    public_send(*a, &amp;b)
  end
end
</code></pre>

<h1>nil</h1>

<p>rails 5.2.3</p>

<pre><code class="ruby">class Account
  attr_reader :owner
  def initialize(owner)
    @owner = owner
  end
end

user = Account.new(nil)
user.owner.address
#NoMethodError (undefined method `address' for nil:NilClass)
user &amp;&amp; user.owner &amp;&amp; user.owner.address
# =&gt; nil
user.try(:owner).try(:address)
# =&gt; nil
user.try!(:owner).try!(:address)
# =&gt; nil
user&amp;.owner&amp;.address
# =&gt; nil
</code></pre>

<p>ruby 2.6.1</p>

<pre><code class="ruby">class Account
  attr_reader :owner
  def initialize(owner)
    @owner = owner
  end
end

user = Account.new(nil)
user.owner.address
# NoMethodError (undefined method `address' for nil:NilClass)
user &amp;&amp; user.owner &amp;&amp; user.owner.address
# =&gt; nil
user.try(:owner).try(:address)
# =&gt; undefined method `try' for #&lt;Account:0x00007fa43d0e25e8 @owner=nil&gt;
user.try!(:owner).try!(:address)
# =&gt; NoMethodError (undefined method `try!' for #&lt;Account:0x00007fa43d0e25e8 @owner=nil&gt;)
user&amp;.owner&amp;.address
# =&gt; nil
</code></pre>

<h1>false</h1>

<p>rails 5.2.3</p>

<pre><code class="ruby">class Account
  attr_reader :owner
  def initialize(owner)
    @owner = owner
  end
end

user = Account.new(false)
user.owner.address
# NoMethodError (undefined method `address' for false:FalseClass)
user &amp;&amp; user.owner &amp;&amp; user.owner.address
# =&gt; false
user.try(:owner).try(:address)
# =&gt; nil
user.try!(:owner).try!(:address)
# NoMethodError (undefined method `address' for false:FalseClass)
user&amp;.owner&amp;.address
# NoMethodError (undefined method `address' for false:FalseClass)
</code></pre>

<p>ruby 2.6.1</p>

<pre><code class="ruby">class Account
  attr_reader :owner
  def initialize(owner)
    @owner = owner
  end
end

user = Account.new(false)
user.owner.address
# NoMethodError (undefined method `address' for false:FalseClass)
user &amp;&amp; user.owner &amp;&amp; user.owner.address
# =&gt; false
user.try(:owner).try(:address)
# =&gt; NoMethodError (undefined method `try' for #&lt;Account:0x00007fd8c78c9b08 @owner=false&gt;)
user.try!(:owner).try!(:address)
# NoMethodError (undefined method `address' for false:FalseClass)
user&amp;.owner&amp;.address
# NoMethodError (undefined method `address' for false:FalseClass)
</code></pre>

<h1>Object.new</h1>

<p>rails 5.2.3</p>

<pre><code class="ruby">class Account
  attr_reader :owner
  def initialize(owner)
    @owner = owner
  end
end

user = Account.new(Object.new)
user.owner.address
# NoMethodError (undefined method `address' for #&lt;Object:0x00007fcb887785e8&gt;)
user &amp;&amp; user.owner &amp;&amp; user.owner.address
# NoMethodError (undefined method `address' for #&lt;Object:0x00007fcb887785e8&gt;)
user.try(:owner).try(:address)
# =&gt; nil
user.try!(:owner).try!(:address)
# NoMethodError (undefined method `try!' for #&lt;Account:0x00007fd8c7893800 @owner=#&lt;Object:0x00007fd8c7893828&gt;&gt;)
user&amp;.owner&amp;.address
# NoMethodError (undefined method `address' for #&lt;Object:0x00007fd8c7893828&gt;)
</code></pre>

<p>ruby 2.6.1</p>

<pre><code class="ruby">class Account
  attr_reader :owner
  def initialize(owner)
    @owner = owner
  end
end

user = Account.new(Object.new)
user.owner.address
# NoMethodError (undefined method `address' for #&lt;Object:0x00007fcb887785e8&gt;)
user &amp;&amp; user.owner &amp;&amp; user.owner.address
# NoMethodError (undefined method `address' for #&lt;Object:0x00007fcb887785e8&gt;)
user.try(:owner).try(:address)
# =&gt; NoMethodError (undefined method `try' for #&lt;Account:0x00007fd8c7893800 @owner=#&lt;Object:0x00007fd8c7893828&gt;&gt;)
user.try!(:owner).try!(:address)
# NoMethodError (undefined method `try!' for #&lt;Account:0x00007fd8c7893800 @owner=#&lt;Object:0x00007fd8c7893828&gt;&gt;)
user&amp;.owner&amp;.address
# NoMethodError (undefined method `address' for #&lt;Object:0x00007fd8c7893828&gt;)
</code></pre>

<p>參考文件:</p>

<ul>
<li><a href="http://mitrev.net/ruby/2015/11/13/the-operator-in-ruby/">The Safe Navigation Operator (&amp;.) in Ruby</a></li>
<li><a href="https://apidock.com/rails/v5.2.3/Object/try">try</a></li>
<li><a href="https://apidock.com/rails/v5.2.3/Object/try%21">try!</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ruby - New Features in Ruby 2.6]]></title>
    <link href="https://mgleon08.github.io/blog/2019/02/12/new-features-in-ruby-2-6/"/>
    <updated>2019-02-12T21:13:17+08:00</updated>
    <id>https://mgleon08.github.io/blog/2019/02/12/new-features-in-ruby-2-6</id>
    <content type="html"><![CDATA[<p>ruby 2.6 多了一些有趣的新特性和功能，來了解一下</p>

<!-- more -->


<h1>Endless ranges</h1>

<p>利用 <code>..</code> 代表無窮的範圍</p>

<blockquote><p>早期的寫法 <code>100..Float::INFINITY</code></p></blockquote>

<pre><code class="ruby">n = 123

case n
when 1..9 then 'Single digit'
when 10..99 then 'Two digit'
when 100.. then 'Three or more'
end

# =&gt; "Three or more"
</code></pre>

<p>但也要小心，會一直跑下去</p>

<pre><code class="ruby">(1..).each {|index| puts index }  
</code></pre>

<h1>Kernel#then (Kernel#yield_self alias)</h1>

<p>新增一個 <code>yield_self</code> 新的 alias <code>then</code></p>

<p>主要跟 <code>tap</code> 相反，<code>tap</code> 最後是返回原本的 <code>object</code>，<code>then</code> 則是返回 <code>block</code></p>

<p>大概是下面這樣的差別</p>

<pre><code class="ruby">class Object
  def tap
    yield self
    self
  end

  def then
    yield(self)
  end
end
</code></pre>

<p>範例</p>

<pre><code class="ruby">3.next.then {|x| x**x }.to_s             
#=&gt; "256"
"my string".yield_self {|s| s.upcase }   
#=&gt; "MY STRING"
</code></pre>

<pre><code class="ruby">cisbn = '978-1-93778-549-9'

cisbn.gsub('-', '')
  .then { |isbn| URI("#{API_URL}?q=isbn:#{isbn}") }
  .then { |uri| Net:HTTP.get(uri) }
  .then { |json_response| JSON.parse(json_response) }
  .then { |response| response.dig('items', 'volumeInfo') }
</code></pre>

<ul>
<li><a href="https://ruby-doc.org/core-2.6.1/Object.html#method-i-yield_self">yield_self</a></li>
</ul>


<h1>Enumerable#chain and Enumerator#+</h1>

<pre><code class="ruby">(1..3).chain((5..7), [9, 10]).to_a 
# =&gt; [1, 2, 3, 5, 6, 7, 9, 10]
(1..3).each + (5..7) + (9..10).to_a
# =&gt; [1, 2, 3, 5, 6, 7, 9, 10]
</code></pre>

<h1>Composition operators &lt;&lt; and >> to Proc and Method</h1>

<pre><code class="ruby">f = proc{|x| x + 2}
g = proc{|x| x * 3}
(f &lt;&lt; g).call(3) # -&gt; 11; identical to f(g(3))
(f &gt;&gt; g).call(3) # -&gt; 15; identical to g(f(3))
</code></pre>

<h1>Array#union and Array#difference</h1>

<pre><code class="ruby">a = [1, 2, 3]
b = [2, 3, 4]

a.union(b) # =&gt; [1, 2, 3, 4]
a.difference(b) # =&gt; [1]
a | b # =&gt; [1, 2, 3, 4]
a &amp; b # =&gt; [2, 3]
a - b # =&gt; [1]
a &amp;&amp; b # =&gt; [2, 3, 4]
a || b # =&gt; [1, 2, 3]
</code></pre>

<ul>
<li><a href="https://ruby-doc.org/core-2.6/Array.html#method-i-union">union</a></li>
<li><a href="https://ruby-doc.org/core-2.6/Array.html#method-i-difference">difference</a></li>
</ul>


<h1>Array#filter (Array#select alias)</h1>

<p>主要是其他語言 <code>Javascript, PHP, Haskell, Java 8, Scala, R</code> 等等都是用 <code>fliter</code></p>

<pre><code class="ruby">[:foo, :bar].filter { |x| x == :foo }
</code></pre>

<h1>Enumerable#to_h with block</h1>

<p><code>to_h</code> 支援 block，就可以直接作轉換 <code>key</code>, <code>value</code></p>

<pre><code class="ruby">hash = { foo: 2, bar: 3 }
hash.to_h { |k, v| [k.upcase, v*v] } #=&gt; { FOO: 4, BAR: 9 }

# ruby 2.5:
# hash.map { |k, v| [k.upcase, v*v] }.to_h
# hash.reduce({}) { |result, (k, v)| result.merge(k.upcase =&gt; v*v) }
</code></pre>

<h1>Enumerator::ArithmeticSequence</h1>

<p>之前無法用 <code>first</code> 和 <code>last</code></p>

<ul>
<li><code>Range#step</code></li>
<li><code>Numeric#step</code></li>
</ul>


<pre><code class="ruby">(1..10).step(2).last
# 9

(1..10).step(2).last
# ruby 2.5:
# NoMethodError: undefined method `last' for #&lt;Enumerator: 1..10:step(2)&gt;
</code></pre>

<p><code>%</code> is <code>step</code> alias</p>

<pre><code class="ruby">((1..10) % 2).to_a
#  =&gt; [1, 3, 5, 7, 9]
</code></pre>

<p>另一個改變</p>

<pre><code class="ruby">(1..10).step(2) == (1..10).step(2)
# false - Ruby 2.5 (and older)
(1..10).step(2) == (1..10).step(2)
# true - Ruby 2.6
</code></pre>

<h1>Merge multiple hashes</h1>

<pre><code class="ruby">a = { a: 1 }
b = { b: 2 }
c = { c: 3 }
a.merge(b, c)
# {:a=&gt;1, :b=&gt;2, :c=&gt;3}


a.merge(b).merge(c)
# ruby 2.5:
# {:a=&gt;1, :b=&gt;2, :c=&gt;3}
</code></pre>

<h1>Random.bytes</h1>

<pre><code class="ruby">Random.bytes(8)
# =&gt; "\xA4\xFB\xC4\x94\xC5U\xA0\x1A"

# ruby 2.5
Random.new.bytes(10)
# =&gt; "\xCEn@\xFA\x93\xB3\xB9\x80p\xA9"
</code></pre>

<h1>Range#=== now uses uses #cover? instead of #include?</h1>

<p><code>===</code>: <code>case equality</code>，原本是用 <code>include?</code> 的方式，改為用 <code>cover?</code></p>

<ul>
<li>include? 會將所有值一一拿出來做比對，因此效率較差</li>
<li>cover?   只會取出開頭和結尾，去比對，值 => 開頭 &amp;&amp; 值 &lt;= 結尾，效能比較好</li>
</ul>


<blockquote><p>cover?</p>

<p>Returns true if obj is between the begin and end of the range.</p>

<p>This tests begin &lt;= obj &lt;= end when exclude_end? is false and begin &lt;= obj &lt; end when exclude_end? is true.</p></blockquote>

<pre><code class="ruby">("a".."z").cover?("c")  #=&gt; true
("a".."z").cover?("5")  #=&gt; false
("a".."z").cover?("cc") #=&gt; true
(1..5).cover?(2..3)     #=&gt; true
(1..5).cover?(0..6)     #=&gt; false
(1..5).cover?(1...6)    #=&gt; true

("a".."z").include?("g")   #=&gt; true
("a".."z").include?("A")   #=&gt; false
("a".."z").include?("cc")  #=&gt; false
</code></pre>

<pre><code class="ruby">require 'date'

case DateTime.now
when Date.today..Date.today+1
  puts 'matched'
else
  puts 'not matched'
end
</code></pre>

<ul>
<li><a href="https://ruby-doc.org/core-2.6.1/Range.html#method-i-cover-3F">cover?</a></li>
<li><a href="https://ruby-doc.org/core-2.6.1/Range.html#method-i-include-3F">include?</a></li>
</ul>


<p>參考文件</p>

<ul>
<li><a href="https://github.com/ruby/ruby/blob/trunk/doc/NEWS-2.6.0">NEWS-2.6.0</a></li>
<li><a href="https://nithinbekal.com/posts/ruby-2-6/">What&rsquo;s new in Ruby 2.6</a></li>
<li><a href="https://medium.com/tailor-tech/whats-new-in-ruby-2-6-a4774f3631c1">What’s new in Ruby 2.6?</a></li>
<li><a href="https://www.rubyguides.com/2018/11/ruby-2-6-new-features/">9 New Features in Ruby 2.6</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ruby - Super vs Super()]]></title>
    <link href="https://mgleon08.github.io/blog/2019/02/04/ruby-super/"/>
    <updated>2019-02-04T18:19:10+08:00</updated>
    <id>https://mgleon08.github.io/blog/2019/02/04/ruby-super</id>
    <content type="html"><![CDATA[<!-- more -->


<p><code>super</code> 可以在同一個 method，呼叫上層的同個 method，但有沒有 <code>()</code> 行為上會有點不一樣</p>

<h1>super</h1>

<p>return <code>ArgumentError</code> 代表 <code>super</code> 會將 <code>Dog say</code> 的參數，帶到 <code>Animal say</code>，因此造成 <code>ArgumentError</code></p>

<p>如果剛好 <code>Animal say</code> 也有帶參數，那就不會 error</p>

<pre><code class="ruby">class Animal
  def say
    puts 'hi'
  end
end

class Dog &lt; Animal
  def say(text)
    super

    puts text
  end
end

Dog.new.say('Woo')
# =&gt; ArgumentError (wrong number of arguments (given 1, expected 0))
</code></pre>

<h1>super()</h1>

<p>而 <code>super()</code> 代表不帶任何參數的呼叫 <code>Animal say</code></p>

<pre><code class="ruby">class Animal
  def say
    'hi'
  end
end

class Dog &lt; Animal
  def say(text)
    super()

    text
  end
end

Dog.new.say('Woo')
</code></pre>

<p>參考文件</p>

<ul>
<li><a href="https://stackoverflow.com/questions/4632224/super-keyword-in-ruby">Super keyword in Ruby</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ruby - A::B vs Module a; Class B]]></title>
    <link href="https://mgleon08.github.io/blog/2019/02/04/ruby-scope/"/>
    <updated>2019-02-04T18:18:05+08:00</updated>
    <id>https://mgleon08.github.io/blog/2019/02/04/ruby-scope</id>
    <content type="html"><![CDATA[<!-- more -->


<p>在 ruby 中，<code>A::B</code> 相當於 <code>module A; class B</code> 但實際上會稍微有點不同的地方</p>

<h1>module A; class B</h1>

<p>在 <code>module A</code> 和 <code>class B</code> 中間宣告的變數，會變成屬於 <code>A module</code> 的 scope，而 <code>class B</code> 也包在 <code>module A</code> 底下，因此可以訪問到 parent 的變數</p>

<h1>A::B</h1>

<p>而在 <code>A::B</code> 裡面宣告是屬於 <code>A::B</code> 的 scope (也就是 <code>class B</code>)</p>

<h1>Example</h1>

<h3>module A; class B</h3>

<ol>
<li><code>class B</code> 會 search 有沒有 <code>SCOPE</code>?</li>
<li>沒有就往上層找 <code>module A</code> 有沒有 <code>SCOPE</code>?</li>
</ol>


<h3>A::B</h3>

<ol>
<li><code>class A::B</code> search 有沒有 <code>SCOPE</code>?</li>
<li>沒有往上層，就到了 global，並沒有 <code>module A</code> 這層</li>
</ol>


<pre><code class="ruby">SCOPE = 'global'

module A
  SCOPE = 'module A'
  class B
    def scope1
      SCOPE
    end
  end
end

class A::B
  def scope2
    SCOPE
  end
end

A::B.new.scope1 # =&gt; "module A"
A::B.new.scope2 # =&gt; "global"
</code></pre>

<h3>module A; class B</h3>

<ol>
<li><code>class B</code> 會 search 有沒有 <code>SCOPE</code>? 在 <code>class A::B</code> 已經有設定 scope 因此取得</li>
</ol>


<h3>A::B</h3>

<ol>
<li><code>class A::B</code> search 有沒有 <code>SCOPE</code>?</li>
</ol>


<pre><code class="ruby">SCOPE = 'global'

module A
  class B
    def scope1
      SCOPE
    end
  end
end

class A::B
  SCOPE = 'A::B'
  def scope2
    SCOPE
  end
end

A::B.new.scope1 # =&gt; "A::B"
A::B.new.scope2 # =&gt; "A::B"
</code></pre>

<p>參考文件</p>

<ul>
<li><a href="https://kaochenlong.com/2015/04/19/namespace/">Ruby 語法放大鏡之「有時候會看到有兩個冒號寫法是什麼意思?」</a></li>
<li><a href="https://stackoverflow.com/questions/15119724/ruby-lexical-scope-vs-inheritance">Ruby - Lexical scope vs Inheritance</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
