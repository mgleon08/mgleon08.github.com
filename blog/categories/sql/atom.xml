<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Sql | Leon's Blogging]]></title>
  <link href="http://mgleon08.github.com/blog/categories/sql/atom.xml" rel="self"/>
  <link href="http://mgleon08.github.com/"/>
  <updated>2018-08-15T20:48:11+08:00</updated>
  <id>http://mgleon08.github.com/</id>
  <author>
    <name><![CDATA[LeonJi]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Sql 好用的 Command]]></title>
    <link href="http://mgleon08.github.com/blog/2018/06/14/sql-command/"/>
    <updated>2018-06-14T18:43:04+08:00</updated>
    <id>http://mgleon08.github.com/blog/2018/06/14/sql-command</id>
    <content type="html"><![CDATA[<p>最近常常使用 sql，因應各種需求，也發現一些蠻好用的指令~</p>

<!-- more -->


<h1>FIELD()</h1>

<p>FIELD 會 return 第一個參數的，position</p>

<pre><code class="sql">// 第一個參數 "c", 在後面第三個位置
SELECT FIELD("c", "a", "b", "c", "d", "e");
// 3

// 如果找不到就會是 0
SELECT FIELD("f", "a", "b", "c", "d", "e");
// 0
</code></pre>

<p>可以搭配 order，讓取出來的順序按照原本給的參數</p>

<pre><code class="ruby">user_ids = [3, 5, 1, 2, 4]

users = User.where(id: user_ids).order("FIELD(id, #{user_ids.join(',')})")
</code></pre>

<pre><code class="sql">SELECT `users`.* FROM `users` WHERE `users`.`id` IN (3, 5, 1, 2, 4)  ORDER BY FIELD(id, 3,5,1,2,4)"
</code></pre>

<ul>
<li><a href="https://www.w3schools.com/sql/func_mysql_field.asp">MySQL FIELD() Function</a></li>
</ul>


<h1>GROUP_CONCAT</h1>

<p>可以透過 group 將所有的 book 做分類，並且依照分類將 <code>book name</code> group 起來</p>

<pre><code class="ruby"># 取出 user 底下所有的 books，並且照 books_type, books_name(會是 string 串聯起來)

User.select("books.type AS book_type, GROUP_CONCAT(DISTINCT books.name SEPARATOR ', ') as book_name")
    .joins("LEFT JOIN books ON users.id = books.user_id")
    .where(id: 8)
    .group("books.type")
</code></pre>

<pre><code class="sql">SELECT user.id, books.type, GROUP_CONCAT(DISTINCT books.name SEPARATOR ', ') as book_name
FROM users
LEFT JOIN books ON users.id = books.user_id
WHERE user.id = 8
GROUP BY books.type
</code></pre>

<p>也可以排序</p>

<pre><code class="sql">SELECT GROUP_CONCAT(DISTINCT books.id ORDER BY books.id ASC SEPARATOR ', ') as book_name
</code></pre>

<h1>CONCAT</h1>

<p>可以將多的 column 串在一起</p>

<pre><code class="sql">CONCAT(字串1, 字串2, 字串3, ...)
</code></pre>

<h1>IFNULL</h1>

<pre><code class="sql">// 如果x不是NULL(不包含0)，IFNULL()返回x，否則它返回y。
IFNULL(x, y)
</code></pre>

<h1>CONVERT</h1>

<pre><code class="sql">// 將時間轉成 date
CONVERT(created_at, date)
</code></pre>

<h1>CASE</h1>

<p>像 <code>if else</code> 一樣，可以根據條件，給不同的值</p>

<pre><code class="sql">SELECT CASE ("欄位名")
  WHEN "條件1" THEN "結果1"
  WHEN "條件2" THEN "結果2"
  ...
  [ELSE "結果N"]
  END
FROM "表格名";
</code></pre>

<h1>LOWER() &amp;  UPPER()</h1>

<p>將字串轉小寫或大寫</p>

<pre><code class="sql">LOWER("HI");
UPPER("hi");
</code></pre>

<h1>AUTO_INCREMENT</h1>

<pre><code class="sql">ALTER TABLE `pre_campaign_details_channels` CHANGE `id` `id` INT(11)  NOT NULL  AUTO_INCREMENT , ADD UNIQUE (`id`);
</code></pre>

<h1>unix_timestamp</h1>

<p>date 轉成 Unix Timestamp</p>

<p><code>2018/01/01</code> -> <code>1514736000(s)</code> -> <code>1514736000000(ms)</code></p>

<pre><code class="sql">SELECT unix_timestamp(my_datetime_column) as stamp
# milliseconds
SELECT unix_timestamp(my_datetime_column) * 1000 as stamp
</code></pre>

<p><a href="https://stackoverflow.com/questions/3075577/convert-mysql-datetime-stamp-into-javascripts-date-format">Convert MySql DateTime stamp into JavaScript&rsquo;s Date format</a></p>

<h1>BETWEEN</h1>

<p>可以直接指定在某個區段的時間</p>

<pre><code class="sql">SELECT * 
FROM Store_Information 
WHERE Txn_Date BETWEEN 'Jan-06-1999' AND 'Jan-10-1999';
</code></pre>

<p><a href="https://www.1keydata.com/tw/sql/sqlbetween.html">SQL Between</a>s</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用 Explain 優化 SQL 語句]]></title>
    <link href="http://mgleon08.github.com/blog/2017/09/01/mysql-sql-optimization-with-explain/"/>
    <updated>2017-09-01T14:33:17+08:00</updated>
    <id>http://mgleon08.github.com/blog/2017/09/01/mysql-sql-optimization-with-explain</id>
    <content type="html"><![CDATA[<p>有時候發現 query 速度很慢，但又不知道要怎麼提升的時候，就可以用 explain 的方式，來看看 sql 語法，哪裡可以做優化!</p>

<!-- more -->


<p>當 query 速度很慢時，很多時候可能是少加了 index，但有時又不是能夠這麼快的馬上看出來，這時候就可以將 sql 語法前面加上 <code>explain</code> 來解析</p>

<pre><code class="sql">explain SELECT * FROM user
</code></pre>

<table>
<thead>
<tr>
<th> id </th>
<th> select_type </th>
<th> table </th>
<th> partitions </th>
<th> type  </th>
<th> possible_keys </th>
<th> key     </th>
<th> key_len </th>
<th> ref  </th>
<th> rows </th>
<th> filtered </th>
<th> Extra       </th>
</tr>
</thead>
<tbody>
<tr>
<td> 1  </td>
<td> SIMPLE      </td>
<td> users </td>
<td> NULL       </td>
<td> range </td>
<td> PRIMARY       </td>
<td> PRIMARY </td>
<td> 4       </td>
<td> NULL </td>
<td> 2148 </td>
<td> 100      </td>
<td> Using where </td>
</tr>
</tbody>
</table>


<ol>
<li>id: 沒有意義</li>
<li>select_type: 查詢類型，是單表查詢、聯合查詢還是子查詢等</li>
<li>table: 查詢的表名</li>
<li>type: 連接使用的類型(重要項) 顯示連接使用的類型,按最 優到最差的類型排序

<ul>
<li>System</li>
<li>const</li>
<li>eq_ref</li>
<li>ref</li>
<li>fulltext</li>
<li>ref_or_null</li>
<li>index_merge</li>
<li>unique_subquery</li>
<li>index_subquery</li>
<li>range</li>
<li>index</li>
<li>ALL</li>
</ul>
</li>
<li>prossible_keys: 能在該表中使用哪些索引有助於查詢</li>
<li>key:實際使用的索引</li>
<li>key_len：索引的長度，在不損失精確性的情況 下,長度越短越好</li>
<li>ref：索引的哪一列被使用了</li>
<li>rows:返回的結果的行數</li>
<li>Extra:其他說明</li>
</ol>


<p>每個欄位詳細的一些 type 可以到參考文件裡的文章去找尋!</p>

<h1>composite index</h1>

<p>另外有時候我們會做 composite index，但其實這種 index 是有順序的!</p>

<p>例如:</p>

<pre><code class="ruby">add_index :lookup, [:name, :email, :phone], name: "lookup_index", unique: true
</code></pre>

<p>當在 <code>where</code> 的時候，就必須有順序 <code>name</code> <code>email</code> <code>phone</code> 這個 <code>index</code> 才會有效</p>

<p>ex:</p>

<ul>
<li><code>name</code></li>
<li><code>name</code> <code>email</code></li>
<li><code>name</code> <code>email</code> <code>phone</code></li>
<li><code>name</code> <code>phone</code></li>
</ul>


<p><code>where</code> 的時候不管順序，只要有對應到就可以</p>

<p>像是 <code>email</code> or <code>phone</code> or <code>email</code> + <code>phone</code> 就不會用到這個 index</p>

<p>參考文件:</p>

<ul>
<li><a href="http://www.shixinke.com/mysql/mysql-sql-optimization-with-using-explain-and-show-profile">使用explain和show profile來分析SQL語句實現優化SQL語句</a></li>
<li><a href="http://blog.kejyun.com/2012/12/Using-EXPLAIN-SQL-To-Analysis-Efficient-On-MySQL.html">在MySQL使用Explain做SQL SELECT語法效能測試</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
