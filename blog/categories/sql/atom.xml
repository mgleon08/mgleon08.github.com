<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Sql | Leon's Blogging]]></title>
  <link href="http://mgleon08.github.com/blog/categories/sql/atom.xml" rel="self"/>
  <link href="http://mgleon08.github.com/"/>
  <updated>2018-03-05T10:20:05+08:00</updated>
  <id>http://mgleon08.github.com/</id>
  <author>
    <name><![CDATA[LeonJi]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[使用 Explain 優化 SQL 語句]]></title>
    <link href="http://mgleon08.github.com/blog/2017/09/01/mysql-sql-optimization-with-explain/"/>
    <updated>2017-09-01T14:33:17+08:00</updated>
    <id>http://mgleon08.github.com/blog/2017/09/01/mysql-sql-optimization-with-explain</id>
    <content type="html"><![CDATA[<p>有時候發現 query 速度很慢，但又不知道要怎麼提升的時候，就可以用 explain 的方式，來看看 sql 語法，哪裡可以做優化!</p>

<!-- more -->


<p>當 query 速度很慢時，很多時候可能是少加了 index，但有時又不是能夠這麼快的馬上看出來，這時候就可以將 sql 語法前面加上 <code>explain</code> 來解析</p>

<pre><code class="sql">explain SELECT * FROM user
</code></pre>

<table>
<thead>
<tr>
<th> id </th>
<th> select_type </th>
<th> table </th>
<th> partitions </th>
<th> type  </th>
<th> possible_keys </th>
<th> key     </th>
<th> key_len </th>
<th> ref  </th>
<th> rows </th>
<th> filtered </th>
<th> Extra       </th>
</tr>
</thead>
<tbody>
<tr>
<td> 1  </td>
<td> SIMPLE      </td>
<td> users </td>
<td> NULL       </td>
<td> range </td>
<td> PRIMARY       </td>
<td> PRIMARY </td>
<td> 4       </td>
<td> NULL </td>
<td> 2148 </td>
<td> 100      </td>
<td> Using where </td>
</tr>
</tbody>
</table>


<ol>
<li>id: 沒有意義</li>
<li>select_type: 查詢類型，是單表查詢、聯合查詢還是子查詢等</li>
<li>table: 查詢的表名</li>
<li>type: 連接使用的類型(重要項) 顯示連接使用的類型,按最 優到最差的類型排序

<ul>
<li>System</li>
<li>const</li>
<li>eq_ref</li>
<li>ref</li>
<li>fulltext</li>
<li>ref_or_null</li>
<li>index_merge</li>
<li>unique_subquery</li>
<li>index_subquery</li>
<li>range</li>
<li>index</li>
<li>ALL</li>
</ul>
</li>
<li>prossible_keys: 能在該表中使用哪些索引有助於查詢</li>
<li>key:實際使用的索引</li>
<li>key_len：索引的長度，在不損失精確性的情況 下,長度越短越好</li>
<li>ref：索引的哪一列被使用了</li>
<li>rows:返回的結果的行數</li>
<li>Extra:其他說明</li>
</ol>


<p>每個欄位詳細的一些 type 可以到參考文件裡的文章去找尋!</p>

<h1>composite index</h1>

<p>另外有時候我們會做 composite index，但其實這種 index 是有順序的!</p>

<p>例如:</p>

<pre><code class="ruby">add_index :lookup, [:name, :email, :phone], name: "lookup_index", unique: true
</code></pre>

<p>當在 <code>where</code> 的時候，就必須有順序 <code>name</code> <code>email</code> <code>phone</code> 這個 <code>index</code> 才會有效</p>

<p>ex:</p>

<ul>
<li><code>name</code></li>
<li><code>name</code> <code>email</code></li>
<li><code>name</code> <code>email</code> <code>phone</code></li>
<li><code>name</code> <code>phone</code></li>
</ul>


<p><code>where</code> 的時候不管順序，只要有對應到就可以</p>

<p>像是 <code>email</code> or <code>phone</code> or <code>email</code> + <code>phone</code> 就不會用到這個 index</p>

<p>參考文件:</p>

<ul>
<li><a href="http://www.shixinke.com/mysql/mysql-sql-optimization-with-using-explain-and-show-profile">使用explain和show profile來分析SQL語句實現優化SQL語句</a></li>
<li><a href="http://blog.kejyun.com/2012/12/Using-EXPLAIN-SQL-To-Analysis-Efficient-On-MySQL.html">在MySQL使用Explain做SQL SELECT語法效能測試</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
