<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Other | Leon's Blogging]]></title>
  <link href="https://mgleon08.github.io/blog/categories/other/atom.xml" rel="self"/>
  <link href="https://mgleon08.github.io/"/>
  <updated>2022-05-06T08:52:34+08:00</updated>
  <id>https://mgleon08.github.io/</id>
  <author>
    <name><![CDATA[LeonJi]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Golang Implementation of gRPC]]></title>
    <link href="https://mgleon08.github.io/blog/2019/03/07/golang-grpc/"/>
    <updated>2019-03-07T21:57:06+08:00</updated>
    <id>https://mgleon08.github.io/blog/2019/03/07/golang-grpc</id>
    <content type="html"><![CDATA[<!-- more -->


<p>最近剛好看到 gRPC 蠻好奇是什麼的，就來了解一下，並試著用 golang 去實現</p>

<h1>What are protocol buffers?</h1>

<blockquote><p>Protocol buffers are Google&rsquo;s language-neutral, platform-neutral, extensible mechanism for serializing structured data</p></blockquote>

<ul>
<li>簡單的來說，就是類似像 <code>JSON</code>，<code>XML</code> 的序列化結構資料格式，但是更小、更快，而且更簡潔</li>
<li>目前支援多種語言 <code>Java</code>, <code>Python</code>, <code>Objective-C</code>, <code>C++</code>, <code>Go</code>, <code>Ruby</code>, and <code>C#</code></li>
<li>只需要定義一次資料結構，就能自動生成符合你程式語言的檔案，讓你能夠直接在你的程式上使用。</li>
<li>結構就是文件，不需額外撰寫 API 文件，<code>.proto</code> 檔本身就是一種「文件」。</li>
</ul>


<h1>What are gRPC?</h1>

<ul>
<li>Simple service definition - 透過 <code>Protocol Buffers</code> 定義 service，就是可以在 <code>.proto</code> 檔案就可以定義好 service 內容</li>
<li>Works across languages and platforms - 自動生成支援客戶端的語言，由下圖解說就是，Server跟 Client 端都透過 <code>protocol buffers</code> 來做傳遞，但三個分別是 <code>ruby</code>, <code>java</code>, <code>c++</code></li>
</ul>


<p><img src="https://grpc.io/img/landing-2.svg" alt="" /></p>

<ul>
<li>Start quickly and scale</li>
<li>Bi-directional streaming and integrated authBi-directional</li>
</ul>


<h1>Quick Start</h1>

<ul>
<li>各種語言都能夠設定，這裡主要先用 Golang <a href="https://grpc.io/docs/quickstart/go.html">quickstart</a></li>
</ul>


<blockquote><p>基本的開發步驟是定義 proto 文件， 定義請求 Request 和 響應 Response 的格式，然後定義一個服務 Service， Service可以包含多個方法。</p></blockquote>

<h3>gRPC requires Go <code>1.6</code> or <code>higher</code>.</h3>

<pre><code class="go">go version
</code></pre>

<h3>Install gRPC</h3>

<pre><code>go get -u google.golang.org/grpc
</code></pre>

<h3>Install Protocol Buffers v3</h3>

<p><a href="https://github.com/protocolbuffers/protobuf/releases">https://github.com/protocolbuffers/protobuf/releases</a></p>

<ul>
<li>根據自己用的 platform，下載編譯好的檔案，並解壓縮</li>
<li>將 <code>bin/protoc</code> binary file 放置在 PATH 底下( ex. <code>$GOPATH/bin</code>)</li>
</ul>


<h3>install the protoc plugin for Go</h3>

<pre><code class="go">go get -u github.com/golang/protobuf/protoc-gen-go
</code></pre>

<h1>Try it!</h1>

<blockquote><p>gRPC services are defined in a <code>.proto</code> file, which is used to generate a corresponding <code>.pb.g</code> file.</p>

<p>The <code>.pb.go</code> file is generated by compiling the <code>.proto</code> file using the protocol compiler: protoc.</p></blockquote>

<p>下載 <code>grpc</code> 時會有一個範例</p>

<pre><code class="go">cd $GOPATH/src/google.golang.org/grpc/examples/helloworld
</code></pre>

<p>體驗一下，先啟動 sever</p>

<pre><code class="go">go run greeter_server/main.go
</code></pre>

<p>再跑 client 會發現 response 回來的資料</p>

<pre><code class="go">go run greeter_client/main.go

// Greeting: Hello world
</code></pre>

<h1>Example</h1>

<p>建立資料夾</p>

<pre><code class="go">.
├── client   // gRPC 客戶端
├── pb       // 擺放 Protobuf 文件
└── server   // gRPC 伺服器
</code></pre>

<ul>
<li><code>client</code>：gRPC client，用來和伺服器溝通的程式</li>
<li><code>pb</code>: 定義的 Protobuf 文件，也會放置轉化後的 Protobuf 程式</li>
<li><code>server</code>: gRPC server</li>
</ul>


<h3>proto</h3>

<p>定義資料格式</p>

<pre><code class="go">// 撰寫格式是 Proto v3。
syntax = "proto3";
// 生成的程式在 Golang 中將會屬於 `pb` 套件。
package pb;

// Calculator 定義了一個計算用的服務。
service Calculator {
    // Plus 會接收 CalcRequest 資料作加總，最終會回傳 CalcReply。
    rpc Plus (CalcRequest) returns (CalcReply) {}
}

// CalcRequest 包含了兩個數字，將會傳送至計算服務並對兩個數字進行計算。
message CalcRequest {
// 後面的數字是 Protocol Buffers 編碼與解碼所會用到的編號，能夠移除其中一個欄位而不打亂整個資料結構的編碼與解碼(除非更改了數字編號)
    int32 number_a = 1;
    int32 number_b = 2;
}

// CalcReply 是計算結果，將會回傳給客戶端。
message CalcReply {
    int32 result = 1;
}
</code></pre>

<p>透過 <code>protoc</code> 產生 <code>.pb.go</code></p>

<pre><code class="go">protoc --go_out=plugins=grpc:. *.proto
</code></pre>

<ul>
<li>Generated client and server code.</li>
<li>Code for populating, serializing, and retrieving our <code>HelloRequest</code> and <code>HelloReply</code> message types.</li>
</ul>


<p>目前資料夾</p>

<pre><code class="go">.
├── client
│   └── main.go
├── pb
│   ├── calc.pb.go
│   └── calc.proto
└── server
    └── main.go
</code></pre>

<h3>server</h3>

<pre><code class="go">// server/main.go
package main

import (
    "context"
    "log"
    "net"

    "google.golang.org/grpc"

    "github.com/mgleon08/demo_proto/pb"
)

const (
    port = ":50051"
)

// server 建構體會實作 Calculator 的 gRPC 伺服器。
type server struct{}

// Plus 會將傳入的數字加總。
func (s *server) Plus(ctx context.Context, in *pb.CalcRequest) (*pb.CalcReply, error) {
    // 計算傳入的數字。
    result := in.NumberA + in.NumberB
    // 包裝成 Protobuf 建構體並回傳。
    return &amp;pb.CalcReply{Result: result}, nil
}

func main() {
    // 監聽指定埠口，這樣服務才能在該埠口執行。
    lis, err := net.Listen("tcp", port)
    if err != nil {
        log.Fatalf("無法監聽該 port: %v", err)
    }

    // 建立新 gRPC 伺服器並註冊 Calculator 服務。
    s := grpc.NewServer()
    // RegisterCalculatorServer 是透過 .proto 定義轉換而成
    pb.RegisterCalculatorServer(s, &amp;server{})

    // 開始在指定埠口中服務。
    if err := s.Serve(lis); err != nil {
        log.Fatalf("無法提供服務: %v", err)
    }
}
</code></pre>

<h3>client</h3>

<pre><code class="go">// client/main.go
package main

import (
    "context"
    "log"

    "google.golang.org/grpc"

    "github.com/mgleon08/demo_proto/pb"
)

const (
    address = "localhost:50051"
)

func main() {
    // 建立連線到遠端 gRPC 伺服器。
    conn, err := grpc.Dial(address, grpc.WithInsecure())
    if err != nil {
        log.Fatalf("無法連線: %v", err)
    }
    // 結束後要關閉
    defer conn.Close()

    // 建立新的 Calculator 客戶端，所以等一下就能夠使用 Calculator 的所有方法。
    c := pb.NewCalculatorClient(conn)

    // 傳送新請求到遠端 gRPC 伺服器 Calculator 中，並呼叫 Plus 函式，讓兩個數字相加。
    r, err := c.Plus(context.Background(), &amp;pb.CalcRequest{NumberA: 32, NumberB: 32})
    if err != nil {
        log.Fatalf("無法執行 plus: %v", err)
    }
    log.Printf("回傳結果: %d", r.Result)
}
</code></pre>

<h3>啟動</h3>

<pre><code class="go">// 先啟動 server
go run ./server/main.go  

// 再啟動 client，就會有 response
go run ./client/main.go  
</code></pre>

<h3>demo</h3>

<p><a href="https://github.com/mgleon08/go-grpc-demo">go-grpc-demo</a></p>

<p>Reference:</p>

<ul>
<li><a href="https://grpc.io/">gprc</a></li>
<li><a href="https://developers.google.com/protocol-buffers/">Protocol Buffers</a></li>
<li><a href="https://codinganimal.info/grpc-tutorial-for-python-2fa0fe2ff853">gRPC Tutorial for Python</a></li>
<li><a href="https://yami.io/grpc/">API 文件就是你的伺服器，REST 的另一個選擇：gRPC</a></li>
<li><a href="https://yami.io/protobuf/">比起 JSON 更方便、更快速、更簡短的 Protobuf 格式</a></li>
<li><a href="https://www.youtube.com/watch?v=NoDRq6Twkts">Getting Started with Protocol Buffers in Go - Tutorial</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Scrum 簡單介紹]]></title>
    <link href="https://mgleon08.github.io/blog/2019/03/07/scrum/"/>
    <updated>2019-03-07T21:51:10+08:00</updated>
    <id>https://mgleon08.github.io/blog/2019/03/07/scrum</id>
    <content type="html"><![CDATA[<p>最近想在團隊中試著導入 scrum，因此先來瞭解一下 scrum 的概念</p>

<!-- more -->


<h1>Waterfall vs Agile</h1>

<p><img src="https://projectresources.cdt.ca.gov/wp-content/uploads/sites/50/2017/08/traditional-waterfall-versus-agile.png" alt="" /></p>

<h1>Iron Triangle</h1>

<p><img src="https://wac-cdn.atlassian.com/dam/jcr:6bd4fa76-577f-40c4-a12d-784860d0dc42/waterfall-v-agile-iron-triangle-v03.png?cdnVersion=ks" alt="The iron triangle of planning " /></p>

<ul>
<li>Scope is the work to be done – such as features and functionalities – to deliver a working product.</li>
<li>Resources include budget and team members working to deliver and execute.</li>
<li>Time is when teams will deliver to the market such as releases and milestones.</li>
</ul>


<p><a href="https://www.atlassian.com/agile/agile-at-scale/agile-iron-triangle">The iron triangle of planning</a></p>

<h1>Scrum</h1>

<p><img src="https://res.infoq.com/news/2013/03/anime-scrum-primer/en/resources/anime_scrum_overview_small.png" alt="" /></p>

<h2><a href="https://agilemanifesto.org/iso/en/manifesto.html">Manifesto for Agile Software Development 敏捷宣言</a></h2>

<ul>
<li><code>個人與互動</code> 重於 <code>流程與工具</code></li>
<li><code>可用的軟體</code> 重於 <code>詳盡的文件</code></li>
<li><code>與客戶合作</code> 重於 <code>合約協商</code> </li>
<li><code>回應變化</code> 重於 <code>遵循計畫</code></li>
</ul>


<h2>Scrum Role</h2>

<ol>
<li>Product Owner(PO，產品負責人)

<ul>
<li>為產品的成敗負責</li>
<li>負責管理產品需求並決定需求的施工順序</li>
<li>負責回答問題與釐清需求</li>
</ul>
</li>
<li>Scrum Master(SM，無中文名稱)

<ul>
<li>監督流程</li>
<li>協助團隊持續改善開發流程</li>
<li>排除任何阻礙開發活動的事件</li>
</ul>
</li>
<li>Development Team(Dev Team，開發團隊)

<ul>
<li>負責開發軟體</li>
<li>決定細節，執行任務</li>
</ul>
</li>
<li>stakeholder (利益相關者)

<ul>
<li>和軟體開發專案有關，但是卻沒有實際參與專案開發活動的人</li>
</ul>
</li>
</ol>


<h2>Scrum Object</h2>

<ol>
<li>Item(物件) or Story(故事)：

<ul>
<li>由 PO 來定義產出，Story 的 Scope 必須是可以讓團隊在一般的速率下完成 3 - 5 個為佳，太多會太雜，太少會讓團隊感覺到這次的 Sprint 產出沒感覺，對團隊信心是個打擊</li>
</ul>
</li>
<li>Task(工作)：

<ul>
<li>由 Dev Team 列出 Story 所需完成的工作項目，並由 Dev Team 自行分配</li>
</ul>
</li>
<li>Product Backlog(產品待辦清單)：

<ul>
<li>由 PO 負責整理的產品願景圖，以 Story 為單位，開始順序由上而下</li>
<li>As a user, I can do something so that I can achieve xxx</li>
<li><a href="https://www.crisp.se/wp-content/uploads/2012/06/ProductBacklog.xls">ProductBacklog.xls</a></li>
</ul>
</li>
<li>Sprint Backlog(衝刺待辦清單)：

<ul>
<li>Dev Team 向 PO 承諾這個 Sprint 會盡力完成的 Story List，以 Task 為單位</li>
</ul>
</li>
<li>Potentially Shippable Product Increment(潛在可交付產品增量)：

<ul>
<li>Dev Team 的產出，就是這個 Spring 所完成的項目，並且客戶需要就可以立即上線的</li>
</ul>
</li>
<li>Burndown Chart(燃盡圖)：

<ul>
<li>剩餘的 Sprint Backlog，看看還剩多少才能清空，以 Task 大小為單位</li>
<li>把所有 stories 的 tasks 施工的小時數加總起來，每次 daily Scrum 報告已經完成哪些 tasks，並將總時數減掉完成時數，畫成一個表，團隊就可以知道進度是否正常</li>
<li><a href="http://www.uml.org.cn/SoftWareProcess/images/2011061511.png">Burndown Chart</a></li>
</ul>
</li>
</ol>


<h2>Scrum Ｍeeting</h2>

<blockquote><p>Scrum 活動每一個都是有它的目的和時間限制(Time Boxed)
Spring n 個禮拜，所有活動抓 n 小時</p></blockquote>

<ol>
<li>Sprint(衝刺)：

<ul>
<li>團隊決定哪些 Item 後，就開始去衝刺</li>
<li>長度定義上是 1 - 4 個禮拜，但實務上不要多過2個禮拜</li>
<li>長度應該要保持穩定，盡可能不變，這樣才容易讓團隊掌握節奏，也容易預估和比較 Sprint 內的工作量</li>
<li>大原則是 Sprint 內的 Sprint Backlog 不改變(有原則就有例外)</li>
</ul>
</li>
<li>Daily Scrum(每日站立會議)：

<ul>
<li>每天 10 - 15 分鐘不能超時</li>
<li>目的是讓團隊資訊同步</li>
<li>一定要站著為了讓大家長話短說</li>
<li>主要報告三件事

<ul>
<li>昨天做什麼以協助團隊達成sprint目標</li>
<li>今天準備做什麼以協助團隊達成sprint目標</li>
<li>有沒有遇到任何阻礙團隊達成sprint目標的事情</li>
</ul>
</li>
</ul>
</li>
<li>Sprint Planning Meeting(衝刺規劃會議)：

<ul>
<li>討論這次 sprint 所要開發的需求（stories）</li>
<li>將 story 細分為若干個 task，並估算每個 task 所需的時間（以小時計算</li>
<li>Story 優先順序 PO 決定</li>
<li>選多少 Item 由 Dev Team 決定</li>
<li>會議後會產生 Spring Backlog，上面完整寫出這次 Spring 所需要的所有資訊</li>
</ul>
</li>
<li>Product Backlog Refinement / PBR(產品待辦清單精煉會議)：

<ul>
<li>PO 跟 Dev Team 一起討論近期內會開始的 Story</li>
<li>從商業和使用者角度切入，儘可能不觸及技術細節</li>
</ul>
</li>
<li>Sprint Review(衝刺檢視會議)：

<ul>
<li>Sprint 結束時針對這次 Sprint 產出的會議</li>
<li>PO 邀請利害關係人對產出給予意見，必須是可用的功能才算產出</li>
<li>不需準備 Powerpoint 或其他簡報，單純就軟體操作取得回饋</li>
</ul>
</li>
<li>Sprint Retrospective / Sprint Retro (衝刺回顧會議，也有人稱『自省』會議)：

<ul>
<li>Scrum Team 成員(Dev Team 或包含 PO)</li>
<li>Sprint Review 後，針對這個 Sprint 團隊的工作模式討論改善，並定出下個 Sprint 改善事項</li>
<li>原則上只有團隊成員才能參加，避免主管級參與，而變成檢討會議</li>
</ul>
</li>
</ol>


<blockquote><p>後面為非正規 Scrum - <a href="http://teddy-chen-tw.blogspot.com/2012/01/scrum-3.html">Scrum 是什麼（3）：三種補充文件</a></p></blockquote>

<ol>
<li>Sprint Info Page (One Page, Kick off)

<ul>
<li>sprint planning meeting 開完之後，SM 會寫一份 sprint info page 文件，這份文件包含了 sprint goal(一句簡短的句子，用以表明該 sprint 所要完成的主要功能)，stories，sprint，startTime，endTime，以及團隊成員。</li>
<li>SM 將這份文件寄給 Scrum Team 與其他有興趣的輔助角色人員，讓他們知道一個新的 sprint 已經開始了。</li>
</ul>
</li>
<li>Sprint Demo Agenda

<ul>
<li>Sprint 結束前一天，SM 要寫出 sprint demo 的議程表，並將此文件寄給 Scrum Team 與其他有興趣的輔助角色人員。</li>
<li>議程表包含所有要 demo 的項目，以及每一個 demo 項目要花多少時間，由誰負責 demo。</li>
<li>當 Developer 收到該議程表時，就可以準備明天要 demo 的資料。</li>
</ul>
</li>
<li>Sprint Summary Report (會議記錄)

<ul>
<li>當開完 sprint retrospective meeting 之後，SM 會準備此文件</li>
<li>內容包含

<ul>
<li>sprint 所完成功能的簡述</li>
<li>完成多少個 story points</li>
<li>好的以及有待改善的項目（最多只各列三點）</li>
<li>改善行動計畫</li>
</ul>
</li>
<li>將此文件寄給Scrum Team 以及其他有興趣的輔助角色人員，讓他們知道這個 sprint 已經正式結束了。</li>
</ul>
</li>
</ol>


<h2>Technical</h2>

<ul>
<li>單元測試(Unit Test)</li>
<li>系統測試(System Test)</li>
<li>CI 持續整合(Continuous Integration)</li>
<li>CD 持續交付(Continuous Delivery)</li>
</ul>


<h2>Benefit</h2>

<ul>
<li>快速驗證使用者反應</li>
<li>學習目標導向解決問題</li>
<li>學習團隊協作</li>
<li>快速失敗，快速學習</li>
<li>快速且頻繁的同步資訊</li>
<li>自組織團隊(Self Organizing Team)</li>
<li>自省會議(Retrospective)</li>
<li>引導(Facilitation)</li>
</ul>


<p>參考文件</p>

<ul>
<li><a href="https://funevo.com/2015/06/27/scrum-agile-project-management-software-development/">Scrum 懶人包 – 10分鐘讀懂 Scrum Agile 敏捷軟體開發專案入門（含中文英文名詞對照）</a></li>
<li><a href="https://medium.com/doflowy/%E4%BB%80%E9%BA%BC%E6%98%AFscrum-%E4%B8%8D%E6%98%AF%E5%B7%A5%E7%A8%8B%E5%B8%AB%E4%B9%9F%E8%83%BD%E6%87%82%E7%9A%84scrum%E5%85%A5%E9%96%80%E6%95%99%E5%AD%B8-1cc6683575f8">什麼是Scrum？不是工程師也能懂的Scrum入門介紹！</a></li>
<li><a href="https://funevo.com/2015/06/01/scrum-agile-shu-dan-book-list-training/">Scrum與Agile敏捷開發書單和學習資源</a></li>
<li><a href="http://teddy-chen-tw.blogspot.com/2011/12/scrum-1.html">Scrum 是什麼</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[UML Class Diagram]]></title>
    <link href="https://mgleon08.github.io/blog/2018/11/08/uml-class-diagram/"/>
    <updated>2018-11-08T15:15:11+08:00</updated>
    <id>https://mgleon08.github.io/blog/2018/11/08/uml-class-diagram</id>
    <content type="html"><![CDATA[<p>類別圖，跟 ERD 有些類似，可能包含了 ERD 所描述的內容，但不一定可對應</p>

<!-- more -->


<p>Unified Modeling Language (UML)，透過此圖可以很清楚的畫出，每個 model 裡面有的 <code>attributes</code> &amp; <code>methods</code>，還有跟別的 model 的相互關係</p>

<h3>Symbol</h3>

<p>每個 <code>attributes</code> &amp; <code>methods</code> 前面可以標示符號，代表這個目前是哪一種狀態</p>

<ul>
<li>private : -</li>
<li>public : +</li>
<li>protected : #</li>
<li>package / default : ~</li>
</ul>


<p><img src="https://i.imgur.com/gkyiOkn.png" alt="" /></p>

<p>上圖算是比較簡易的版本，有些在 method 後面還會加入傳入的參數，跟回傳值</p>

<pre><code class="ruby">- setName(string): string
- eat(string): string
</code></pre>

<h3>Relationship</h3>

<p>透過 model 跟 model 間線的關聯，可以知道是繼承還是組合等等</p>

<ul>
<li>Inheritance 繼承 –––––▷</li>
<li>Association 關聯 ––––––</li>
<li>Aggregation 聚合 –––––◆</li>
<li>Composition 組合 –––––◇</li>
<li>Dependency 依賴  &mdash;&ndash;></li>
</ul>


<h3>Multiplicity</h3>

<p>線上面的數字則可以表示，model 與 model 的對應關係</p>

<ul>
<li><code>0..1</code> zero to one (optional)</li>
<li><code>n</code> specific number</li>
<li><code>0..*</code> zero to many</li>
<li><code>1..*</code> one to many</li>
<li><code>m..n</code> specific number range</li>
</ul>


<h3>Example</h3>

<p>實際上大概的圖示</p>

<p><img src="https://i.imgur.com/B6mapCR.png" alt="" /></p>

<ul>
<li><a href="https://www.youtube.com/watch?v=UI6lqHOVHic">UML Class Diagram Tutorial</a></li>
<li><a href="https://dotblogs.com.tw/lazycodestyle/2016/06/01/233545">[軟工] 類別圖「關聯」、「聚合」及「組合」比較</a></li>
<li><a href="https://github.com/macdidi5/UMLTutorial">UML超新手入門</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Entity Relationship Diagram (ERD)]]></title>
    <link href="https://mgleon08.github.io/blog/2018/11/07/entity-relationship-diagram/"/>
    <updated>2018-11-07T15:14:59+08:00</updated>
    <id>https://mgleon08.github.io/blog/2018/11/07/entity-relationship-diagram</id>
    <content type="html"><![CDATA[<p>在工作上時常用到 Entity Relationship Diagram (ERD) 來規劃 DB schema 的關聯，透過這個可以在規劃專案時很清楚知道整個架構，並且讓執行的人也可以很清楚要怎麼實作。</p>

<!-- more -->


<p>畫出來的圖大概會長這樣</p>

<p><img src="https://i.imgur.com/aGA5DHb.png" alt="" /></p>

<p>這邊的重點就是要瞭解中間關聯的線的左右邊代表了什麼意思 (如以下圖)</p>

<p><img src="https://d2slcw3kip6qmk.cloudfront.net/marketing/pages/chart/erd-symbols/ERD-Notation.PNG" alt="ERPD Cardinality" /></p>

<p>以第一張圖舉例來說就代表</p>

<ul>
<li>1 個 customer 可以有 0 個或多個 order</li>
<li>1 個 order 至少有 1 個或多個 product</li>
<li>1 個 product 可以有 0 個或多個 order</li>
<li>1 個 order 至少且只能有一個 customer</li>
</ul>


<p>更進階清楚的話，可以連所有 column 的 type 都寫進去</p>

<p><img src="https://i.imgur.com/KBUmyAK.png" alt="" /></p>

<ul>
<li><a href="https://www.youtube.com/watch?v=QpdhBUYk7Kk">Entity Relationship Diagram (ERD) Tutorial - Part 1</a></li>
<li><a href="https://www.youtube.com/watch?v=-CuY5ADwn24">Entity Relationship Diagram (ERD) Tutorial - Part 2</a></li>
<li><a href="https://www.smartdraw.com/entity-relationship-diagram/">Entity Relationship Diagram</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[簡單理解 CDN 原理]]></title>
    <link href="https://mgleon08.github.io/blog/2018/10/29/understand-cdn/"/>
    <updated>2018-10-29T15:06:53+08:00</updated>
    <id>https://mgleon08.github.io/blog/2018/10/29/understand-cdn</id>
    <content type="html"><![CDATA[<p>近期遇到 CDN 的問題，順便瞭解一下 CDN 整個運作模式</p>

<!-- more -->


<p>原先以為 CDN 會自動做快取直到我們去 purge CDN，但實際上 CDN 是會根據 <code>Response Headers</code> 的</p>

<pre><code>cache-control: max-age=60, public
</code></pre>

<pre><code class="ruby"># rails 中設定 max-age 的方式
expires_in 1.minutes, public: true # public
expires_in 5.minutes # private
</code></pre>

<p>去做對應的 cache (必須用 public)，另外做了 <code>max-age</code> 之後，不只 CDN 會有設定，使用者的瀏覽器也會有設定</p>

<pre><code>server -&gt; CDN -&gt; Browser
60         60       60
</code></pre>

<p>因此如果設定 <code>max-age</code> 60 秒</p>

<ul>
<li>CDN cache 60 秒，在這 60 秒就不會再打 server，直到 60秒過 or <code>purge CDN</code></li>
<li>Browser cache 60 秒，在這 60 秒就不會再打 CDN，直到 60秒過 or <code>clear browser cache</code></li>
</ul>


<blockquote><p>這邊有個重點，當測試的時候，必須開不同的 browser 去做測試，不然直接打 CDN 跟 HTML 打 API 的 url cache 會同步</p></blockquote>

<h1>cache-control</h1>

<blockquote><p>HTTP 1.1 才出現 Cache-Control</p></blockquote>

<p>接著再根據 cache-control 瞭解一下行為，當 browser 設定</p>

<h3>max-age</h3>

<pre><code class="ruby">cache-control: max-age=60, public
</code></pre>

<ul>
<li>第一次訪問，200</li>
<li>第二次訪問時，則會顯示 200(from cache)，後來 google 有更新，就有分 <code>from disk cache(磁盤緩存)</code> 和 <code>from memory cache(內存緩存)</code></li>
</ul>


<pre><code class="ruby">Status Code: 200  (from disk cache)
# 記得必須是用 code 去呼叫才會，不是直接打 api，之前測試直接打會變成 304，改用 script 成功了
</code></pre>

<ul>
<li>但什麼時候是哪種緩存，目前看起來是會根據 google 來判斷 <a href="https://www.zhihu.com/question/64201378">求教大神瀏覽器是根據什麼決定from disk cache 與 from memory cache？</a></li>
<li>如果有 expires(HTTP1.0) 也存在的話，max-age 會蓋過 expires</li>
</ul>


<blockquote><p>「public」和「private」
如果回應標記為「public」，即使具備關聯的 HTTP 認證，甚至回應狀態碼無法正常快取，回應也可以供使用者快取。在大多數情況下，「public」並不是必要項目，因為明確的快取資訊 (例如「max-age」) 已表示 回應可供快取。</p>

<p>另一方面，瀏覽器可以快取「private」回應，但是通常只開放給單一使用者快取，因此不允許任何中繼快取對其進行快取，例如使用者瀏覽器可以快取包含使用者私人資訊的 HTML 網頁，但是 CDN 不能快取。
<a href="https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/http-caching?hl=zh-tw">HTTP 快取</a></p></blockquote>

<h3>no-cache</h3>

<p>當設定以下 <code>no-cache</code>，代表每次都會發送 Request 去確認是否有新的檔案，沒有就會  return <code>304</code></p>

<pre><code class="ruby">cache-control: no-cache
# 相當於 cache-control: max-age=0
</code></pre>

<h3>no-store</h3>

<p>當設定以下 <code>no-store</code>，代表完全不使用快取</p>

<pre><code class="ruby">cache-control: no-store
</code></pre>

<h1>Purge CDN</h1>

<p>通常廠商會提供一隻 API，可以做 purge CDN 的動作，當資料有更新時就可以透過這支 API 把 CDN 清除，讓它重新跟 server 拉取，但有個重點是，<code>max-age</code> 就不能夠設定太長，太長會導致 brower 那邊一直 cache 舊的，即使我們 purge 掉 CDN，brower 也是會等到 <code>max-age</code> 時間到，才會重新去拉 CDN。</p>

<h1>params cache object</h1>

<p>一開始 url 本來是希望帶 params 的方式做 cache，在測試的時候發現，雖然可以做 cache，但在 purge 的時候卻無法清除，看 log 發現顯示 <code>none cache-existing</code>
代表根本沒有清掉 cache，詢問了 cdn 的廠商，原來要有帶 params 的 url，當作是 unique object 算是特殊需求，要另外開啟。</p>

<p>但這家開啟後，萬一之後要換別家，會不會別家沒有支援或是要另外開啟? 所以後來還是改用 <code>path_params</code> 的方式，以防換別家的時候又會有問題</p>

<h1>File Extension</h1>

<p>CDN cache 是根據整個 url，包括副檔名，因此 <code>http://localhost:3000/test.js</code> 和 <code>http://localhost:3000/test.json</code> 會是不同的 url，purge 時也必須指定對應的 url 才能夠 purge</p>

<h1>http/https</h1>

<p>purge 的 url 必須要打一開始設定的 url，<code>http/https</code> 會有差別，如果設定的是 <code>http</code> 就必須針對 <code>http</code> 去做 purge 而不是 <code>https</code></p>

<p>參考文件:</p>

<ul>
<li><a href="https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/http-caching?hl=zh-tw">HTTP 快取</a></li>
<li><a href="https://cythilya.github.io/2018/07/27/http-caching/?fbclid=IwAR1jJfxG2o25i06Pqueb8yE0copC4VSJpbXmr4lG76wPTcDQzGa7ncE6iTk">HTTP Caching</a></li>
<li><a href="https://blog.techbridge.cc/2017/06/17/cache-introduction/">循序漸進理解 HTTP Cache 機制</a></li>
<li><a href="https://excaliburhan.com/post/things-you-should-know-about-browser-cache.html">你應該知道的瀏覽器緩存知識</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
