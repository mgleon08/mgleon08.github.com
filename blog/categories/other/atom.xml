<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Other | Leon's Blogging]]></title>
  <link href="http://mgleon08.github.com/blog/categories/other/atom.xml" rel="self"/>
  <link href="http://mgleon08.github.com/"/>
  <updated>2019-02-18T22:50:14+08:00</updated>
  <id>http://mgleon08.github.com/</id>
  <author>
    <name><![CDATA[LeonJi]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[UML Class Diagram]]></title>
    <link href="http://mgleon08.github.com/blog/2018/11/08/uml-class-diagram/"/>
    <updated>2018-11-08T15:15:11+08:00</updated>
    <id>http://mgleon08.github.com/blog/2018/11/08/uml-class-diagram</id>
    <content type="html"><![CDATA[<p>類別圖，跟 ERD 有些類似，可能包含了 ERD 所描述的內容，但不一定可對應</p>

<!-- more -->


<p>Unified Modeling Language (UML)，透過此圖可以很清楚的畫出，每個 model 裡面有的 <code>attributes</code> &amp; <code>methods</code>，還有跟別的 model 的相互關係</p>

<h3>Symbol</h3>

<p>每個 <code>attributes</code> &amp; <code>methods</code> 前面可以標示符號，代表這個目前是哪一種狀態</p>

<ul>
<li>private : -</li>
<li>public : +</li>
<li>protected : #</li>
<li>package / default : ~</li>
</ul>


<p><img src="https://i.imgur.com/gkyiOkn.png" alt="" /></p>

<p>上圖算是比較簡易的版本，有些在 method 後面還會加入傳入的參數，跟回傳值</p>

<pre><code class="ruby">- setName(string): string
- eat(string): string
</code></pre>

<h3>Relationship</h3>

<p>透過 model 跟 model 間線的關聯，可以知道是繼承還是組合等等</p>

<ul>
<li>Inheritance 繼承 –––––▷</li>
<li>Association 關聯 ––––––</li>
<li>Aggregation 聚合 –––––◆</li>
<li>Composition 組合 –––––◇</li>
<li>Dependency 依賴  &mdash;&ndash;></li>
</ul>


<h3>Multiplicity</h3>

<p>線上面的數字則可以表示，model 與 model 的對應關係</p>

<ul>
<li><code>0..1</code> zero to one (optional)</li>
<li><code>n</code> specific number</li>
<li><code>0..*</code> zero to many</li>
<li><code>1..*</code> one to many</li>
<li><code>m..n</code> specific number range</li>
</ul>


<h3>Example</h3>

<p>實際上大概的圖示</p>

<p><img src="https://i.imgur.com/B6mapCR.png" alt="" /></p>

<ul>
<li><a href="https://www.youtube.com/watch?v=UI6lqHOVHic">UML Class Diagram Tutorial</a></li>
<li><a href="https://dotblogs.com.tw/lazycodestyle/2016/06/01/233545">[軟工] 類別圖「關聯」、「聚合」及「組合」比較</a></li>
<li><a href="https://github.com/macdidi5/UMLTutorial">UML超新手入門</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Entity Relationship Diagram (ERD)]]></title>
    <link href="http://mgleon08.github.com/blog/2018/11/07/entity-relationship-diagram/"/>
    <updated>2018-11-07T15:14:59+08:00</updated>
    <id>http://mgleon08.github.com/blog/2018/11/07/entity-relationship-diagram</id>
    <content type="html"><![CDATA[<p>在工作上時常用到 Entity Relationship Diagram (ERD) 來規劃 DB schema 的關聯，透過這個可以在規劃專案時很清楚知道整個架構，並且讓執行的人也可以很清楚要怎麼實作。</p>

<!-- more -->


<p>畫出來的圖大概會長這樣</p>

<p><img src="https://i.imgur.com/aGA5DHb.png" alt="" /></p>

<p>這邊的重點就是要瞭解中間關聯的線的左右邊代表了什麼意思 (如以下圖)</p>

<p><img src="https://d2slcw3kip6qmk.cloudfront.net/marketing/pages/chart/erd-symbols/ERD-Notation.PNG" alt="ERPD Cardinality" /></p>

<p>以第一張圖舉例來說就代表</p>

<ul>
<li>1 個 customer 可以有 0 個或多個 order</li>
<li>1 個 order 至少有 1 個或多個 product</li>
<li>1 個 product 可以有 0 個或多個 order</li>
<li>1 個 order 至少且只能有一個 customer</li>
</ul>


<p>更進階清楚的話，可以連所有 column 的 type 都寫進去</p>

<p><img src="https://i.imgur.com/KBUmyAK.png" alt="" /></p>

<ul>
<li><a href="https://www.youtube.com/watch?v=QpdhBUYk7Kk">Entity Relationship Diagram (ERD) Tutorial - Part 1</a></li>
<li><a href="https://www.youtube.com/watch?v=-CuY5ADwn24">Entity Relationship Diagram (ERD) Tutorial - Part 2</a></li>
<li><a href="https://www.smartdraw.com/entity-relationship-diagram/">Entity Relationship Diagram</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[簡單理解 CDN 原理]]></title>
    <link href="http://mgleon08.github.com/blog/2018/10/29/understand-cdn/"/>
    <updated>2018-10-29T15:06:53+08:00</updated>
    <id>http://mgleon08.github.com/blog/2018/10/29/understand-cdn</id>
    <content type="html"><![CDATA[<p>近期遇到 CDN 的問題，順便瞭解一下 CDN 整個運作模式</p>

<!-- more -->


<p>原先以為 CDN 會自動做快取直到我們去 purge CDN，但實際上 CDN 是會根據 <code>Response Headers</code> 的</p>

<pre><code>cache-control: max-age=60, public
</code></pre>

<pre><code class="ruby"># rails 中設定 max-age 的方式
expires_in 1.minutes, public: true # public
expires_in 5.minutes # private
</code></pre>

<p>去做對應的 cache (必須用 public)，另外做了 <code>max-age</code> 之後，不只 CDN 會有設定，使用者的瀏覽器也會有設定</p>

<pre><code>server -&gt; CDN -&gt; Browser
60         60       60
</code></pre>

<p>因此如果設定 <code>max-age</code> 60 秒</p>

<ul>
<li>CDN cache 60 秒，在這 60 秒就不會再打 server，直到 60秒過 or <code>purge CDN</code></li>
<li>Browser cache 60 秒，在這 60 秒就不會再打 CDN，直到 60秒過 or <code>clear browser cache</code></li>
</ul>


<blockquote><p>這邊有個重點，當測試的時候，必須開不同的 browser 去做測試，不然直接打 CDN 跟 HTML 打 API 的 url cache 會同步</p></blockquote>

<h1>cache-control</h1>

<blockquote><p>HTTP 1.1 才出現 Cache-Control</p></blockquote>

<p>接著再根據 cache-control 瞭解一下行為，當 browser 設定</p>

<h3>max-age</h3>

<pre><code class="ruby">cache-control: max-age=60, public
</code></pre>

<ul>
<li>第一次訪問，200</li>
<li>第二次訪問時，則會顯示 200(from cache)，後來 google 有更新，就有分 <code>from disk cache(磁盤緩存)</code> 和 <code>from memory cache(內存緩存)</code></li>
</ul>


<pre><code class="ruby">Status Code: 200  (from disk cache)
# 記得必須是用 code 去呼叫才會，不是直接打 api，之前測試直接打會變成 304，改用 script 成功了
</code></pre>

<ul>
<li>但什麼時候是哪種緩存，目前看起來是會根據 google 來判斷 <a href="https://www.zhihu.com/question/64201378">求教大神瀏覽器是根據什麼決定from disk cache 與 from memory cache？</a></li>
<li>如果有 expires(HTTP1.0) 也存在的話，max-age 會蓋過 expires</li>
</ul>


<blockquote><p>「public」和「private」
如果回應標記為「public」，即使具備關聯的 HTTP 認證，甚至回應狀態碼無法正常快取，回應也可以供使用者快取。在大多數情況下，「public」並不是必要項目，因為明確的快取資訊 (例如「max-age」) 已表示 回應可供快取。</p>

<p>另一方面，瀏覽器可以快取「private」回應，但是通常只開放給單一使用者快取，因此不允許任何中繼快取對其進行快取，例如使用者瀏覽器可以快取包含使用者私人資訊的 HTML 網頁，但是 CDN 不能快取。
<a href="https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/http-caching?hl=zh-tw">HTTP 快取</a></p></blockquote>

<h3>no-cache</h3>

<p>當設定以下 <code>no-cache</code>，代表每次都會發送 Request 去確認是否有新的檔案，沒有就會  return <code>304</code></p>

<pre><code class="ruby">cache-control: no-cache
# 相當於 cache-control: max-age=0
</code></pre>

<h3>no-store</h3>

<p>當設定以下 <code>no-store</code>，代表完全不使用快取</p>

<pre><code class="ruby">cache-control: no-store
</code></pre>

<h1>Purge CDN</h1>

<p>通常廠商會提供一隻 API，可以做 purge CDN 的動作，當資料有更新時就可以透過這支 API 把 CDN 清除，讓它重新跟 server 拉取，但有個重點是，<code>max-age</code> 就不能夠設定太長，太長會導致 brower 那邊一直 cache 舊的，即使我們 purge 掉 CDN，brower 也是會等到 <code>max-age</code> 時間到，才會重新去拉 CDN。</p>

<h1>params cache object</h1>

<p>一開始 url 本來是希望帶 params 的方式做 cache，在測試的時候發現，雖然可以做 cache，但在 purge 的時候卻無法清除，看 log 發現顯示 <code>none cache-existing</code>
代表根本沒有清掉 cache，詢問了 cdn 的廠商，原來要有帶 params 的 url，當作是 unique object 算是特殊需求，要另外開啟。</p>

<p>但這家開啟後，萬一之後要換別家，會不會別家沒有支援或是要另外開啟? 所以後來還是改用 <code>path_params</code> 的方式，以防換別家的時候又會有問題</p>

<h1>File Extension</h1>

<p>CDN cache 是根據整個 url，包括副檔名，因此 <code>http://localhost:3000/test.js</code> 和 <code>http://localhost:3000/test.json</code> 會是不同的 url，purge 時也必須指定對應的 url 才能夠 purge</p>

<h1>http/https</h1>

<p>purge 的 url 必須要打一開始設定的 url，<code>http/https</code> 會有差別，如果設定的是 <code>http</code> 就必須針對 <code>http</code> 去做 purge 而不是 <code>https</code></p>

<p>參考文件:</p>

<ul>
<li><a href="https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/http-caching?hl=zh-tw">HTTP 快取</a></li>
<li><a href="https://cythilya.github.io/2018/07/27/http-caching/?fbclid=IwAR1jJfxG2o25i06Pqueb8yE0copC4VSJpbXmr4lG76wPTcDQzGa7ncE6iTk">HTTP Caching</a></li>
<li><a href="https://blog.techbridge.cc/2017/06/17/cache-introduction/">循序漸進理解 HTTP Cache 機制</a></li>
<li><a href="https://excaliburhan.com/post/things-you-should-know-about-browser-cache.html">你應該知道的瀏覽器緩存知識</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Drone]]></title>
    <link href="http://mgleon08.github.com/blog/2018/09/17/drone/"/>
    <updated>2018-09-17T11:25:36+08:00</updated>
    <id>http://mgleon08.github.com/blog/2018/09/17/drone</id>
    <content type="html"><![CDATA[<p>透過 drone 可以很輕易的自己架設一個 CI CD server</p>

<!-- more -->


<blockquote><p>Drone 是一套基於 Docker 容器技術的持續交付平台。</p></blockquote>

<h3>dockerfile</h3>

<pre><code class="ruby">version: '3'

services:
  drone-server:
    image: drone/drone:0.8.5
    container_name: drone-server
    ports:
      - 80:8000
      - 9000
    volumes:
      - ./db:/var/lib/drone/
    restart: always
    environment:
      - DRONE_OPEN=true
      - DRONE_HOST=${DRONE_HOST}
      - DRONE_GITHUB=true
      - DRONE_GITHUB_CLIENT=${DRONE_GITHUB_CLIENT}
      - DRONE_GITHUB_SECRET=${DRONE_GITHUB_SECRET}
      - DRONE_SECRET=${DRONE_SECRET}
      - DRONE_ADMIN=leon
      - DRONE_ORGS=test # Organization 名稱
      - DRONE_DEBUG=true

  drone-agent:
    image: drone/agent:0.8.5
    command: agent
    restart: always
    depends_on:
      - drone-server
    scale: 3
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock
    environment:
      - DRONE_SERVER=drone-server:9000
      - DRONE_SECRET=${DRONE_SECRET}
      - DRONE_MAX_PROCS=3
      - DRONE_DEBUG=true
</code></pre>

<h3>.drone.yml</h3>

<pre><code class="yaml"># 所有流程共享一個 workspace
workspace:
  base: /rails # 所有步驟都可以存取此目錄資料
  path: src/github.com/mgleon08/project # 所有指令都在此目錄執行

# pull git 下來
clone:
  git:
    image: plugins/git:next
    pull: true
    depth: 50
    tags: true # 將 tag 一起拉下來

pipeline:
# 將一些不需要重複 build 的檔案 cache 起來 e.g. gem, node_module
  restore-cache:
    image: drillster/drone-volume-cache
    restore: true
    mount:
      - ./vendor
    # Mount the cache volume, needs "Trusted"
    volumes:
      - /tmp/cache:/cache
    when:
      local: false

  install:
    image: ruby:2.5
    pull: true
    environment:
      - RAILS_ENV=test
      - RAKE_ENV=test
    commands:
      - ruby -v
      - gem -v

      # bundle，檔案位置設定在 vendor/bundle
      - bundle check --path=vendor/bundle || bundle install --path=vendor/bundle --jobs=4 --retry=3

      # config
      - cp config/database.ci.yml config/database.yml

      # setup secrets and db migration
      - bundle exec rails -v
      - bundle exec rake generate:secrets --trace
      - bundle exec rake db:create db:migrate --trace
    when:
      local: false

  rubocop:
    image: ruby:2.5
    group: testing # 同一個 group 可同時執行，平行測試
    commands:
      - bundle check --path=vendor/bundle || bundle install --path=vendor/bundle --jobs=4 --retry=3
      - bundle exec rubocop -c .rubocop.yml || true
      - bundle exec rubocop -c .rubocop.yml --format=json --out=rubocop-result.json || true

  flay:
    image: ruby:2.5
    group: testing
    commands:
      - bundle check --path=vendor/bundle || bundle install --path=vendor/bundle --jobs=4 --retry=3
      - bundle exec flay app

  rspec:
    image: ruby:2.5
    group: testing
    environment:
      - RAILS_ENV=test
      - RAKE_ENV=test
    commands:
        - bundle check --path=vendor/bundle || bundle install --path=vendor/bundle --jobs=4 --retry=3
        - bundle exec rspec --color --tag ~@feature
    when:
      local: false

  rebuild-cache:
    image: drillster/drone-volume-cache
    group: cleanup
    rebuild: true
    mount:
      - ./vendor
    # Mount the cache volume, needs "Trusted"
    volumes:
      - /tmp/cache:/cache
    when:
      local: false

  notify:
    image: plugins/slack
    secrets: [ slack_webhook ] # 在 drone 介面上設定環境變數 secrets
    channel: channel_name
    username: Drone CI
    when:
      status: [ success, failure ] # 成功或失敗都通知訊息
      local: false

# database.yml 裡面的 database 要跟下面定義的名字一樣，這邊也是叫 database
services:
  database:
    image: mysql:5.7
    environment: # 全域變數
      - MYSQL_ALLOW_EMPTY_PASSWORD=yes
</code></pre>

<ul>
<li><a href="https://yeasy.gitbooks.io/docker_practice/cases/ci/drone.html">Build Drone</a></li>
<li><a href="http://docs.drone.io/zh/">docs drone</a></li>
<li><a href="http://plugins.drone.io/">plugins.drone.io</a></li>
<li><a href="https://www.slideshare.net/appleboy/drone-79506886">用 Drone 打造輕量級容器持續交付平台</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JSON Web Token(JWT) 簡單介紹]]></title>
    <link href="http://mgleon08.github.com/blog/2018/07/16/jwt/"/>
    <updated>2018-07-16T17:48:22+08:00</updated>
    <id>http://mgleon08.github.com/blog/2018/07/16/jwt</id>
    <content type="html"><![CDATA[<p>之前常常聽到 jwt，但沒有很了解，就來研究一下吧</p>

<!-- more -->


<h1>什麼是 JWT</h1>

<ul>
<li>JWT 是基於 JSON 的開放標準 (RFC 7519)</li>
<li>一般被用來在 身份提供者 和 服務提供者 間傳遞被 認證 的用戶身份訊息，以便於從資源伺服器獲取資源</li>
<li>同時也可以增加一些額外的聲明訊息，該 token 也可直接被用於認證，也可被加密</li>
<li>特別適用於分佈式站點的單點登錄（SSO）場景</li>
</ul>


<p>先來瞭解一般 session 和 jwt 的差別</p>

<h2>Session</h2>

<p>Http 協議本身是無狀態的，所以無法知道每個 request 來的是誰? 因此用戶每次 request 就必須提供帳號密碼，以便證明身份，但每次都要另外輸入帳號密碼，豈不是很麻煩?</p>

<p>所以當用戶第一次發 request 過來後，就會產生一組 token 紀錄在 db 和 session，並且將這組 token 給用戶，告訴其保存在 cookie，當下次發 request 的時候，就直接帶這組 token 以便證明身份。</p>

<h2>JWT</h2>

<p>JWT 的組成內容有三個部分，由 <code>.</code> 做區隔，最後透過這三個部分，串成一個 Jwt 字串</p>

<h3>1. Header 頭部</h3>

<pre><code class="ruby">{
  'typ': 'JWT', # 聲明類型
  'alg': 'HS256' # 加密的方法: HMAC、SHA256、RSA 進行 Base64 編碼
}
</code></pre>

<p>進行 base64 加密（該加密是可以對稱解密的)</p>

<pre><code class="ruby">eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9
</code></pre>

<h3>2. Payload 載荷</h3>

<p>這裡放聲明內容，可以說就是存放溝通訊息的地方，在定義上有 3 種聲明 (Claims)</p>

<ul>
<li>Reserved (註冊聲明)</li>
<li>Public (公開聲明)</li>
<li>Private (私有聲明)</li>
</ul>


<p>註冊聲明參數 (建議但不強制使用)</p>

<ul>
<li>iss (Issuer) - jwt簽發者</li>
<li>sub (Subject) -  jwt所面向的用戶</li>
<li>aud (Audience) - 接收jwt的一方</li>
<li>exp (Expiration Time) - jwt的過期時間，這個過期時間必須要大於簽發時間</li>
<li>nbf (Not Before) - 定義在什麼時間之前，該jwt都是不可用的</li>
<li>iat (Issued At) - jwt的簽發時間</li>
<li>jti (JWT ID) - jwt的唯一身份標識，主要用來作為一次性token,從而迴避重放攻擊</li>
</ul>


<pre><code class="ruby">{
  "sub": "1234567890",
  "name": "John Doe",
  "iat": 1516239022
}
</code></pre>

<p>進行 base64 加密（該加密是可以對稱解密的)</p>

<pre><code class="ruby">eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9
</code></pre>

<h3>3. Signature</h3>

<p>由三個部分組成</p>

<ul>
<li>header (base64後的)</li>
<li>payload (base64後的)</li>
<li>secret</li>
</ul>


<pre><code class="ruby">HMACSHA256(base64UrlEncode(header) + "." + base64UrlEncode(payload), 'secret')
</code></pre>

<blockquote><p>secret 要保存在 server 端，jwt 的 簽發驗證都必須使用這個 secret，當其他人得知這個 secret，那就意味著客戶端是可以自我簽發 jwt ，因此在任何場景都不應該外流</p></blockquote>

<p>進行 base64 加密</p>

<pre><code class="ruby">SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c
</code></pre>

<p>最後由三個部分由 <code>.</code> 組成</p>

<pre><code class="ruby">eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c
</code></pre>

<h1>使用方法</h1>

<p>在發 request 的時候在 header 加入 <code>Authorization: Bearer &lt;token&gt;</code></p>

<pre><code class="ruby">post('api/user/1', {
  headers: {
    'Authorization': 'Bearer ' + token
  }
})
</code></pre>

<p><img src="https://cdn.auth0.com/content/jwt/jwt-diagram.png" alt="" /></p>

<h1>優點</h1>

<ul>
<li>跨語言，因為 json 格式大部分語言都可使用</li>
<li>可儲存一些簡單但非敏感的商業邏輯 - role ..</li>
<li>構成內容簡單，佔用 Size 小方便傳輸</li>
<li>不需在 server 保存 session，所以它易於應用的擴展</li>
</ul>


<h1>安全相關 Security</h1>

<ul>
<li>Base64 是可逆的加密方式，不適合存放敏感訊息，因為該部分是客戶端可解密的部分</li>
<li>用來加密的 Secret 要保護好，存在 server 端</li>
<li>使用 Https 協議 - 避免敏感訊息被嗅探</li>
<li>使用 HttpOnly 來防止 Cookie 被 JavaScript 讀取，從而避免跨站腳本攻擊（XSS攻擊）</li>
</ul>


<h1>JWT的適用場景</h1>

<ul>
<li>一次性驗證  ex: 信件中的連結</li>
<li>restful api 的無狀態認證</li>
<li>單點登錄+會話管理(不推薦，絕大多數情況下，傳統的 cookie-session 機制工作得更好)</li>
</ul>


<p>參考文件:</p>

<ul>
<li><a href="https://jwt.io/">JWT</a></li>
<li><a href="https://www.jianshu.com/p/576dbf44b2ae">什麼是 JWT &ndash; JSON WEB TOKEN</a></li>
<li><a href="https://hk.saowen.com/a/e86e2d932aa9b5dc3d11d639e9940eb55812f030029fac54245f6d1f9eef6f23">不要用JWT替代session管理（上）：全面瞭解Token,JWT,OAuth,SAML,SSO</a></li>
<li><a href="https://blog.leapoahead.com/2015/09/06/understanding-jwt/">JSON Web Token - 在Web應用間安全地傳遞訊息</a></li>
<li><a href="http://blog.leapoahead.com/2015/09/07/user-authentication-with-jwt/">八幅漫畫理解使用JSON Web Token設計單點登錄系統</a></li>
<li><a href="https://hk.saowen.com/a/afdc2b0fb445a973bed63330596f8588ad8f86da0faf6b5af5211ff3e29c2da8">理解JWT的使用場景和優劣</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
