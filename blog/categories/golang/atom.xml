<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Golang | Leon's Blogging]]></title>
  <link href="http://mgleon08.github.com/blog/categories/golang/atom.xml" rel="self"/>
  <link href="http://mgleon08.github.com/"/>
  <updated>2019-04-02T09:56:32+08:00</updated>
  <id>http://mgleon08.github.com/</id>
  <author>
    <name><![CDATA[LeonJi]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Golang - Testing]]></title>
    <link href="http://mgleon08.github.com/blog/2019/03/28/golang-testing/"/>
    <updated>2019-03-28T18:24:12+08:00</updated>
    <id>http://mgleon08.github.com/blog/2019/03/28/golang-testing</id>
    <content type="html"><![CDATA[<!-- more -->


<h1>Testing</h1>

<ul>
<li>檔案的結尾必須是，<code>測試檔案名稱</code> + <code>_test</code></li>
<li>測試函式必須是 <code>Test</code> 開頭，且必須第一個字母大寫(public)</li>
<li>測試函式 <code>TestXxx()</code> 的參數是 <code>testing.T</code>，我們可以使用該型別來記錄錯誤或者是測試狀態</li>
<li>要使用 <code>testing</code> package</li>
<li>測試案例會按照原始碼中寫的順序依次執行</li>
<li>函式中透過呼叫 <code>testing.T</code> 的 <code>Error</code>, <code>Errorf</code>, <code>FailNow</code>, <code>Fatal</code>, <code>FatalIf</code> 方法，說明測試不透過，呼叫 <code>Log</code> 方法用來記錄測試的資訊。</li>
</ul>


<h3>main.go</h3>

<pre><code class="go">// main.go
package main

import (
    "errors"
    "fmt"
)

func Division(a, b float64) (float64, error) {
    if b == 0 {
        return 0, errors.New("b can not be 0")
    }
    return a / b, nil
}

func main() {
    fmt.Println(Division(60, 2))
}
</code></pre>

<h3>main_test.go</h3>

<pre><code class="go">// main_test.go
package main

import (
    "testing"
)

func Test_division_1(t *testing.T) {
    if i, e := division(6, 2); i != 3 || e != nil {
        t.Error("失敗")
    } else {
        t.Log("成功")
    }
}

func Test_division_2(t *testing.T) {
    t.Error("失敗")
}

func Test_division_table(t *testing.T) {
    tables := []struct {
        x float64
        y float64
    }{
        {3, 1},
        {6, 2},
        {9, 3},
        {8, 2},
    }

    for _, table := range tables {
        if i, e := division(table.x, table.y); i != 3 || e != nil {
            t.Error("失敗")
        } else {
            t.Log("成功")
        }
    }
}
</code></pre>

<h3>Run test</h3>

<pre><code class="go">// go test -v -cover

=== RUN   Test_Division_1
--- PASS: Test_Division_1 (0.00s)
    main_test.go:11: 成功
=== RUN   Test_Division_2
--- FAIL: Test_Division_2 (0.00s)
    main_test.go:16: 失敗
=== RUN   Test_Division_table
--- FAIL: Test_Division_table (0.00s)
    main_test.go:34: 成功
    main_test.go:34: 成功
    main_test.go:34: 成功
    main_test.go:32: 失敗
FAIL
coverage: 50.0% of statements
exit status 1
FAIL    github.com/mgleon08/packages/015.test   0.007s
</code></pre>

<h1>Benchmark testing</h1>

<ul>
<li>檔案的結尾必須是，<code>測試檔案名稱</code> + <code>_test</code></li>
<li>測試函式必須是 <code>Benchmark</code> 開頭，且必須第一個字母大寫(public)</li>
<li><code>for</code> 循環內要放置要測試的程式碼</li>
<li><code>b.N</code> 是 go 語言內建提供的循環，根據一秒鐘的時間計算</li>
<li>測試函式 <code>Benchmark_xxx()</code> 的參數是 <code>b *testing.B</code></li>
</ul>


<h3>webbench_test.go</h3>

<pre><code class="go">// webbench_test.go

package main

import (
    "testing"
)

func Benchmark_Division(b *testing.B) {
    for i := 0; i &lt; b.N; i++ { //use b.N for looping
        Division(4, 5)
    }
}

func Benchmark_TimeConsumingFunction(b *testing.B) {
    b.StopTimer() //呼叫該函式停止壓力測試的時間計數

    //做一些初始化的工作，例如讀取檔案資料，資料庫連線之類別的,
    //這樣這些時間不影響我們測試函式本身的效能

    b.StartTimer() //重新開始時間
    for i := 0; i &lt; b.N; i++ {
        Division(4, 5)
    }
}
</code></pre>

<h3>Run benchmark test</h3>

<p>跑測試 <code>go test -v -bench=. -run=none</code></p>

<pre><code class="go">// go test -v -bench=. -run=none . -cover 

goos: darwin
goarch: amd64
pkg: github.com/mgleon08/packages/015.test
Benchmark_Division-4                    2000000000               0.43 ns/op
Benchmark_TimeConsumingFunction-4       2000000000               0.42 ns/op
PASS
coverage: 50.0% of statements
ok      github.com/mgleon08/packages/015.test   1.802s
</code></pre>

<ul>
<li><code>-bench</code> - 要跑 Benchmark</li>
<li><code>-run=none</code> - 不要跑一般的測試</li>
<li><code>-4</code> - 目前的 CPU 核心數，也就是 GOMAXPROCS 的值</li>
<li><code>-benchtime=2s</code> - 加上這個代表跑 2 秒</li>
</ul>


<h1>Example testing</h1>

<ul>
<li>檔案的結尾必須是，<code>測試檔案名稱</code> + <code>_test</code></li>
<li>測試函式必須是 <code>Example</code> 開頭，且必須第一個字母大寫(public)</li>
<li><code>Output:</code> 是固定格式</li>
</ul>


<pre><code class="go">package main

import (
    "fmt"
)

func ExampleDivision() {
    i, _ := Division(6, 1)
    fmt.Print(i)
    // Output: 6
}

func ExampleDivision2() {
    i, _ := Division(6, 2)
    x, _ := Division(12, 3)
    fmt.Println(i)
    fmt.Println(x)
    // Output:
    // 3
    // 4
}
</code></pre>

<p>Reference</p>

<ul>
<li><a href="https://github.com/astaxie/build-web-application-with-golang/blob/master/zh-tw/11.3.md">11.3 Go 怎麼寫測試案例</a></li>
<li><a href="https://blog.wu-boy.com/2018/05/how-to-write-testing-in-golang/">如何在 Go 專案內寫測試</a></li>
<li><a href="https://blog.wu-boy.com/2018/06/how-to-write-benchmark-in-go/">如何在 Go 語言內寫效能測試</a></li>
<li><a href="https://ithelp.ithome.com.tw/articles/10206088">Example 示例函式</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Golang - MySQL]]></title>
    <link href="http://mgleon08.github.com/blog/2019/03/11/golang-mysql/"/>
    <updated>2019-03-11T23:13:41+08:00</updated>
    <id>http://mgleon08.github.com/blog/2019/03/11/golang-mysql</id>
    <content type="html"><![CDATA[<!-- more -->


<p>golang 在 database 上的存取，建立了一個 sql 抽象介面 <a href="https://golang.org/pkg/database/sql/">database/sql</a>，接著大家就可以透過這個 interface 去實作裡面相對應的 driver</p>

<p>目前看到比較多人使用的是 <a href="https://github.com/go-sql-driver/mysql">go-sql-driver/mysql</a></p>

<h1>install</h1>

<pre><code class="go">go get github.com/go-sql-driver/mysql
</code></pre>

<h1>connect to database</h1>

<pre><code class="go">package main

import (
    "database/sql"
    "fmt"
    "strings"

    _ "github.com/go-sql-driver/mysql"
)

// db 設定
const (
    userName = "root"
    password = ""
    host     = "127.0.0.1"
    port     = "3306"
    dbName   = "dbName"
)

func initDB() {
    // [username[:password]@][protocol[(address)]]/dbname[?param1=value1&amp;...&amp;paramN=valueN]
    // "username:password@tcp(host:port)/數據庫?charset=utf8"
    path := strings.Join([]string{userName, ":", password, "@tcp(", host, ":", port, ")/", dbName, "?charset=utf8"}, "")
    fmt.Println(path)

    // 第一個是 driverName 第二個則是 database 的設定 path
    // 也可以用 var DB *sql.DB
    DB, _ := sql.Open("mysql", path)

    // 設定 database 最大連接數
    DB.SetConnMaxLifetime(100)

    //設定上 database 最大閒置連接數
    DB.SetMaxIdleConns(10)

    // 驗證是否連上 db
    if err := DB.Ping(); err != nil {
        fmt.Println("opon database fail:", err)
        return
    }
    fmt.Println("connnect success")
}

func main() {
    initDB()
}
</code></pre>

<h1>query</h1>

<h3>Exec</h3>

<pre><code class="go">result, err := db.Exec(
    "INSERT INTO users (name) VALUES (?)",
    "leon",
)
</code></pre>

<h3>QueryRow</h3>

<pre><code class="go">var id int64
row := DB.QueryRow("SELECT id FROM users WHERE name = ?", "leon")
err := row.Scan(&amp;id)
if err != nil {
    log.Fatal(err)
}
fmt.Println(id)
</code></pre>

<h3>Query</h3>

<pre><code class="go">rows, err := DB.Query("SELECT * FROM banner")
if err != nil {
  log.Fatal(err)
}

// 記得要 close
defer rows.Close()
for rows.Next() {
  var id, width, height int64
  if err := rows.Scan(&amp;id, &amp;width, &amp;height); err != nil {
    log.Fatal(err)
  }
  fmt.Printf("id: %v, width: %v, height: %v\n", id, width, height)
}
if err := rows.Err(); err != nil {
  log.Fatal(err)
}
</code></pre>

<h3>Prepare</h3>

<pre><code class="go">width := 640
stmt, err := DB.Prepare("SELECT id FROM banner WHERE width = ?")
if err != nil {
  log.Fatal(err)
}
rows, err := stmt.Query(width)

// 記得要 close
defer rows.Close()
for rows.Next() {
  var id int64
  if err := rows.Scan(&amp;id); err != nil {
    log.Fatal(err)
  }
  fmt.Printf("id: %v\n", id)
}
</code></pre>

<h3>Begin (transcation)</h3>

<pre><code class="go">// 開啟 transaction
tx, err := DB.Begin()
if err != nil {
  fmt.Println("tx fail")
  return
}
// 準備 sql 語句
stmt, err := tx.Prepare("INSERT INTO banner (`id`, `width`, `height`) VALUES (?, ?, ?)")
if err != nil {
  fmt.Println("Prepare fail")
  return
}
// 設定參數以及執行 sql 語句
res, err := stmt.Exec(100, 200, 300)
if err != nil {
  fmt.Println("Exec fail")
  return
}
// 提交 transaction
tx.Commit()
// 取得最後一個 insert 的 id
fmt.Println(res.LastInsertId())
</code></pre>

<h1>各種方式效率分析</h1>

<p>先參照 <a href="https://studygolang.com/articles/3022">golang學習之旅：使用go語言操作mysql數據庫</a> 之後有用到再來研究</p>

<p>Reference:</p>

<ul>
<li><a href="https://golang.org/pkg/database/sql/">database/sql</a></li>
<li><a href="https://github.com/go-sql-driver/mysql">go-sql-driver/mysql</a></li>
<li><a href="https://www.jianshu.com/p/ee87e989f149">Golang連接mysql數據庫</a></li>
<li><a href="https://studygolang.com/articles/3022">golang學習之旅：使用go語言操作mysql數據庫</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Golang Implementation of gRPC]]></title>
    <link href="http://mgleon08.github.com/blog/2019/03/07/golang-grpc/"/>
    <updated>2019-03-07T21:57:06+08:00</updated>
    <id>http://mgleon08.github.com/blog/2019/03/07/golang-grpc</id>
    <content type="html"><![CDATA[<!-- more -->


<p>最近剛好看到 gRPC 蠻好奇是什麼的，就來了解一下，並試著用 golang 去實現</p>

<h1>What are protocol buffers?</h1>

<blockquote><p>Protocol buffers are Google&rsquo;s language-neutral, platform-neutral, extensible mechanism for serializing structured data</p></blockquote>

<ul>
<li>簡單的來說，就是類似像 <code>JSON</code>，<code>XML</code> 的序列化結構資料格式，但是更小、更快，而且更簡潔</li>
<li>目前支援多種語言 <code>Java</code>, <code>Python</code>, <code>Objective-C</code>, <code>C++</code>, <code>Go</code>, <code>Ruby</code>, and <code>C#</code></li>
<li>只需要定義一次資料結構，就能自動生成符合你程式語言的檔案，讓你能夠直接在你的程式上使用。</li>
<li>結構就是文件，不需額外撰寫 API 文件，<code>.proto</code> 檔本身就是一種「文件」。</li>
</ul>


<h1>What are gRPC?</h1>

<ul>
<li>Simple service definition - 透過 <code>Protocol Buffers</code> 定義 service，就是可以在 <code>.proto</code> 檔案就可以定義好 service 內容</li>
<li>Works across languages and platforms - 自動生成支援客戶端的語言，由下圖解說就是，Server跟 Client 端都透過 <code>protocol buffers</code> 來做傳遞，但三個分別是 <code>ruby</code>, <code>java</code>, <code>c++</code></li>
</ul>


<p><img src="https://grpc.io/img/landing-2.svg" alt="" /></p>

<ul>
<li>Start quickly and scale</li>
<li>Bi-directional streaming and integrated authBi-directional</li>
</ul>


<h1>Quick Start</h1>

<ul>
<li>各種語言都能夠設定，這裡主要先用 Golang <a href="https://grpc.io/docs/quickstart/go.html">quickstart</a></li>
</ul>


<blockquote><p>基本的開發步驟是定義 proto 文件， 定義請求 Request 和 響應 Response 的格式，然後定義一個服務 Service， Service可以包含多個方法。</p></blockquote>

<h3>gRPC requires Go <code>1.6</code> or <code>higher</code>.</h3>

<pre><code class="go">go version
</code></pre>

<h3>Install gRPC</h3>

<pre><code>go get -u google.golang.org/grpc
</code></pre>

<h3>Install Protocol Buffers v3</h3>

<p><a href="https://github.com/protocolbuffers/protobuf/releases">https://github.com/protocolbuffers/protobuf/releases</a></p>

<ul>
<li>根據自己用的 platform，下載編譯好的檔案，並解壓縮</li>
<li>將 <code>bin/protoc</code> binary file 放置在 PATH 底下( ex. <code>$GOPATH/bin</code>)</li>
</ul>


<h3>install the protoc plugin for Go</h3>

<pre><code class="go">go get -u github.com/golang/protobuf/protoc-gen-go
</code></pre>

<h1>Try it!</h1>

<blockquote><p>gRPC services are defined in a <code>.proto</code> file, which is used to generate a corresponding <code>.pb.g</code> file.</p>

<p>The <code>.pb.go</code> file is generated by compiling the <code>.proto</code> file using the protocol compiler: protoc.</p></blockquote>

<p>下載 <code>grpc</code> 時會有一個範例</p>

<pre><code class="go">cd $GOPATH/src/google.golang.org/grpc/examples/helloworld
</code></pre>

<p>體驗一下，先啟動 sever</p>

<pre><code class="go">go run greeter_server/main.go
</code></pre>

<p>再跑 client 會發現 response 回來的資料</p>

<pre><code class="go">go run greeter_client/main.go

// Greeting: Hello world
</code></pre>

<h1>Example</h1>

<p>建立資料夾</p>

<pre><code class="go">.
├── client   // gRPC 客戶端
├── pb       // 擺放 Protobuf 文件
└── server   // gRPC 伺服器
</code></pre>

<ul>
<li><code>client</code>：gRPC client，用來和伺服器溝通的程式</li>
<li><code>pb</code>: 定義的 Protobuf 文件，也會放置轉化後的 Protobuf 程式</li>
<li><code>server</code>: gRPC server</li>
</ul>


<h3>proto</h3>

<p>定義資料格式</p>

<pre><code class="go">// 撰寫格式是 Proto v3。
syntax = "proto3";
// 生成的程式在 Golang 中將會屬於 `pb` 套件。
package pb;

// Calculator 定義了一個計算用的服務。
service Calculator {
    // Plus 會接收 CalcRequest 資料作加總，最終會回傳 CalcReply。
    rpc Plus (CalcRequest) returns (CalcReply) {}
}

// CalcRequest 包含了兩個數字，將會傳送至計算服務並對兩個數字進行計算。
message CalcRequest {
// 後面的數字是 Protocol Buffers 編碼與解碼所會用到的編號，能夠移除其中一個欄位而不打亂整個資料結構的編碼與解碼(除非更改了數字編號)
    int32 number_a = 1;
    int32 number_b = 2;
}

// CalcReply 是計算結果，將會回傳給客戶端。
message CalcReply {
    int32 result = 1;
}
</code></pre>

<p>透過 <code>protoc</code> 產生 <code>.pb.g</code></p>

<pre><code class="go">protoc --go_out=plugins=grpc:. *.proto
</code></pre>

<ul>
<li>Generated client and server code.</li>
<li>Code for populating, serializing, and retrieving our <code>HelloRequest</code> and <code>HelloReply</code> message types.</li>
</ul>


<p>目前資料夾</p>

<pre><code class="go">.
├── client
│   └── main.go
├── pb
│   ├── calc.pb.go
│   └── calc.proto
└── server
    └── main.go
</code></pre>

<h3>server</h3>

<pre><code class="go">// server/main.go
package main

import (
    "context"
    "log"
    "net"

    "google.golang.org/grpc"

    "github.com/mgleon08/demo_proto/pb"
)

const (
    port = ":50051"
)

// server 建構體會實作 Calculator 的 gRPC 伺服器。
type server struct{}

// Plus 會將傳入的數字加總。
func (s *server) Plus(ctx context.Context, in *pb.CalcRequest) (*pb.CalcReply, error) {
    // 計算傳入的數字。
    result := in.NumberA + in.NumberB
    // 包裝成 Protobuf 建構體並回傳。
    return &amp;pb.CalcReply{Result: result}, nil
}

func main() {
    // 監聽指定埠口，這樣服務才能在該埠口執行。
    lis, err := net.Listen("tcp", port)
    if err != nil {
        log.Fatalf("無法監聽該 port: %v", err)
    }

    // 建立新 gRPC 伺服器並註冊 Calculator 服務。
    s := grpc.NewServer()
    // RegisterCalculatorServer 是透過 .proto 定義轉換而成
    pb.RegisterCalculatorServer(s, &amp;server{})

    // 開始在指定埠口中服務。
    if err := s.Serve(lis); err != nil {
        log.Fatalf("無法提供服務: %v", err)
    }
}
</code></pre>

<h3>client</h3>

<pre><code class="go">// client/main.go
package main

import (
    "context"
    "log"

    "google.golang.org/grpc"

    "github.com/mgleon08/demo_proto/pb"
)

const (
    address = "localhost:50051"
)

func main() {
    // 建立連線到遠端 gRPC 伺服器。
    conn, err := grpc.Dial(address, grpc.WithInsecure())
    if err != nil {
        log.Fatalf("無法連線: %v", err)
    }
    // 結束後要關閉
    defer conn.Close()

    // 建立新的 Calculator 客戶端，所以等一下就能夠使用 Calculator 的所有方法。
    c := pb.NewCalculatorClient(conn)

    // 傳送新請求到遠端 gRPC 伺服器 Calculator 中，並呼叫 Plus 函式，讓兩個數字相加。
    r, err := c.Plus(context.Background(), &amp;pb.CalcRequest{NumberA: 32, NumberB: 32})
    if err != nil {
        log.Fatalf("無法執行 plus: %v", err)
    }
    log.Printf("回傳結果: %d", r.Result)
}
</code></pre>

<h3>啟動</h3>

<pre><code class="go">// 先啟動 server
go run ./server/main.go  

// 再啟動 client，就會有 response
go run ./client/main.go  
</code></pre>

<h3>demo</h3>

<p><a href="https://github.com/mgleon08/go-grpc-demo">go-grpc-demo</a></p>

<p>Reference:</p>

<ul>
<li><a href="https://grpc.io/">gprc</a></li>
<li><a href="https://developers.google.com/protocol-buffers/">Protocol Buffers</a></li>
<li><a href="https://codinganimal.info/grpc-tutorial-for-python-2fa0fe2ff853">gRPC Tutorial for Python</a></li>
<li><a href="https://yami.io/grpc/">API 文件就是你的伺服器，REST 的另一個選擇：gRPC</a></li>
<li><a href="https://yami.io/protobuf/">比起 JSON 更方便、更快速、更簡短的 Protobuf 格式</a></li>
<li><a href="https://www.youtube.com/watch?v=NoDRq6Twkts">Getting Started with Protocol Buffers in Go - Tutorial</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Golang - JSON and Go]]></title>
    <link href="http://mgleon08.github.com/blog/2019/02/17/golang-json-and-go/"/>
    <updated>2019-02-17T22:40:16+08:00</updated>
    <id>http://mgleon08.github.com/blog/2019/02/17/golang-json-and-go</id>
    <content type="html"><![CDATA[<!-- more -->


<h1>Encoding - Marshal 序列化</h1>

<p>在 Go 中並不是所有的類型都能進行序列化：</p>

<ul>
<li>必須是 struct 中支援外部引用的 field 才能夠序列化 (即開頭字母大寫的 field)</li>
<li>JSON object key 只支援 string</li>
<li>Channel、complex、function 等 type 無法進行序列化</li>
<li>不支援循環數據結構，因為序列化時會進行無限迴圈</li>
<li><code>Pointer</code> 序列化之後是其指向的值或者是 <code>nil</code></li>
</ul>


<pre><code class="go">func Marshal(v interface{}) ([]byte, error)
</code></pre>

<pre><code class="go">package main

import (
    "encoding/json"
    "fmt"
)

type UserInfo struct {
    Name string
    Say  string
    Age int64 
}

func main() {
    m := UserInfo{"Leon", "Hello", 18}
    b, _ := json.Marshal(m)
    fmt.Println(string(b))
}

// {"Name":"Leon","Say":"Hello","Age":18}
</code></pre>

<h1>指定 JSON filed name</h1>

<h3>Struct Tag</h3>

<p><code>Struct tag</code> 可以決定 <code>Marshal</code> 和 <code>Unmarshal</code> 函式如何序列化和反序列化數據。</p>

<ul>
<li>一般 <code>json</code> 都是小寫，但因為 golang 序列化時，struct 必須是大寫，因此透過 <code>Struct Tag</code> 改成小寫</li>
</ul>


<pre><code class="go">package main

import (
    "encoding/json"
    "fmt"
)

type UserInfo struct {
    Name string `json:"name"`
    Say  string `json:"say"`
    Age int64   `json:"age"`
}

func main() {
    m := UserInfo{"Leon", "Hello", 18}
    b, _ := json.Marshal(m)
    fmt.Println(string(b))
}

// {"name":"Leon","say":"Hello","age":18}
</code></pre>

<h1>指定 field 的行為</h1>

<h3>omitempty</h3>

<p>透過 <code>omitempty</code> 如果 field 的值是對應類型的 <code>zero-value</code>，序列化之後的 <code>JSON object</code> 中不包含此 <code>field</code></p>

<pre><code class="go">package main

import (
    "encoding/json"
    "fmt"
)

type UserInfo struct {
    Name string `json:"name"`
    Say  string `json:"say"`
    Age int64   `json:"age,omitempty"`
}

func main() {
    m := UserInfo{}
    b, _ := json.Marshal(m)
    fmt.Println(string(b))
}

// {"name":"","say":""}
</code></pre>

<h3>-</h3>

<p>透過 <code>-</code> 可以忽略掉該 field</p>

<pre><code class="go">package main

import (
    "encoding/json"
    "fmt"
)

type UserInfo struct {
    Name string `json:"name"`
    Say  string `json:"-"`
    Age int64   `json:"age,omitempty"`
}

func main() {
    m := UserInfo{"Leon", "Hello", 18}
    b, _ := json.Marshal(m)
    fmt.Println(string(b))
}

// {"name":"Leon","age":18}
</code></pre>

<h1>Decoding - Unmarshal 反序列化</h1>

<p>預設的 JSON 支援以下幾種 Go 類型：</p>

<pre><code class="go">bool for JSON booleans
float64 for JSON numbers
string for JSON strings
nil for JSON null
</code></pre>

<h3>知道類型的反序列化</h3>

<pre><code class="go">package main

import (
    "encoding/json"
    "fmt"
)

type UserInfo struct {
    Name string `json:"name"`
    Say string  `json:"say"`
    Age int64   `json:"age"`
}

func main() {
    var jsonString string
    jsonString = `{"name":"Leon","say":"hello","age":18}`

    //把 json unmarshal 進去 struct
    u := &amp;UserInfo{}
    err := json.Unmarshal([]byte(jsonString), u)
    if err != nil {
        fmt.Println(err)
        return
    }
    fmt.Println(u)
    fmt.Printf("%T\n", u)
    fmt.Printf("name:%s, say:%s, age:%d\n", u.Name, u.Say, u.Age)
}

// &amp;{Leon hello 18}
// *main.UserInfo
// name:Leon, say:hello, age:18
</code></pre>

<h3>不知道類型的反序列化</h3>

<p>如果不知道類型可以用 <code>interface{}</code></p>

<pre><code class="go">package main

import (
    "encoding/json"
    "fmt"
)

func main() {
    var jsonString string
    jsonString = `{"name":"Leon","age":18,"cars":["Maserati","BMW"]}`

    //把 json unmarshal 進去 struct
    var u interface{}
    err := json.Unmarshal([]byte(jsonString), &amp;u)
    if err != nil {
        fmt.Println(err)
        return
    }
    fmt.Println(u)
    fmt.Printf("%T\n", u)
}

// map[cars:[Maserati BMW] name:Leon age:18]
// map[string]interface {}
</code></pre>

<p>回傳的格式如</p>

<pre><code class="go">map[string]interface{}{
    "Name": "Leon",
    "age":  18,
    "cars": []interface{}{
        "Maserati",
        "BMW",
    },
}
</code></pre>

<p>key 是 <code>string</code>，value 是 <code>interface{}</code>，必須透過 <code>type assertion</code> 和 <code>range</code> 取得所有的 key</p>

<pre><code class="go">package main

import (
    "encoding/json"
    "fmt"
)

func showInfo(u interface{}){
    m := u.(map[string]interface{})
    for k, v := range m {
        switch vv := v.(type) {
        case string:
            fmt.Println(k, "is string", vv)
        case float64:
            fmt.Println(k, "is float64", vv)
        case []interface{}:
            fmt.Println(k, "is an array:")
            for i, u := range vv {
                fmt.Println(i, u)
            }
        default:
            fmt.Println(k, "is of a type I don't know how to handle")
        }
    }
}

func main() {
    var jsonString string
    jsonString = `{"name":"Leon","age":18,"cars":["Maserati","BMW"]}`

    //把 json unmarshal 進去 struct
    var u interface{}
    err := json.Unmarshal([]byte(jsonString), &amp;u)
    if err != nil {
        fmt.Println(err)
        return
    }
    showInfo(u)
}

// name is string Leon
// age is float64 18
// cars is an array:
// 0 Maserati
// 1 BMW
</code></pre>

<h1>Reference Types - 反序列化對 slice、map、pointer 的處理</h1>

<p>struct 中包含一個 <code>slice Cars</code> ，slice 預設是 <code>nil</code>，之所以反序列化可以正常進行就是因為 Unmarshal 在序列化時進行了對 <code>slice Cars</code> 做了初始化，同理，對 <code>map</code> 和 <code>pointer</code> 都會做類似的工作</p>

<blockquote><p>比如序列化如果 Pointer 不是 nil 首先進行 dereference 獲得其指向的值，然後再進行序列化，反序列化時首先對 nil pointer 進行初始化</p></blockquote>

<pre><code class="go">package main

import (
    "encoding/json"
    "fmt"
)

type UserInfo struct {
    Name string 
    Age  int64  
    Cars []string
}

func main() {
    var jsonString string
    jsonString = `{"name":"Leon","age":18,"cars":["Maserati","BMW"]}`

    //把 json unmarshal 進去 struct
    u := &amp;UserInfo{}
    err := json.Unmarshal([]byte(jsonString), u)
    if err != nil {
        fmt.Println(err)
        return
    }
    fmt.Println(u)
    fmt.Printf("%T\n", u)
    fmt.Printf("name:%s, age:%d, cars:%s\n", u.Name, u.Age, u.Cars)
}

// &amp;{Leon 18 [Maserati BMW]}
// *main.UserInfo
// name:Leon, age:18, cars:[Maserati BMW]
</code></pre>

<h1>nested struct 的序列化</h1>

<p>Go 支援對 <code>nested struct</code> 進行序列化和反序列化:</p>

<pre><code class="go">package main

import (
    "encoding/json"
    "fmt"
)

type App struct {
    Id string `json:"id"`
}

type Org struct {
    Name string `json:"name"`
}

type AppWithOrg struct {
    App
    Org
}

func main() {
    data := []byte(`{ "id": "123", "name": "My Awesome Org" }`)
    var b AppWithOrg
    json.Unmarshal(data, &amp;b)
    fmt.Printf("%#v\n\n", b)

    a := AppWithOrg{
        App: App{ Id: "321" },
        Org: Org{ Name: "My Awesome Org"},
    }
    data, _ = json.Marshal(a)
    fmt.Println(string(data))
}

// main.AppWithOrg{App:main.App{Id:"123"}, Org:main.Org{Name:"My Awesome Org"}}
// {"id":"321","name":"My Awesome Org"}
</code></pre>

<h1>Stream JSON</h1>

<p>Golang 提供 <code>Decoder</code> 和 <code>Encoder</code> 對 stream JSON 進行處理，常見 request 中的 Body、文件等</p>

<pre><code class="go">package main

import (
    "encoding/json"
    "fmt"
    "io"
    "log"
    "strings"
)

func main() {
    const jsonStream = `
    {"Name": "Ed", "Text": "Knock knock."}
    {"Name": "Sam", "Text": "Who's there?"}
    {"Name": "Ed", "Text": "Go fmt."}
    {"Name": "Sam", "Text": "Go fmt who?"}
    {"Name": "Ed", "Text": "Go fmt yourself!"}
`
    type Message struct {
        Name, Text string
    }
    dec := json.NewDecoder(strings.NewReader(jsonStream))
    for {
        var m Message
        if err := dec.Decode(&amp;m); err == io.EOF {
            break
        } else if err != nil {
            log.Fatal(err)
        }
        fmt.Printf("%s: %s\n", m.Name, m.Text)
    }
}

// Ed: Knock knock.
// Sam: Who's there?
// Ed: Go fmt.
// Sam: Go fmt who?
// Ed: Go fmt yourself!
</code></pre>

<p>參考文件</p>

<ul>
<li><a href="https://golang.org/pkg/encoding/json/#Marshal">json</a></li>
<li><a href="https://sanyuesha.com/2018/05/07/go-json/">理解 Go 中的 JSON</a></li>
<li><a href="https://blog.golang.org/json-and-go">JSON and Go</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Golang - Maps in Action]]></title>
    <link href="http://mgleon08.github.com/blog/2019/02/08/golang-maps-in-action/"/>
    <updated>2019-02-08T10:55:15+08:00</updated>
    <id>http://mgleon08.github.com/blog/2019/02/08/golang-maps-in-action</id>
    <content type="html"><![CDATA[<!-- more -->


<h1>Introduction</h1>

<p> <code>Hash Table</code> 是 Computer Science 中最有用的資料結構，提供了快速尋找，新增，刪除，Golang 透過 <code>map</code> type 來實踐。</p>

<h1>Declaration and initialization</h1>

<pre><code class="go">map[KeyType]ValueType
</code></pre>

<ul>
<li>KeyType 是 type 可以是任意一個可比較的類型</li>
<li>ValueType 也是可以任意的類型</li>
<li>包括 map type 也可以</li>
</ul>


<p>下面的變數 <code>m</code> 是一個 <code>string keys</code> to <code>int values</code> 的 map</p>

<pre><code class="go">var m map[string]int
</code></pre>

<p>Map 的類型是 <code>reference types</code>, 像是 <code>pointers</code> or <code>slices</code>，因此上面 <code>m</code> 的 value 是 nil</p>

<p>當讀取時 <code>nil map</code> 行為類似空的 map，若嘗試寫入 <code>nil map</code> 則會造成 <code>runtime panic</code></p>

<p>因此如果要初始化一個 map 可以用 <code>make</code> function</p>

<pre><code class="go">m = make(map[string]int)
</code></pre>

<p><code>make</code> function 會分配並且初始化一個 <code>hash map data structure</code> 並返回指向它(<code>make</code>)的 map value</p>

<h1>Working with maps</h1>

<p>Set key <code>route</code> to <code>66</code></p>

<pre><code class="go">m["route"] = 66
</code></pre>

<p>Assign <code>m["route"]</code> to variable <code>66</code></p>

<pre><code class="go">i := m["route"]
</code></pre>

<p>value 是 <code>int</code>，因此如果 key 不存在，則會回傳 <code>0</code>，string 則是回傳空字串</p>

<blockquote><p>前提是要用 make 來建立，否則會 panic</p></blockquote>

<pre><code class="go">j := m["root"]
// j == 0
</code></pre>

<p>回傳 map 的 item 長度</p>

<pre><code class="go">n := len(m)
</code></pre>

<p><code>delete</code> function 根據 key 去做刪除，刪除不會回傳任何東西，如果 key 是不存在則不會做任何事</p>

<pre><code class="go">delete(m, "route")
</code></pre>

<p>map 也可以用兩個變數來取</p>

<ul>
<li>第一個變數 <code>i</code> 是指 <code>m["route"]</code> 裡的值，如果沒有 <code>route</code> 就回傳 <code>0</code></li>
<li>第二個變數 <code>ok</code> 則是用來判斷這個 key 存不存在，true 為存在，反之不存在</li>
</ul>


<pre><code class="go">i, ok := m["route"]
</code></pre>

<p>如果只是要判斷存不存在，並沒有要使用到 value 可以給一個 <code>_</code></p>

<pre><code class="go">_, ok := m["route"]
</code></pre>

<p>要取出 map 的 key &amp; value 可以用 range</p>

<pre><code class="go">for key, value := range m {
    fmt.Println("Key:", key, "Value:", value)
}
</code></pre>

<p>初始化並給值</p>

<pre><code class="go">commits := map[string]int{
    "rsc": 3711,
    "r":   2138,
    "gri": 1908,
    "adg": 912,
}
</code></pre>

<p>初始化並給空的值，效果跟用 <code>make</code> 一樣</p>

<pre><code class="go">m = map[string]int{}
</code></pre>

<h1>Exploiting zero values</h1>

<p>在 map 上利用 0(bool) 值</p>

<h3>map 利用 bool 來作為一種數據結構的檢測，就不需要多一個變數來處理</h3>

<pre><code class="go">package main

import (
    "fmt"
)

func main() {
    // 建立一個 Node 的 struct
    type Node struct {
        Next  *Node
        Value interface{}
    }

    second := &amp;Node{
        Next:  nil,
        Value: 2,
    }

    first := &amp;Node{
        Next:  second,
        Value: 1,
    }
    // 故意讓 first 重複，形成迴圈
    second.Next = first
    visited := make(map[*Node]bool)
    for n := first; n != nil; n = n.Next {
        // 如果遇到一個已經變成 true 代表重複了，就 break
        if visited[n] {
            fmt.Println("cycle detected")
            break
        }
        // 只要有遍歷到就將 value 改成 true
        visited[n] = true
        fmt.Println(n.Value)
    }

}
</code></pre>

<h3>map of slices</h3>

<p>不需要 check key 存不存在，因為 appending 一個 nil 的 slice, 會自動分配新的 slice</p>

<pre><code class="go">package main

import (
    "fmt"
)

func main() {
    type Person struct {
        Name  string
        Likes []string
    }

    var people []*Person
    people = append(people, &amp;Person{"Leon", []string{"cheese", "bacon"}})
    // 也可以 people := []*Person{&amp;Person{"Leon", []string{"cheese", "bacon"}}}

    likes := make(map[string][]*Person)

    // 取出所有 people
    for _, p := range people {
        // 取出每個 person 喜歡的東西
        for _, l := range p.Likes {
            // 列出喜歡這個東西的人
            likes[l] = append(likes[l], p)
        }
    }
    // 列出喜歡起司的人
    for _, p := range likes["cheese"] {
        fmt.Println(p.Name, "likes cheese.")
    }

    // 列出喜歡培根的人數
    fmt.Println(len(likes["bacon"]), "people like bacon.")
}
</code></pre>

<p>由於 range 和 len 都將 nil slice 視為零長度的 slice，所以沒有 data 也不會有問題</p>

<pre><code class="go">package main

import "fmt"

type ListNode struct {
    Val  int
    Next *ListNode
}

func main() {
    mapp := make(map[string]ListNode)
    mapp["a"] = ListNode{Val: 1}
    mapp["b"] = ListNode{Val: 2}
    mapp["a"].Next = mapp["b"]
    fmt.Println(mapp["a"].Val)
}
</code></pre>

<h1>Key types</h1>

<p>先前提到 key 可以是任何可以比較的類型(<code>boolean</code>, <code>numeric</code>, <code>string</code>, <code>pointer</code>, <code>channel</code>, and <code>interface types</code>, and <code>structs</code> or <code>arrays</code>)</p>

<p>注意到這列表上不包括(<code>slices</code>, <code>maps</code>, and <code>functions</code>) 這些類型不能做比較，所以也不能當作 map 的 key</p>

<p>另外 struct key 是比較特別的，因為 struct 的 data 是多維度的面相(可以描述一個 data 的結構)</p>

<p>舉例來說下面是一個 map 包著一個 map，用於統計國家/地區的網頁造訪次數</p>

<pre><code class="go">// 外面 map 的 key 是網頁的路徑 path，裡面的 map 的 key 則是 國家的代碼
hits := make(map[string]map[string]int)
</code></pre>

<p>澳洲(Australian) 的 documentation page 點擊次數</p>

<pre><code class="go">n := hits["/doc/"]["au"]
</code></pre>

<p>但這種方法，再新增新的 data 時，會不太好處理，因為每次給外部 map key 時，就必須再檢查裡面的 map 是否存在，不存在在建立</p>

<pre><code class="go">func add(m map[string]map[string]int, path, country string) {
    // 先確認 value 在不在
    mm, ok := m[path]
    // 如果 value 不存在，就建立新的 inner map，每次都要檢查
    if !ok {
        mm = make(map[string]int)
        m[path] = mm
    }
    // 
    mm[country]++
}
add(hits, "/doc/", "au")
</code></pre>

<p>利用 struct 可以減少上面的複雜性</p>

<pre><code class="go">type Key struct {
    Path, Country string
}
hits := make(map[Key]int)
</code></pre>

<p>當越南人(Vietnamese) 造訪頁面，增加(或建立新的) 可以用一行就解決</p>

<pre><code class="go">hits[Key{"/", "vn"}]++
</code></pre>

<p>要看到瑞士(Swiss)有多少人看到 <code>/ref/spec</code> 也很簡單</p>

<pre><code class="go">n := hits[Key{"/ref/spec", "ch"}]
</code></pre>

<h1>Concurrency</h1>

<p><a href="https://golang.org/doc/faq#atomic_maps">Maps are not safe for concurrent use</a></p>

<p>並發訪問map是不安全的，會出現未定義行為</p>

<p>如果希望多併發讀取 map，必須提供某種同步機制，可以用 <a href="https://golang.org/pkg/sync/#RWMutex">sync.RWMutex</a> 讀寫鎖，確保同步機制(synchronization mechanism)</p>

<p>但是透過讀寫鎖控制 map 的並發訪問時，會導致一定的性能問題，不過能保證程序的安全運行。</p>

<pre><code class="go">package main

import (
    "fmt"
    "sync"
)

func main() {
    var counter = struct {
        sync.RWMutex
        m map[string]int
    }{m: make(map[string]int)}

    // To read from the counter, take the read lock:
    counter.RLock()
    n := counter.m["some_key"]
    counter.RUnlock()
    fmt.Println("some_key:", n)

    // To write to the counter, take the write lock:
    counter.Lock()
    counter.m["some_key"]++
    counter.Unlock()
    fmt.Println("some_key:", counter.m["some_key"])
}
</code></pre>

<ul>
<li><a href="https://colobu.com/2017/07/11/dive-into-sync-Map/">Go 1.9 sync.Map揭秘</a></li>
<li><a href="https://www.jianshu.com/p/10a998089486">go語言坑之並發訪問map</a></li>
</ul>


<h1>Iteration order</h1>

<p>用 <code>range</code> 迭代 map 時，並沒有指定每次的順序一樣，也沒有保證下一次的順序會跟上一次的順序一樣，每次都是隨機的</p>

<p>如果希望能夠每次迭代的順序都一樣的話，必須先將 key 單獨分開來做排序，在迭代排序好的 key mapping 回 map</p>

<pre><code class="go">package main

import (
    "fmt"
    "sort"
)

func main() {

    m := map[int]string{
        1: "A",
        2: "B",
        3: "C",
    }
    // 先將 key 取出來排序
    var keys []int
    for k := range m {
        keys = append(keys, k)
    }
    sort.Ints(keys)
    // 改成以下方法，就會倒過來
    // sort.Sort(sort.Reverse(sort.IntSlice(keys)))

    // 迭代排序好的 slice，並指定 map 的 key
    for _, k := range keys {
        fmt.Println("Key:", k, "Value:", m[k])
    }
}
</code></pre>

<h1>cannot assign to struct field XXX in map</h1>

<p>當 struct 作為 map 裡面的值時，不能透過 map[key].xx = &ldquo;xx&rdquo; 這種賦值，會出現 <code>cannot assign to struct field XXX in map</code> 不予許修改 map 裡的值</p>

<pre><code class="go">package main

import (
    "fmt"
)

type test struct {
    name string
}

func main() {
    a := test{"hello"}
    mapp := make(map[string]test)
    mapp["hey"] = a

    // 因為 map 的 value 是不可尋址的，因此會報錯
    // cannot assign to struct field mapp["test"].name in map
    mapp["hey"].name = "hi"

    // if v, ok := mapp["hey"]; ok {
    // 雖然這樣不會有 error，但實際上 v 是 copy 的值，因此也不會改到原本的 value，所以還是 hello
    //  v.name = "hi"
    // }

    fmt.Println(mapp["hey"].name)

}
</code></pre>

<h3>原因:</h3>

<p>map 的 value 是不可尋址的(<a href="https://golang.org/ref/spec#Address_operators">addressable</a>)，因為 map 中的值會在記憶體中行動，舊的指針地址在 map 改變時會變得無效。</p>

<p>另外 map 是會自動擴容，因此原來存值是 A 地址，擴容後 A 地址就不是原來的值了，因此如果需要改值，必須改用 <code>make(map[string]*test)</code></p>

<p>參考文件</p>

<ul>
<li><a href="https://blog.golang.org/go-maps-in-action">Go maps in action</a></li>
<li><a href="https://stackoverflow.com/questions/32751537/why-do-i-get-a-cannot-assign-error-when-setting-value-to-a-struct-as-a-value-i">Why do I get a “cannot assign” error when setting value to a struct as a value in a map? [duplicate]</a></li>
<li><a href="https://gocn.vip/question/1714">問一個問題。為啥結構體作為map的值，不能透過map[key].成員屬性 = &ldquo;Xxx&rdquo; 這種賦值</a></li>
<li><a href="https://studygolang.com/articles/12714">Golang面試題解析（四）</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
