<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Golang | Leon's Blogging]]></title>
  <link href="https://mgleon08.github.io/blog/categories/golang/atom.xml" rel="self"/>
  <link href="https://mgleon08.github.io/"/>
  <updated>2019-07-10T19:07:27+08:00</updated>
  <id>https://mgleon08.github.io/</id>
  <author>
    <name><![CDATA[LeonJi]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Golang - GraphQL With Gqlgen]]></title>
    <link href="https://mgleon08.github.io/blog/2019/06/04/golang-graphql-with-gqlgen/"/>
    <updated>2019-06-04T18:50:50+08:00</updated>
    <id>https://mgleon08.github.io/blog/2019/06/04/golang-graphql-with-gqlgen</id>
    <content type="html"><![CDATA[<!-- more -->


<h2>Setup Project</h2>

<p>使用 Go Module  記得先執行 <code>export GO111MODULE=on</code></p>

<pre><code class="go">mkdir gqlgen-todos
cd gqlgen-todos
go mod init github.com/[username]/gqlgen-todos
</code></pre>

<h2>Define the schema</h2>

<p>新增 <code>schema.graphql</code> 定義 <a href="https://graphql.org/learn/queries/">graphql 結構</a></p>

<pre><code class="go">type Todo {
  id: ID!
  text: String!
  done: Boolean!
  user: User!
}

type User {
  id: ID!
  name: String!
}

type Query {
  todos: [Todo!]!
}

input NewTodo {
  text: String!
  userId: String!
}

type Mutation {
  createTodo(input: NewTodo!): Todo!
}
</code></pre>

<h2>Create the project skeleton</h2>

<p>透過 <code>gglgen</code> 建立 graphql 的專案初始化</p>

<pre><code class="go">go run github.com/99designs/gqlgen init
</code></pre>

<ul>
<li><code>gqlgen.yml</code> — The gqlgen config file, knobs for controlling the generated code.</li>
<li><code>generated.go</code> — The GraphQL execution runtime, the bulk of the generated code.</li>
<li><code>models_gen.go</code> — Generated models required to build the graph. Often you will override these with your own models. Still very useful for input types.</li>
<li><code>resolver.go</code> — This is where your application code lives. generated.go will call into this to get the data the user has requested.</li>
<li><code>server/server.go</code> — This is a minimal entry point that sets up an http.Handler to the generated GraphQL server.</li>
</ul>


<h2>Create the database models</h2>

<p>自動生成的 Todo model 不是正確的，因為 Todo 裡面還嵌入了 User，我們希望是在使用者要求時才給予，因此要另外建立 <code>todo.go</code></p>

<pre><code class="go">// todo.go
package gqlgen_todos

type Todo struct {
    ID     string
    Text   string
    Done   bool
    UserID string
}
</code></pre>

<p>將新的 struct 路徑加到 <code>gqlgen.yml</code></p>

<pre><code class="go">// Todo 對應到 todo.go 裡的 struct name
models:
  Todo:
    model: github.com/[username]/gqlgen-todos.Todo
</code></pre>

<p>重新生成檔案</p>

<pre><code class="go">go run github.com/99designs/gqlgen
</code></pre>

<h2>Implement the resolvers</h2>

<p>在 <code>generated.go</code> 產生了很多個 resolvers interface，接著就要實作這些，但 <code>resolver.go</code> 這個檔案，再新增新的 method 時，要重新再產生一份</p>

<pre><code class="go">rm resolver.go
go run github.com/99designs/gqlgen
</code></pre>

<p>實作 <code>resolver.go</code></p>

<pre><code class="go">package gqlgen_todos

import (
    context "context"
    "fmt"
    "math/rand"
)

type Resolver struct {
    todos []Todo
}

func (r *Resolver) Mutation() MutationResolver {
    return &amp;mutationResolver{r}
}
func (r *Resolver) Query() QueryResolver {
    return &amp;queryResolver{r}
}
func (r *Resolver) Todo() TodoResolver {
    return &amp;todoResolver{r}
}

type mutationResolver struct{ *Resolver }

func (r *mutationResolver) CreateTodo(ctx context.Context, input NewTodo) (*Todo, error) {
    todo := &amp;Todo{
        Text:   input.Text,
        ID:     fmt.Sprintf("T%d", rand.Int()),
        UserID: input.UserID,
    }
    r.todos = append(r.todos, *todo)
    return todo, nil
}

type queryResolver struct{ *Resolver }

func (r *queryResolver) Todos(ctx context.Context) ([]Todo, error) {
    return r.todos, nil
}

type todoResolver struct{ *Resolver }

func (r *todoResolver) User(ctx context.Context, obj *Todo) (*User, error) {
    return &amp;User{ID: obj.UserID, Name: "user " + obj.UserID}, nil
}
</code></pre>

<h1>Query</h1>

<pre><code class="go">// open http://localhost:8080
go run server/server.go
</code></pre>

<pre><code class="go">// create
mutation createTodo {
  createTodo(input:{text:"todo", userId:"1"}) {
    user {
      id
    }
    text
    done
  }
}

// show
query findTodos {
    todos {
      text
      done
      user {
        name
      }
    }
}
</code></pre>

<h2>Finishing touches</h2>

<p>At the top of our resolver.go add the following line:</p>

<pre><code class="go">//go:generate go run github.com/99designs/gqlgen
</code></pre>

<p>This magic comment tells go generate what command to run when we want to regenerate our code</p>

<h2>Example</h2>

<ul>
<li><a href="https://github.com/mgleon08/go-packages/tree/master/020.gqlgen-todos">gqlgen-todos</a></li>
</ul>


<h1>Reference</h1>

<ul>
<li><a href="https://gqlgen.com/getting-started/">gqlgen getting-started</a></li>
<li><a href="https://graphql.org/">Graphql</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Golang - Simple RESTful]]></title>
    <link href="https://mgleon08.github.io/blog/2019/04/11/golang-simple-restful/"/>
    <updated>2019-04-11T16:27:10+08:00</updated>
    <id>https://mgleon08.github.io/blog/2019/04/11/golang-simple-restful</id>
    <content type="html"><![CDATA[<!-- more -->


<p>Practice RESTful with golang</p>

<pre><code class="go">GetUsers     GET     /users
GetUser      GET     /users/{id}
CreateUser   POST    /users
UpdateUser   UPDATE  /users/{id}
DeleteUser   DELETE  /users/{id}
</code></pre>

<p>Use <a href="https://github.com/gorilla/mux">gorilla/mux</a> package</p>

<pre><code class="go">package main

import (
    "encoding/json"
    "fmt"
    "log"
    "net/http"
    "strconv"

    "github.com/gorilla/mux"
)

type User struct {
    ID        int    `json:"id,omitempty"`
    Firstname string `json:"firstname,omitempty"`
    Lastname  string `json:"lastname,omitempty"`
    Info      `json:"info,omitempty"`
}
type Info struct {
    City  string `json:"city,omitempty"`
    Phone int    `json:"phone,omitempty"`
}

var users []User

func GetUsers(w http.ResponseWriter, r *http.Request) {
    json.NewEncoder(w).Encode(users)
}

func GetUser(w http.ResponseWriter, r *http.Request) {
    id := convertParams(r)
    for _, u := range users {
        if u.ID == id {
            json.NewEncoder(w).Encode(u)
            return
        }
    }
    json.NewEncoder(w).Encode("User not found")
}

func CreateUser(w http.ResponseWriter, r *http.Request) {
    var user User
    _ = json.NewDecoder(r.Body).Decode(&amp;user)
    users = append(users, user)
    json.NewEncoder(w).Encode(user)
}

func UpdateUser(w http.ResponseWriter, r *http.Request) {
    var user User
    id := convertParams(r)
    _ = json.NewDecoder(r.Body).Decode(&amp;user)
    for i, u := range users {
        if u.ID == id {
            users[i] = user
            json.NewEncoder(w).Encode(user)
            break
        }
    }
}

func DeleteUser(w http.ResponseWriter, r *http.Request) {
    id := convertParams(r)
    for i, u := range users {
        if u.ID == id {
            copy(users[i:], users[i+1:])
            users = users[:len(users)-1]
            break
        }
    }
    json.NewEncoder(w).Encode(users)
}

func convertParams(r *http.Request) int {
    params := mux.Vars(r)
    id, err := strconv.Atoi(params["id"])
    if err != nil {
        log.Fatalf("err: %v", err)
    }
    return id
}

func main() {
    router := mux.NewRouter()
    user1 := User{ID: 1, Firstname: "hello", Lastname: "World", Info: Info{City: "Taipei", Phone: 123}}
    user2 := User{ID: 2, Firstname: "hello", Lastname: "World", Info: Info{City: "Taipei", Phone: 456}}
    users = append(users, user1, user2)
    router.HandleFunc("/users", GetUsers).Methods("GET")
    router.HandleFunc("/users/{id}", GetUser).Methods("GET")
    router.HandleFunc("/users", CreateUser).Methods("POST")
    router.HandleFunc("/users/{id}", UpdateUser).Methods("PUT")
    router.HandleFunc("/users/{id}", DeleteUser).Methods("DELETE")
    fmt.Println("Starting server on port 3000...")
    log.Fatal(http.ListenAndServe(":3000", router))
}
</code></pre>

<p>params</p>

<pre><code class="go">{
  "id": 3,
  "firstname": "hello",
  "lastname": "World",
  "info": {
    "city": "Taipei",
    "phone": 123
  }
}
</code></pre>

<p>run</p>

<pre><code class="go">go run main.go
// http://localhost:3000/users
</code></pre>

<h1>Code</h1>

<ul>
<li><a href="https://github.com/mgleon08/go-packages/blob/master/018.simple_restful/main.go">simple_restful</a></li>
</ul>


<h1>With mongodb</h1>

<ul>
<li><a href="https://github.com/mgleon08/go-packages/tree/master/019.restful_mongodb">restful_mongodb</a></li>
</ul>


<p>Reference</p>

<ul>
<li><a href="https://medium.com/@petrousov/how-to-build-a-restful-api-in-go-for-phonebook-app-d55f7234a10">How to build a RESTful API in Go for phonebook app</a></li>
<li><a href="https://medium.com/@petrousov/implementing-crud-operations-with-go-and-mongodb-cf622f2379c4">Implementing CRUD operations with Go and MongoDB</a></li>
<li><a href="https://github.com/gorilla/mux">gorilla/mux</a></li>
<li><a href="https://yourbasic.org/golang/delete-element-slice/">2 ways to delete an element from a slice</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Golang - MongoDB]]></title>
    <link href="https://mgleon08.github.io/blog/2019/04/10/golang-mongodb/"/>
    <updated>2019-04-10T21:30:30+08:00</updated>
    <id>https://mgleon08.github.io/blog/2019/04/10/golang-mongodb</id>
    <content type="html"><![CDATA[<!-- more -->


<h1>Install the MongoDB Go Driver</h1>

<pre><code class="go">go go get github.com/mongodb/mongo-go-driver
</code></pre>

<p>或使用 go module</p>

<pre><code class="go">go mode init &lt;current package name&gt;
</code></pre>

<h1>Connect to MongoDB using the Go Driver</h1>

<pre><code class="go">package main

import (
    "context"
    "fmt"
    "log"

    "github.com/mongodb/mongo-go-driver/mongo"
    "go.mongodb.org/mongo-driver/mongo/options"
)

func main() {
    client, err := mongo.Connect(context.Background(), options.Client().ApplyURI("mongodb://localhost:27017"))

    if err != nil {
        log.Fatal(err)
    }

    // Check the connection
    err = client.Ping(context.Background(), nil)

    if err != nil {
        log.Fatal(err)
    }

    fmt.Println("Connected to MongoDB!")

    // handle for the trainers collection in the test database
    // collection := client.Database("test").Collection("trainers")

    // Close the connection
    err = client.Disconnect(context.TODO())

    if err != nil {
        log.Fatal(err)
    }
    fmt.Println("Connection to MongoDB closed.")
}
</code></pre>

<ul>
<li><code>mongo.Connect</code> Connect</li>
<li><code>client.Ping</code> Check the connection</li>
<li><code>client.Disconnect</code> Close the connection</li>
</ul>


<h1>BSON (Binary Serialized Document Format, Binary-encoded JSON)</h1>

<ul>
<li>一種二進制形式的存儲格式，採用了類似於 C 語言結構體的名稱</li>
<li>對表示方法支援內嵌的文件物件和陣列物件</li>
<li>具有輕量性、可遍歷性、高效性的特點，可以有效描述非結構化數據和結構化數據</li>
<li>schema-less的存儲形式</li>
<li>優點是靈活性高，但它的缺點是空間利用率不是很理想</li>
<li>不像一般 json 用簡單的 string 和 number，而是可以給予 type (int, long, date, floating point, and decimal128)，可以更方便的去做比較排許等等的</li>
</ul>


<h3>在 Go 中提供了兩種 BSON 的資料格式 <code>D types</code> the <code>Raw types</code></h3>

<p><code>D type</code></p>

<blockquote><p>The D family of types is used to concisely build BSON objects using native Go types. This can be particularly useful for constructing commands passed to MongoDB. The D family consists of four types:</p></blockquote>

<ul>
<li><code>D</code>: A BSON document. This type should be used in situations where order matters, such as MongoDB commands.</li>
<li><code>M</code>: An unordered map. It is the same as D, except it does not preserve order.</li>
<li><code>A</code>: A BSON array.</li>
<li><code>E</code>: A single element inside a D.</li>
</ul>


<p>Example</p>

<pre><code class="go">// D type filter to find where the name field matches either Alice or Bob 
bson.D\{\{
    "name", 
    bson.D\{\{
        "$in", 
        bson.A{"Alice", "Bob"}
    }}
}}
</code></pre>

<p><code>Raw</code></p>

<blockquote><p>The Raw family of types is used for validating a slice of bytes. You can also retrieve single elements from Raw types using a <a href="https://godoc.org/go.mongodb.org/mongo-driver/bson#Raw.Lookup">Lookup</a>. This is useful if you don&rsquo;t want the overhead of having to unmarshall the BSON into another type. This tutorial will just use the D family of types.</p></blockquote>

<h1>CRUD Operations</h1>

<pre><code class="go">type Trainer struct {
    Name string
    Age  int
    City string
}
</code></pre>

<h3>C - Insert documents</h3>

<pre><code class="go">ash := Trainer{"Ash", 10, "Pallet Town"}
misty := Trainer{"Misty", 10, "Cerulean City"}
brock := Trainer{"Brock", 15, "Pewter City"}

// insert one
insertResult, err := collection.InsertOne(context.TODO(), ash)
if err != nil {
  log.Fatal(err)
}
fmt.Println("Inserted a single document: ", insertResult.InsertedID)

// insert many
trainers := []interface{}{misty, brock}
insertManyResult, err := collection.InsertMany(context.TODO(), trainers)
if err != nil {
  log.Fatal(err)
}
fmt.Println("Inserted multiple documents: ", insertManyResult.InsertedIDs)
</code></pre>

<h3>U - Update documents</h3>

<p>需要透過 <code>bson.D</code> types 去找到 match 的 data 再做更新</p>

<ul>
<li><a href="https://docs.mongodb.com/manual/reference/operator/update-field/">Field Update Operators</a></li>
</ul>


<pre><code class="go">// 找出 name ＝ "Ash"
filter := bson.Dname

// 將 age - 1
update := bson.D{
    {"$inc", bson.D{
        {"age", 1},
    }},
}

updateResult, err := collection.UpdateOne(context.TODO(), filter, update)
if err != nil {
    log.Fatal(err)
}

fmt.Printf("Matched %v documents and updated %v documents.\n", updateResult.MatchedCount, updateResult.ModifiedCount)
</code></pre>

<ul>
<li><code>$inc</code> - Increments the value of the field by the specified amount.</li>
<li><code>updateResult.MatchedCount</code> - The number of documents that matched the filter.</li>
<li><code>updateResult.ModifiedCount</code> - The number of documents that were modified.</li>
</ul>


<h3>R - Find documents</h3>

<p><code>Find a document</code> use <code>collection.FindOne()</code></p>

<blockquote><p>To find a document, you will need a filter document as well as a pointer to a value into which the result can be decoded</p></blockquote>

<pre><code class="go">// create a value into which the result can be decoded
var result Trainer

// 取出的值必須要 Decode
err = collection.FindOne(context.TODO(), filter).Decode(&amp;result)
if err != nil {
    log.Fatal(err)
}

fmt.Printf("Found a single document: %+v\n", result)
</code></pre>

<p><code>Find multiple documents</code> use <code>collection.Find()</code></p>

<blockquote><p>This method returns a Cursor. A Cursor provides a stream of documents through which you can iterate and decode one at a time. Once a Cursor has been exhausted, you should close the Cursor.</p>

<p>Here you&rsquo;ll also set some options on the operation using the options package. Specifically, you&rsquo;ll set a limit so only 2 documents are returned.</p></blockquote>

<pre><code class="go">// Pass these options to the Find method
findOptions := options.Find()
findOptions.SetLimit(2)

// Here's an array in which you can store the decoded documents
var results []*Trainer

// Passing nil as the filter matches all documents in the collection
// 範例原本寫 nil 但是有問題所以改成 bson.D{}
cur, err := collection.Find(context.TODO(), bson.D{}, findOptions)
if err != nil {
    log.Fatal(err)
}

// Finding multiple documents returns a cursor
// Iterating through the cursor allows us to decode documents one at a time
for cur.Next(context.TODO()) {

    // create a value into which the single document can be decoded
    var elem Trainer
    err := cur.Decode(&amp;elem)
    if err != nil {
        log.Fatal(err)
    }
    results = append(results, &amp;elem)
}

if err := cur.Err(); err != nil {
    log.Fatal(err)
}

// Close the cursor once finished
cur.Close(context.TODO())

fmt.Printf("Found multiple documents (array of pointers): %+v\n", results)

for index, result := range results {
    fmt.Printf("%d: %+v \n", index, result)
}
</code></pre>

<h3>D - Delete Documents</h3>

<blockquote><p>delete documents using <code>collection.DeleteOne()</code> or <code>collection.DeleteMany()</code>.</p>

<p>Here you pass nil as the filter argument, which will match all documents in the collection. You could also use <a href="https://godoc.org/github.com/mongodb/mongo-go-driver/mongo#Collection.Drop">collection.Drop()</a> to delete an entire collection.</p></blockquote>

<pre><code class="go">// DeleteOne
deleteOneResult, err := collection.DeleteOne(context.TODO(), bson.M{})
if err != nil {
  log.Fatal(err)
}
fmt.Printf("Deleted %v documents in the trainers collection\n", deleteOneResult.DeletedCount)

// DeleteMany
deleteResult, err := collection.DeleteMany(context.TODO(), bson.M{})
// DELETA name = Misty &amp;&amp; age &gt; 10
// deleteResult, err := collection.DeleteMany(context.TODO(), bson.M{"name": "Misty", "age": bson.M{"$gte": 10}})
// deleteResult, err := collection.DeleteMany(context.TODO(), bson.D\{\{"name", "Misty"}, {"age", bson.M{"$gte": 10}}})
if err != nil {
  log.Fatal(err)
}
fmt.Printf("Deleted %v documents in the trainers collection\n", deleteResult.DeletedCount)
</code></pre>

<h1>Example</h1>

<ul>
<li><a href="https://github.com/mgleon08/go-packages/tree/master/017.mongodb">016.mongodb</a></li>
</ul>


<p>Reference</p>

<ul>
<li><a href="https://github.com/mongodb/mongo-go-driver/tree/master/examples/documentation_examples">documentation_examples</a></li>
<li><a href="https://godoc.org/go.mongodb.org/mongo-driver">godoc mongo-driver</a></li>
<li><a href="https://docs.mongodb.com/manual/reference/operator/">BSON Operators</a></li>
<li><a href="http://bsonspec.org/">BSON</a></li>
<li><a href="https://blog.csdn.net/m0_38110132/article/details/77716792">BSON的介紹及BSON與JSON的區別</a></li>
<li><a href="https://www.mongodb.com/blog/post/mongodb-go-driver-tutorial">MongoDB Go Driver Tutorial</a></li>
<li><a href="https://www.jianshu.com/p/0344a21e8040?utm_campaign=maleskine&amp;utm_content=note&amp;utm_medium=seo_notes&amp;utm_source=recommendation">mongodb官方的golang驅動基礎使用課程分享</a></li>
<li><a href="https://zh.shellman.me/articles/mongo-go-driver-demo/">MongoDB官方推出的Go驅動庫“mongo-go-driver”快速課程</a></li>
<li><a href="https://blog.gtwang.org/programming/getting-started-with-mongodb-shell-1/">MongoDB 基礎入門教學：MongoDB Shell 篇</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Golang - Context]]></title>
    <link href="https://mgleon08.github.io/blog/2019/04/10/golang-context/"/>
    <updated>2019-04-10T21:30:20+08:00</updated>
    <id>https://mgleon08.github.io/blog/2019/04/10/golang-context</id>
    <content type="html"><![CDATA[<!-- more -->


<p><code>context</code> 是控制並發的一個 package，之前在 <a href="https://mgleon08.github.io/blog/2018/05/17/golang-goroutine-channel-worker-pool-select-mutex/#worker_pool">Worker Pool</a> 也有提到過另一個 <code>WaitGroup</code>，那為什麼需要兩種，來了解一下</p>

<h1>WaitGroup</h1>

<p>當所有的 <code>goroutine</code> 都完成後，才算完成</p>

<h3>實際場景</h3>

<p>有個監控程式跑很多 <code>gorountine</code>，當要停止時，就必須通知每個 <code>gorountine</code> 並等待所有都完成，才算完成，否則會造成記憶體洩漏</p>

<pre><code class="go">package main

import (
    "fmt"
    "sync"
    "time"
)

func process(i int, wg *sync.WaitGroup) {
    fmt.Println("監控開始 ", i)
    time.Sleep(2 * time.Second)
    fmt.Printf("監控 %d 結束\n", i)
    wg.Done() // 執行完一次就 -1
}

func main() {
    no := 2
    var wg sync.WaitGroup
    for i := 0; i &lt; no; i++ {
        wg.Add(1)          // 每次執行都 + 1
        go process(i, &amp;wg) // wg 一定要用 pointer，否則每個 goroutine 都會有各自的 WaitGroup
    }
    wg.Wait() // 會 wait 到 0 才會繼續下一步
    fmt.Println("所有監控完成")
}
</code></pre>

<p>大部分的 <code>gorountine</code> 啟動後，就會一直跑，大部分情況是等待它自己結束，如果是不會結束的 <code>gorountine</code>，就會一直跑下去，比較笨的方式就是，用一個變數去判斷是否要結束，但這樣就必須一直去檢查這個變數</p>

<p>因此可以改用 <code>chan + select</code> 來通知</p>

<h1>chan + select</h1>

<p>這方式很好的解決上述的問題，並且可以透過給予 <code>chan</code> 值來決定是否要停止，但還是有其他問題</p>

<ul>
<li>如果有很多 <code>goroutine</code> 都需要控制結束怎麼辦?</li>
<li><code>goroutine</code> 又衍生了其它更多的goroutine怎麼?</li>
</ul>


<p>即使定義很多 <code>chan</code> 也很難解決這個問題，因為 <code>goroutine</code> 的關係鏈就導致了這種場景非常複雜，因此就有另一個方式 <code>context</code></p>

<pre><code class="go">package main

import (
    "fmt"
    "time"
)

func process(stop chan bool) {
    for {
        select {
        case &lt;-stop:
            fmt.Println("監控退出，停止了...")
            return
        default:
            fmt.Println("goroutine 監控中...")
            time.Sleep(2 * time.Second)
        }
    }
}

func main() {
    stop := make(chan bool)
    go process(stop)
    time.Sleep(5 * time.Second)
    stop &lt;- true
    fmt.Println("所有監控完成")
}
</code></pre>

<h1>context</h1>

<ul>
<li><a href="https://golang.org/pkg/context/">context</a></li>
</ul>


<p>上面提到的情境是多層級的 <code>goroutine</code>，因此要控制就必須跟蹤 <code>groutine</code></p>

<p>因此 golang 提供了 <code>context</code> 來控制，也就是 <code>groutine</code> 的上下文</p>

<h3>Context 使用原則</h3>

<ul>
<li>不要把 Context 放在結構體中，要以參數的方式傳遞</li>
<li>以 Context 作為參數的函式方法，應該把 Context 作為第一個參數，放在第一位。</li>
<li>給一個函式方法傳遞 Context 的時候，不要傳遞 nil，如果不知道傳遞什麼，就使用 <code>context.TODO</code></li>
<li>Context 的 Value 相關方法應該傳遞必須的數據，不要什麼數據都使用這個傳遞</li>
<li>Context 是執行緒安全的，可以放心的在多個 goroutine 中傳遞</li>
</ul>


<pre><code class="go">package main

import (
    "context"
    "fmt"
    "time"
)

func process(ctx context.Context) {
    for {
        select {
        case &lt;-ctx.Done():
            fmt.Println("監控退出，停止了...")
            return
        default:
            fmt.Println("goroutine監控中...")
            time.Sleep(2 * time.Second)
        }
    }
}

func main() {
    ctx, cancel := context.WithCancel(context.Background())

    go process(ctx)
    time.Sleep(5 * time.Second)
    fmt.Println("通知監控停止")
    cancel()
    time.Sleep(5 * time.Second)
    fmt.Println("所有監控完成")
}
</code></pre>

<ul>
<li><code>context.Background()</code> 回傳一個非 nil 的空 context，不會被取消也沒有值或時間，就是 context 的根節點</li>
<li><code>context.WithCancel(parent)</code> 建立一個可取消的 <code>子 context</code> 當作參數來追蹤 <code>goroutine</code>，另外一個是 <code>cancle</code> 用於取消這個 <code>子 context</code></li>
<li><code>ctx.Done</code> 判斷是否要結束，透過 <code>cancel()</code> 來取消</li>
</ul>


<p>目前為止似乎跟 <code>chan</code> 沒什麼兩樣?接著試著控制多個 goroutine</p>

<pre><code class="go">package main

import (
    "context"
    "fmt"
    "time"
)

func process(ctx context.Context, n int) {
    for {
        select {
        case &lt;-ctx.Done():
            fmt.Println(n, "監控退出，停止了...")
            return
        default:
            fmt.Printf("goroutine %v 監控中...\n", n)
            time.Sleep(2 * time.Second)
        }
    }
}

func main() {
    ctx, cancel := context.WithCancel(context.Background())
    n := 3
    for i := 0; i &lt; n; i++ {
        go process(ctx, i)
    }

    time.Sleep(5 * time.Second)
    fmt.Println("通知監控停止")
    cancel()
    time.Sleep(5 * time.Second)
    fmt.Println("所有監控完成")
}
</code></pre>

<p>可以看到，上面即使有多個 <code>goroutine</code> 依樣只要一個 <code>cancel()</code> 就全部都取消了</p>

<p>如果是用之前 <code>chan</code>，變成只有一個 <code>true</code> 只能夠取消一個，就結束了，導致剩下的 memory 沒辦法釋放，或是一次放三個 <code>true</code> 去控制，但是當一多起來，就會變得很複雜</p>

<h1>Context interface</h1>

<pre><code class="go">type Context interface {
    Deadline() (deadline time.Time, ok bool)

    Done() &lt;-chan struct{}

    Err() error

    Value(key interface{}) interface{}
}
</code></pre>

<ul>
<li><code>Deadline()</code> 是獲取設定的截止時間的意思

<ul>
<li><code>deadline</code> 截止時間，到了這個時間點，Context 會自動發起取消請求</li>
<li><code>ok</code> 如果是 false，表示沒有設定截止時間，如果需要取消的話，需要呼叫取消函式進行取消</li>
</ul>
</li>
<li><code>Done</code> 返回一個 <code>只讀的 chan</code>，類型為 struct{}

<ul>
<li>如果可讀取，表示 <code>parent context</code> 已發起取消的請求(<code>cancel</code>)，收到信號時就會開始清理操作，然後退出 goroutine，釋放資源</li>
</ul>
</li>
<li><code>Err</code> 返回取消的錯誤原因，因為什麼 Context 被取消</li>
<li><code>Value</code> 獲取該 Context 上繫結的值，是一個鍵值對，所以要透過一個 Key 才可以獲取對應的值，這個值一般是執行緒安全的</li>
</ul>


<h1>Other</h1>

<ul>
<li><a href="https://golang.org/pkg/context/#example_WithCancel">WithCancel</a> 主動取消</li>
<li><a href="https://golang.org/pkg/context/#example_WithDeadline">WithDeadline</a> 截止時間取消</li>
<li><a href="https://golang.org/pkg/context/#example_WithTimeout">WithTimeout</a> 超時取消</li>
<li><a href="https://golang.org/pkg/context/#example_WithValue">WithValue</a> 傳值</li>
<li>也可以不包上面的 With，直接使用 <code>context.Background()</code>，可以看到上面的 With 最後回傳的也是 <code>context Context</code></li>
</ul>


<p>Reference</p>

<ul>
<li><a href="https://golang.org/pkg/context/">context</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/58967892">Go Context</a></li>
<li><a href="https://deepzz.com/post/golang-context-package-notes.html">快速掌握 Golang context 包，簡單示例</a></li>
<li><a href="https://segmentfault.com/a/1190000017394302">Golang Context 是好的設計嗎？</a></li>
<li><a href="https://juejin.im/post/5a6873fef265da3e317e55b6">Golang Context深入理解</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Golang - Testing]]></title>
    <link href="https://mgleon08.github.io/blog/2019/03/28/golang-testing/"/>
    <updated>2019-03-28T18:24:12+08:00</updated>
    <id>https://mgleon08.github.io/blog/2019/03/28/golang-testing</id>
    <content type="html"><![CDATA[<!-- more -->


<h1>Testing</h1>

<ul>
<li>檔案的結尾必須是，<code>測試檔案名稱</code> + <code>_test</code></li>
<li>測試函式必須是 <code>Test</code> 開頭，且必須第一個字母大寫(public)</li>
<li>測試函式 <code>TestXxx()</code> 的參數是 <code>testing.T</code>，我們可以使用該型別來記錄錯誤或者是測試狀態</li>
<li>要使用 <code>testing</code> package</li>
<li>測試案例會按照原始碼中寫的順序依次執行</li>
<li>函式中透過呼叫 <code>testing.T</code> 的 <code>Error</code>, <code>Errorf</code>, <code>FailNow</code>, <code>Fatal</code>, <code>FatalIf</code> 方法，說明測試不透過，呼叫 <code>Log</code> 方法用來記錄測試的資訊。</li>
</ul>


<h3>main.go</h3>

<pre><code class="go">// main.go
package main

import (
    "errors"
    "fmt"
)

func Division(a, b float64) (float64, error) {
    if b == 0 {
        return 0, errors.New("b can not be 0")
    }
    return a / b, nil
}

func main() {
    fmt.Println(Division(60, 2))
}
</code></pre>

<h3>main_test.go</h3>

<pre><code class="go">// main_test.go
package main

import (
    "testing"
)

func Test_division_1(t *testing.T) {
    if i, e := Division(6, 2); i != 3 || e != nil {
        t.Error("失敗")
    } else {
        t.Log("成功")
    }
}

func Test_division_2(t *testing.T) {
    t.Error("失敗")
}

func Test_division_table(t *testing.T) {
    tables := []struct {
        x float64
        y float64
    }{
        {3, 1},
        {6, 2},
        {9, 3},
        {8, 2},
    }

    for _, table := range tables {
        if i, e := Division(table.x, table.y); i != 3 || e != nil {
            t.Error("失敗")
        } else {
            t.Log("成功")
        }
    }
}
</code></pre>

<h3>Run test</h3>

<pre><code class="go">// go test -v -cover

=== RUN   Test_Division_1
--- PASS: Test_Division_1 (0.00s)
    main_test.go:11: 成功
=== RUN   Test_Division_2
--- FAIL: Test_Division_2 (0.00s)
    main_test.go:16: 失敗
=== RUN   Test_Division_table
--- FAIL: Test_Division_table (0.00s)
    main_test.go:34: 成功
    main_test.go:34: 成功
    main_test.go:34: 成功
    main_test.go:32: 失敗
FAIL
coverage: 50.0% of statements
exit status 1
FAIL    github.com/mgleon08/packages/015.test   0.007s
</code></pre>

<h1>Benchmark testing</h1>

<ul>
<li>檔案的結尾必須是，<code>測試檔案名稱</code> + <code>_test</code></li>
<li>測試函式必須是 <code>Benchmark</code> 開頭，且必須第一個字母大寫(public)</li>
<li><code>for</code> 循環內要放置要測試的程式碼</li>
<li><code>b.N</code> 是 go 語言內建提供的循環，根據一秒鐘的時間計算</li>
<li>測試函式 <code>Benchmark_xxx()</code> 的參數是 <code>b *testing.B</code></li>
</ul>


<h3>webbench_test.go</h3>

<pre><code class="go">// webbench_test.go

package main

import (
    "testing"
)

func Benchmark_Division(b *testing.B) {
    for i := 0; i &lt; b.N; i++ { //use b.N for looping
        Division(4, 5)
    }
}

func Benchmark_TimeConsumingFunction(b *testing.B) {
    b.StopTimer() //呼叫該函式停止壓力測試的時間計數

    //做一些初始化的工作，例如讀取檔案資料，資料庫連線之類別的,
    //這樣這些時間不影響我們測試函式本身的效能

    b.StartTimer() //重新開始時間
    for i := 0; i &lt; b.N; i++ {
        Division(4, 5)
    }
}
</code></pre>

<h3>Run benchmark test</h3>

<p>跑測試 <code>go test -v -bench=. -run=none</code></p>

<pre><code class="go">// go test -v -bench=. -run=none . -cover 

goos: darwin
goarch: amd64
pkg: github.com/mgleon08/packages/015.test
Benchmark_Division-4                    2000000000               0.43 ns/op
Benchmark_TimeConsumingFunction-4       2000000000               0.42 ns/op
PASS
coverage: 50.0% of statements
ok      github.com/mgleon08/packages/015.test   1.802s
</code></pre>

<ul>
<li><code>-bench</code> - 要跑 Benchmark</li>
<li><code>-run=none</code> - 不要跑一般的測試</li>
<li><code>-4</code> - 目前的 CPU 核心數，也就是 GOMAXPROCS 的值</li>
<li><code>-benchtime=2s</code> - 加上這個代表跑 2 秒</li>
</ul>


<h1>Example testing</h1>

<ul>
<li>檔案的結尾必須是，<code>測試檔案名稱</code> + <code>_test</code></li>
<li>測試函式必須是 <code>Example</code> 開頭，且必須第一個字母大寫(public)</li>
<li><code>Output:</code> 是固定格式</li>
</ul>


<pre><code class="go">package main

import (
    "fmt"
)

func ExampleDivision() {
    i, _ := Division(6, 1)
    fmt.Print(i)
    // Output: 6
}

func ExampleDivision2() {
    i, _ := Division(6, 2)
    x, _ := Division(12, 3)
    fmt.Println(i)
    fmt.Println(x)
    // Output:
    // 3
    // 4
}
</code></pre>

<h1>Use assert package</h1>

<pre><code class="go">// main.go
package main

import (
    "errors"
    "fmt"
)

type numbers struct {
    A float64
    B float64
}

func Division(number numbers) (float64, error) {
    if number.B == 0 {
        return 0, errors.New("b can not be 0")
    }
    return number.A / number.B, nil
}

func main() {
    number := numbers{ 60, 2 }
    fmt.Println(Division(number))
}
</code></pre>

<pre><code class="go">// main_test.go
package main

import (
    "testing"

    "github.com/stretchr/testify/assert"
)

func Test_Division(t *testing.T) {
    // Arrange
    testCases := []struct {
        name     string
        p        numbers
        expected float64
    }{
        {
            name: "9/3 = 3",
            p: numbers{
                A: 9,
                B: 3,
            },
            expected: 3,
        },
        {
            name: "6/3 = 2",
            p: numbers{
                A: 6,
                B: 3,
            },
            expected: 2,
        },
        {
            name: "3/3 = 1",
            p: numbers{
                A: 3,
                B: 3,
            },
            expected: 1,
        },
    }

    for _, c := range testCases {
        t.Run(c.name, func(t *testing.T) {
            // Act
            r, _ := Division(c.p)

            // Assert
            assert.Equal(t, r, c.expected)
        })
    }
}
</code></pre>

<p>Reference</p>

<ul>
<li><a href="https://github.com/astaxie/build-web-application-with-golang/blob/master/zh-tw/11.3.md">11.3 Go 怎麼寫測試案例</a></li>
<li><a href="https://blog.wu-boy.com/2018/05/how-to-write-testing-in-golang/">如何在 Go 專案內寫測試</a></li>
<li><a href="https://blog.wu-boy.com/2018/06/how-to-write-benchmark-in-go/">如何在 Go 語言內寫效能測試</a></li>
<li><a href="https://ithelp.ithome.com.tw/articles/10206088">Example 示例函式</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
