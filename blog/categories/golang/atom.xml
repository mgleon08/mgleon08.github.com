<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Golang | Leon's Blogging]]></title>
  <link href="https://mgleon08.github.io/blog/categories/golang/atom.xml" rel="self"/>
  <link href="https://mgleon08.github.io/"/>
  <updated>2020-04-17T23:47:13+08:00</updated>
  <id>https://mgleon08.github.io/</id>
  <author>
    <name><![CDATA[LeonJi]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Golang Tricks]]></title>
    <link href="https://mgleon08.github.io/blog/2019/06/18/golang-tricks/"/>
    <updated>2019-06-18T22:11:30+08:00</updated>
    <id>https://mgleon08.github.io/blog/2019/06/18/golang-tricks</id>
    <content type="html"><![CDATA[<!-- more -->


<ol>
<li><a href="#defer1">Defer 執行順序</a></li>
<li><a href="#range">Range &amp; Foreach</a></li>
<li><a href="#closure">golang 執行的隨機性和閉包</a></li>
<li><a href="#combination_inherit">golang 的組合繼承</a></li>
<li><a href="#select">Select 隨機性</a></li>
<li><a href="#defer2">Defer 執行順序</a></li>
<li><a href="#make_append">make 預設值和 append</a></li>
<li><a href="#map_concurrent">map 執行緒安全</a></li>
<li><a href="#chan_buffer">chan緩存池</a></li>
<li><a href="#interface_implement">interface 實作方式</a></li>
<li><a href="#interface_internal">interface內部結構</a></li>
<li><a href="#type_assertion">Type Assertion</a></li>
<li><a href="#return_value_naming">Return Value Naming</a></li>
<li><a href="#defer3">defer和函式返回值</a></li>
<li><a href="#new_make">new &amp; make</a></li>
<li><a href="#slice_append">slice append</a></li>
<li><a href="#struct_compare">Struct Compare</a></li>
<li><a href="#return_type">Return Type</a></li>
<li><a href="#iota">iota</a></li>
<li><a href="#short_variable_declarations">Short variable declarations</a></li>
<li><a href="#const_address">Const Address</a></li>
<li><a href="#goto">goto 位置</a></li>
<li><a href="#type_alias">Type Alias</a></li>
<li><a href="#variable_scope">if 變數作用域</a></li>
</ol>


<h1><span id='defer1'> Defer 執行順序 </span></h1>

<pre><code class="go">package main

import (
    "fmt"
)

func main() {
    defer_call()
}

func defer_call() {
    defer func() { fmt.Println("1") }()
    defer func() { fmt.Println("2") }()
    defer func() { fmt.Println("3") }()

    panic("exception")
}
</code></pre>

<p><a href="https://play.golang.org/p/Zpbiau9RuGm">https://play.golang.org/p/Zpbiau9RuGm</a></p>

<ul>
<li>defer 採用後進先出(Last In First Out (LIFO))</li>
<li>panic 需等所有的 defer 結束後才會執行</li>
</ul>


<h1><span id='range'> Range &amp; Foreach </span></h1>

<pre><code class="go">package main

import (
    "fmt"
)

type student struct {
    Name string
    Age  int
}

func main() {
    m := make(map[string]*student)
    stus := []student{
        {Name: "zhou", Age: 24},
        {Name: "li", Age: 23},
        {Name: "wang", Age: 22},
    }
    for _, stu := range stus {
        m[stu.Name] = &amp;stu
    }

    for k, v := range m {
        fmt.Println(k, "=&gt;", v.Name)
    }

}
</code></pre>

<p><a href="https://play.golang.org/p/ocNj5lp0W0_4">https://play.golang.org/p/ocNj5lp0W0_4</a></p>

<ul>
<li>range 是用 copy 的方式，因此每個 key 都指向同一個 point，最後的值就會是最後一個指向的 value</li>
<li><p>解決方式，改用 index 的方式</p>

<pre><code class="go">for i := 0; i &lt; len(stus); i++ {
  m[stus[i].Name] = &amp;stus[i]
}

for k, v := range m {
  fmt.Println(k, "=&gt;", v.Name)
}

for i, _ := range stus {
  m[stus[i].Name] = &amp;stus[i]
}

for k, v := range m {
  fmt.Println(k, "=&gt;", v.Name)
}
</code></pre></li>
</ul>


<h1><span id='closure'> golang 執行的隨機性和閉包 </span></h1>

<pre><code class="go">package main

import (
    "fmt"
    "runtime"
    "sync"
)

func main() {
    runtime.GOMAXPROCS(1)
    wg := sync.WaitGroup{}
    wg.Add(20)
    for i := 0; i &lt; 10; i++ {
        go func() {
            fmt.Printf("A address: %p, value: %v\n", &amp;i, i)
            wg.Done()
        }()
    }
    for i := 0; i &lt; 10; i++ {
        go func(i int) {
            fmt.Printf("B address: %p, value: %v\n", &amp;i, i)
            wg.Done()
        }(i)
    }
    wg.Wait()
}
</code></pre>

<p><a href="https://play.golang.org/p/EzCWf8r1wnt">https://play.golang.org/p/EzCWf8r1wnt</a></p>

<ul>
<li>第一個 func 沒有將 i 帶入，取得的 i 是 for 外部的 i，並且 i 會一直加 1 直到 10，因此最後輸出的 A 全部都是 10</li>
<li>第二個 func 則是每次都會帶入 i，每個 i 都會做 copy 帶入 func，因此外部的 ++ 不會影響到</li>
</ul>


<h1><span id='combination_inherit'> golang 的組合繼承 </span></h1>

<pre><code class="go">package main

import (
    "fmt"
)

type People struct{}

func (p *People) ShowA() {
    fmt.Println("showA")
    p.ShowB()
}
func (p *People) ShowB() {
    fmt.Println("showB")
}

type Teacher struct {
    People
}

func (t *Teacher) ShowB() {
    fmt.Println("teacher showB")
}

func main() {
    t := Teacher{}
    t.ShowA()
}
</code></pre>

<p><a href="https://play.golang.org/p/eSGvASIBn5K">https://play.golang.org/p/eSGvASIBn5K</a></p>

<ul>
<li>透過組合的方式，來實現 OO 的繼承，當 struct 有 <code>anonymous struct field</code>，就會被當成 <code>promoted fields</code>，簡單的來說原本 people 的方法(必須是匿名)就可以直接被 teacher 給調用</li>
<li>當呼叫了 showA() 裡面在 call showB() 時，此時 People 類型並不知道自己會被什麼類型組合，因此無法去使用未知的組合者 Teacher 類型的 func</li>
</ul>


<h1><span id='select'> Select隨機性 </span></h1>

<pre><code class="go">package main

import (
    "fmt"
    "runtime"
)

func main() {
    runtime.GOMAXPROCS(1)
    int_chan := make(chan int, 1)
    string_chan := make(chan string, 1)
    int_chan &lt;- 1
    string_chan &lt;- "hello"
    select {
    case value := &lt;-int_chan:
        fmt.Println(value)
    case value := &lt;-string_chan:
        panic(value)
    }
}
</code></pre>

<p><a href="https://play.golang.org/p/ntESh6QYaYT">https://play.golang.org/p/ntESh6QYaYT</a></p>

<ul>
<li>select 擁有隨機性，因此都有可能觸發</li>
<li>當只要有個 case 可以 return 就可以立即執行</li>
<li>都能 return 則隨機</li>
<li>都不行則跑 default</li>
</ul>


<h1><span id='defer2'> Defer 執行順序 </span></h1>

<pre><code class="go">package main

import "fmt"

func calc(index string, a, b int) int {
    ret := a + b
    fmt.Println(index, a, b, ret)
    return ret
}

func main() {
    a := 1
    b := 2
    defer calc("A", a, calc("C", a, b))
    a = 3
    defer calc("B", a, calc("D", a, b))
    b = 4
}
</code></pre>

<p><a href="https://play.golang.org/p/BrhIs-_chN_y">https://play.golang.org/p/BrhIs-_chN_y</a></p>

<ul>
<li>defer 採用後進先出(Last In First Out (LIFO))</li>
</ul>


<h1><span id='make_append'> make 預設值和 append </span></h1>

<pre><code class="go">package main

import "fmt"

func main() {
    s := make([]int, 5)
    s = append(s, 1, 2, 3)
    fmt.Println(s)
}
</code></pre>

<p><a href="https://play.golang.org/p/7VHcPYjenWw">https://play.golang.org/p/7VHcPYjenWw</a></p>

<ul>
<li>make 初始化時，後面直有一個值的話，代表 len 和 cap，因此裡面預設就有 5 個 default 0，所以在 append 時，會再繼續加上去</li>
</ul>


<h1><span id='map_concurrent'> map 執行緒安全 </span></h1>

<pre><code class="go">package main

import (
    "fmt"
    "sync"
)

type UserAges struct {
    ages map[string]int
    sync.Mutex
}

func (ua *UserAges) Add(name string, age int) {
    ua.Lock()
    defer ua.Unlock()
    ua.ages[name] = age
}

func (ua *UserAges) Get(name string) int {
    if age, ok := ua.ages[name]; ok {
        return age
    }
    return -1
}

func main() {
    userAge := &amp;UserAges{
        ages: make(map[string]int),
    }
    userAge.Add("leon", 28)
    age := userAge.Get("leon")
    fmt.Println(age)
}
</code></pre>

<p><a href="https://play.golang.org/p/KwtbBryhP5x">https://play.golang.org/p/KwtbBryhP5x</a></p>

<ul>
<li>在讀(Get)的時候，沒有加上 Lock，可能會導致 <code>fatal error: concurrent map read and map write</code></li>
<li>更改為
<code>go
func (ua *UserAges) Get(name string) int {
  ua.Lock()
  defer ua.Unlock()
  if age, ok := ua.ages[name]; ok {
      return age
  }
  return -1
}
</code></li>
</ul>


<h1><span id='chan_buffer'> chan緩存池 </span></h1>

<pre><code class="go">package main

import (
    "fmt"
    "sync"
)

type threadSafeSet struct {
    sync.RWMutex
    s []interface{}
}

func (set *threadSafeSet) Iter() &lt;-chan interface{} {
    ch := make(chan interface{})
    go func() {
        set.RLock()

        for _, elem := range set.s {
            ch &lt;- elem
            fmt.Println("Iter:", elem)
        }

        close(ch)
        set.RUnlock()

    }()
    return ch
}

func main() {

    th := threadSafeSet{
        s: []interface{}{"1", "2"},
    }
    v := &lt;-th.Iter()
    fmt.Printf("%s%v", "ch", v)
}
</code></pre>

<p><a href="https://play.golang.org/p/2n2GBeo35Jo">https://play.golang.org/p/2n2GBeo35Jo</a></p>

<ul>
<li>chan 不是 buffer chan 因此，會造成阻塞，並且顯示不了所有的 value，當 range 將第一個 &ldquo;1&rdquo; 放進 chan 後，再跑第二次要放進 &ldquo;2&rdquo; 時，必須等待第一個值被取出來，因此會停在那邊，但是當取出來後，就會繼續進行下面，導致直接結束</li>
<li>改用 buffer chan
<code>go
ch := make(chan interface{},len(set.s))
</code></li>
</ul>


<h1><span id="interface_implement"> interface 實作方式 </span></h1>

<pre><code class="go">package main

import (
    "fmt"
)

type People interface {
    Speak(string) string
}

type Stduent struct{}

func (stu *Stduent) Speak(think string) (talk string) {
    if think == "say" {
        talk = "You are a good boy"
    } else {
        talk = "hi"
    }
    return
}

func main() {
    var peo People = Stduent{}
    think := "say"
    fmt.Println(peo.Speak(think))
}
</code></pre>

<p><a href="https://play.golang.org/p/u1qbY4CbVNQ">https://play.golang.org/p/u1qbY4CbVNQ</a></p>

<ul>
<li>因為實作 interface 的是 pointer receiver，所以會造成 error
<code>go
var peo People = &amp;Stduent{}
</code></li>
</ul>


<h1><span id="interface_internal"> interface內部結構 <span></h1>

<pre><code class="go">package main

import (
    "fmt"
)

type People interface {
    Show()
}

type Student struct{}

func (stu *Student) Show() {

}

func live() People {
    var stu *Student
    return stu
}

func main() {
    if live() == nil {
        fmt.Println("AAAAAAA")
    } else {
        fmt.Println("BBBBBBB")
    }
}
</code></pre>

<p><a href="https://play.golang.org/p/2nBU-dMwW6b">https://play.golang.org/p/2nBU-dMwW6b</a></p>

<pre><code class="go">package main

import "fmt"

func Foo(x interface{}) {
    if x == nil {
        fmt.Println("empty interface")
        return
    }
    fmt.Println("non-empty interface")
}

func main() {
    var x *int = nil
    Foo(x)
}
</code></pre>

<p><a href="https://play.golang.org/p/lx6W61O66P">https://play.golang.org/p/lx6W61O66P</a></p>

<ul>
<li>golang 中的 interface 分兩種，但底層結構稍微不同，因此 data 指向了 <code>nil</code> 並不代表 interface 是 <code>nil</code>

<ul>
<li><pre><code class="go">var in interface{}
</code></pre></li>
<li><pre><code class="go">type People interface {
    Show()
}
</code></pre></li>
</ul>
</li>
<li>第二個改成 <code>var x interface{}</code> 則為 <code>empty interface</code></li>
<li><a href="https://i6448038.github.io/2018/10/01/Golang-interface/">Go語言interface底層實現</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/27055513">Go介面詳解</a></li>
</ul>


<h1><span id="type_assertion"> Type Assertion <span></h1>

<pre><code class="go">package main

import "fmt"

func main() {
    i := GetValue()

    switch i.(type) {
    case int:
        fmt.Println("int")
    case string:
        fmt.Println("string")
    case interface{}:
        fmt.Println("interface")
    default:
        fmt.Println("unknown")
    }

}

func GetValue() int {
    return 1
}
</code></pre>

<p><a href="https://play.golang.org/p/-OiFMCcYttw">https://play.golang.org/p/-OiFMCcYttw</a></p>

<ul>
<li>Type Assertion 只能用於 interface</li>
</ul>


<h1><span id="return_value_naming"> Return Value Naming <span></h1>

<pre><code class="go">package main

import "fmt"

func main() {
    i, _ := funcMui(1, 2)
    fmt.Println(i)

}

func funcMui(x,y int)(sum int, error){
    return x+y,nil
}
</code></pre>

<p><a href="https://play.golang.org/p/nH6KTCel6ns">https://play.golang.org/p/nH6KTCel6ns</a></p>

<ul>
<li>只要有一個返回值有命名，全部就必須命名</li>
<li>如果兩個 type 一樣，則可以只寫一個</li>
</ul>


<h1><span id="defer3"> defer和函式返回值 <span></h1>

<pre><code class="go">package main

func main() {
    println(DeferFunc1(1))
    println(DeferFunc2(1))
    println(DeferFunc3(1))
}

func DeferFunc1(i int) (t int) {
    t = i
    defer func() {
        t += 3
    }()
    return t
}

func DeferFunc2(i int) int {
    t := i
    defer func() {
        t += 3
    }()
    return t
}

func DeferFunc3(i int) (t int) {
    defer func() {
        t += i
    }()
    return 2
}
</code></pre>

<p><a href="https://play.golang.org/p/HpOb3huRV-0">https://play.golang.org/p/HpOb3huRV-0</a></p>

<ul>
<li>defer 需要在 func 結束前執行</li>
<li>func return 名字會在函式起始處被初始化為對應類型的零值並且作用域為整個函式</li>
<li>DeferFunc1 - t 作用域為整個 func，因此 return 前會將 t 更改</li>
<li>DeferFunc2 - t 作用域為裡面的 func，因此不影響外面的 t</li>
<li>DeferFunc3 - t 作用域為整個 func，跟 Func 1 一樣</li>
</ul>


<h1><span id="new_make"> new &amp; make <span></h1>

<pre><code class="go">package main

import "fmt"

func main() {
    list := new([]int)
    list = append(list, 1)
    fmt.Println(list)
}
</code></pre>

<p><a href="https://play.golang.org/p/CEwGhsmQfZx">https://play.golang.org/p/CEwGhsmQfZx</a></p>

<ul>
<li>new 可以用來初始化泛型，並且返回儲存位址</li>
<li>new 會自動用 zeroed value 來初始化型別

<ul>
<li><code>string</code> => &ldquo;&rdquo;</li>
<li><code>int</code>, <code>float</code> => 0</li>
<li><code>channel</code>, <code>func</code>, <code>map</code>, <code>slice</code> => <code>nil</code></li>
</ul>
</li>
<li>必須改用 make([]int, 0), 初始化 slice (make 不會回傳指標)</li>
<li><a href="https://draveness.me/golang-make-and-new">Go 語言中的 make 和 new</a></li>
<li><a href="https://medium.com/d-d-mag/golang-%E7%AD%86%E8%A8%98-make-%E8%88%87-new-%E7%9A%84%E5%B7%AE%E5%88%A5-68b05c7ce016">golang 筆記：make 與 new 的差別</a></li>
<li><a href="https://golang.org/doc/effective_go.html#allocation_new">Allocation with new</a></li>
<li><a href="https://golang.org/doc/effective_go.html#allocation_make">Allocation with make</a></li>
</ul>


<h1><span id="slice_append"> slice append <span></h1>

<pre><code class="go">package main

import "fmt"

func main() {
    s1 := []int{1, 2, 3}
    s2 := []int{4, 5}
    s1 = append(s1, s2)
    fmt.Println(s1)
}
</code></pre>

<p><a href="https://play.golang.org/p/xOWsWj0Evni">https://play.golang.org/p/xOWsWj0Evni</a></p>

<ul>
<li>append slice 必須加上 <code>...</code> 展開 <code>s2...</code></li>
</ul>


<h1><span id="struct_compare"> Struct Compare <span></h1>

<pre><code class="go">package main

import "fmt"

func main() {
    sn1 := struct {
        age  int
        name string
    }{age: 11, name: "qq"}

    sn2 := struct {
        age  int
        name string
    }{age: 11, name: "qq"}

    if sn1 == sn2 {
        fmt.Println("sn1 == sn2")
    }

    sm1 := struct {
        age int
        m   map[string]string
    }{age: 11, m: map[string]string{"a": "1"}}

    sm2 := struct {
        age int
        m   map[string]string
    }{age: 11, m: map[string]string{"a": "1"}}

    if sm1 == sm2 {
        fmt.Println("sm1 == sm2")
    }
}
</code></pre>

<p><a href="https://play.golang.org/p/3cEX9aYtvsR">https://play.golang.org/p/3cEX9aYtvsR</a></p>

<ul>
<li>struct 只能在相同類型才能做比較，順序也會有差

<ul>
<li>這樣也不能做比較</li>
<li><pre><code class="go">sn3 := struct {
    age  int
    name string
  }{age: 11, name: "qq"}
</code></pre></li>
</ul>
</li>
<li>map 和 slice 則不可比較，如果要比較要用 <code>reflect.DeepEqual</code>

<ul>
<li><pre><code class="go">if reflect.DeepEqual(sm1, sm2) {
      fmt.Println("sm1 == sm2")
  }
</code></pre></li>
</ul>
</li>
</ul>


<h1><span id="return_type"> Return Type <span></h1>

<pre><code class="go">package main

import "fmt"

func GetValue(m map[int]string, id int) (string, bool) {
    if _, exist := m[id]; exist {
        return "存在數據", true
    }
    return nil, false
}

func main() {
    intmap := map[int]string{
        1: "a",
        2: "bb",
        3: "ccc",
    }

    v, err := GetValue(intmap, 3)
    fmt.Println(v, err)
}
</code></pre>

<p><a href="https://play.golang.org/p/noHSLgTvdEq">https://play.golang.org/p/noHSLgTvdEq</a></p>

<ul>
<li><code>nil</code> 可以用作 <code>interface</code>、<code>function</code>、<code>pointer</code>、<code>map</code>、<code>slice</code> 和 <code>channel</code> 的"空值"。</li>
</ul>


<h1><span id="iota"> iota </span></h1>

<pre><code class="go">package main

import "fmt"

const (
    x = iota
    y
    z = "zz"
    k
    p = iota
)

func main() {
    fmt.Println(x, y, z, k, p)
}
</code></pre>

<p><a href="https://play.golang.org/p/XwtR_I0fQdp">https://play.golang.org/p/XwtR_I0fQdp</a></p>

<h1><span id="short_variable_declarations"> Short variable declarations </span></h1>

<pre><code class="go">package main

import "fmt"

var(
    size := 1024
    max_size = size*2
)

func main()  {
    fmt.Println(size,max_size)
}
</code></pre>

<p><a href="https://play.golang.org/p/AUfpBHZg-F4">https://play.golang.org/p/AUfpBHZg-F4</a></p>

<ul>
<li><code>:=</code> 是聲明並賦值，並且系統自動推斷類型，必須放在 main function 裡面</li>
</ul>


<h1><span id="const_address"> Const Address </span></h1>

<pre><code class="go">package main

import "fmt"

const cl  = 100
var bl    = 123

func main()  {
    fmt.Println(&amp;bl,bl)
    fmt.Println(&amp;cl,cl)
}
</code></pre>

<p><a href="https://play.golang.org/p/dbK6-maWceJ">https://play.golang.org/p/dbK6-maWceJ</a></p>

<ul>
<li>常量不同於變數的在運行期分配記憶體，常量通常會被編譯器在預處理階段直接展開，作為指令數據使用</li>
<li><a href="https://stackoverflow.com/questions/35146286/find-address-of-constant-in-go">pointers - Find address of constant in go</a></li>
</ul>


<h1><span id="goto"> goto 位置 </span></h1>

<pre><code class="go">package main

import "fmt"

func main() {

    for i := 0; i &lt; 10; i++ {
    loop:
        fmt.Println(i)
    }
    goto loop
}
</code></pre>

<p><a href="https://play.golang.org/p/-0KuesWC3kM">https://play.golang.org/p/-0KuesWC3kM</a></p>

<ul>
<li>goto 必須放在 func 裡面</li>
</ul>


<h1><span id="type_alias"> Type Alias </span></h1>

<pre><code class="go">package main

import "fmt"

func main() {
    type MyInt1 int
    type MyInt2 = int
    var i int = 9
    var i1 MyInt1 = i
    var i2 MyInt2 = i
    fmt.Println(i1, i2)
}
</code></pre>

<p><a href="https://play.golang.org/p/ELp_QFf5-o2">https://play.golang.org/p/ELp_QFf5-o2</a></p>

<ul>
<li>基於一個類別型建立一個新類型，稱之為 defintion</li>
<li>基於一個類別型建立一個別名，稱之為 alias</li>
<li>MyInt1 為稱之為 defintion，雖然底層類型為 int 類型，但是不能直接賦值，需要強轉</li>
<li>MyInt2 稱之為 alias，可以直接賦值</li>
</ul>


<pre><code class="go">package main

import "fmt"

type User struct {
}

type MyUser1 User
type MyUser2 = User

func (i MyUser1) m1() {
    fmt.Println("MyUser1.m1")
}
func (i User) m2() {
    fmt.Println("User.m2")
}

func main() {
    var i1 MyUser1
    var i2 MyUser2
    i1.m1()
    i2.m2()
}
</code></pre>

<p><a href="https://play.golang.org/p/2fsGAqTmUrH">https://play.golang.org/p/2fsGAqTmUrH</a></p>

<ul>
<li><code>i2.m1()</code> 會 error，因為 m1() 是 <code>MyUser1</code> 才有的 func，不是 User</li>
</ul>


<pre><code class="go">package main

import "fmt"

type T1 struct {
}

func (t T1) m1() {
    fmt.Println("T1.m1")
}

type T2 = T1

type MyStruct struct {
    T1
    T2
}

func main() {
    my := MyStruct{}
    my.m1()
}
</code></pre>

<p><a href="https://play.golang.org/p/zwvjqUFLHax">https://play.golang.org/p/zwvjqUFLHax</a></p>

<ul>
<li>重複會不知道該 call 哪一個導致 error (<code>ambiguous selector my.m1</code>)，把其中一個拿掉就可以 work，或是改為 <code>my.T1.m1()</code> + <code>my.T2.m1()</code></li>
</ul>


<h1><span id="variable_scope"> if 變數作用域 </span></h1>

<pre><code class="go">package main

import (
    "fmt"
)

func main() {
    a, b := 1, 2
    fmt.Printf("%p\n", &amp;a)
    fmt.Printf("%p\n", &amp;b)

    if true {
        b, c := 3, 4
        fmt.Printf("%p\n", &amp;b)
        fmt.Printf("%p\n", &amp;c)
    }
}
</code></pre>

<p><a href="https://play.golang.org/p/CvqxnzGSAG9">https://play.golang.org/p/CvqxnzGSAG9</a></p>

<ul>
<li>if 的變數會遮罩函式作用域內的變數，導致裡面的 b 是新的 address</li>
</ul>


<h1><span id="closure"> closure </span></h1>

<pre><code class="go">package main

import (
    "fmt"
)

func test() []func() {
    var funs []func()
    for i := 0; i &lt; 2; i++ {
        funs = append(funs, func() {
            fmt.Println(&amp;i, i)
        })
    }
    return funs
}

func main() {
    funs := test()
    for _, f := range funs {
        f()
    }
}
</code></pre>

<p><a href="https://play.golang.org/p/8RL7gO5_4EF">https://play.golang.org/p/8RL7gO5_4EF</a></p>

<ul>
<li><code>funx</code> 裡的 i 都是同一個，要不一樣要先 assign 到新的 value
<code>go
for i:=0;i&lt;2 ;i++  {
      x:=i
      funs = append(funs, func() {
          println(&amp;x,x)
      })
}
</code></li>
</ul>


<pre><code class="go">package main

import (
    "fmt"
)

func test(x int) (func(), func()) {
    return func() {
            fmt.Println(x)
            x += 10
        }, func() {
            fmt.Println(x)
        }
}

func main() {
    a, b := test(100)
    a()
    b()

}
</code></pre>

<p><a href="https://play.golang.org/p/5ReC78kUM3c">https://play.golang.org/p/5ReC78kUM3c</a></p>

<ul>
<li>閉包引用相同變數</li>
</ul>


<h1>Reference</h1>

<ul>
<li><a href="https://my.oschina.net/qiangmzsx/blog/1478739">Golang面試題解析</a></li>
<li><a href="https://bit.ly/2WSSgGe">Go面試題答案與解析</a></li>
<li><a href="https://my.oschina.net/qiangmzsx/blog/1515173">Golang面試題解析（二）</a></li>
<li><a href="https://my.oschina.net/qiangmzsx/blog/1533839">Golang面試題解析（三) </a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Golang - GraphQL With Gqlgen]]></title>
    <link href="https://mgleon08.github.io/blog/2019/06/04/golang-graphql-with-gqlgen/"/>
    <updated>2019-06-04T18:50:50+08:00</updated>
    <id>https://mgleon08.github.io/blog/2019/06/04/golang-graphql-with-gqlgen</id>
    <content type="html"><![CDATA[<!-- more -->


<h2>Setup Project</h2>

<p>使用 Go Module  記得先執行 <code>export GO111MODULE=on</code></p>

<pre><code class="go">mkdir gqlgen-todos
cd gqlgen-todos
go mod init github.com/[username]/gqlgen-todos
</code></pre>

<h2>Define the schema</h2>

<p>新增 <code>schema.graphql</code> 定義 <a href="https://graphql.org/learn/queries/">graphql 結構</a></p>

<pre><code class="go">type Todo {
  id: ID!
  text: String!
  done: Boolean!
  user: User!
}

type User {
  id: ID!
  name: String!
}

type Query {
  todos: [Todo!]!
}

input NewTodo {
  text: String!
  userId: String!
}

type Mutation {
  createTodo(input: NewTodo!): Todo!
}
</code></pre>

<h2>Create the project skeleton</h2>

<p>透過 <code>gglgen</code> 建立 graphql 的專案初始化</p>

<pre><code class="go">go run github.com/99designs/gqlgen init
</code></pre>

<ul>
<li><code>gqlgen.yml</code> — The gqlgen config file, knobs for controlling the generated code.</li>
<li><code>generated.go</code> — The GraphQL execution runtime, the bulk of the generated code.</li>
<li><code>models_gen.go</code> — Generated models required to build the graph. Often you will override these with your own models. Still very useful for input types.</li>
<li><code>resolver.go</code> — This is where your application code lives. generated.go will call into this to get the data the user has requested.</li>
<li><code>server/server.go</code> — This is a minimal entry point that sets up an http.Handler to the generated GraphQL server.</li>
</ul>


<h2>Create the database models</h2>

<p>自動生成的 Todo model 不是正確的，因為 Todo 裡面還嵌入了 User，我們希望是在使用者要求時才給予，因此要另外建立 <code>todo.go</code></p>

<pre><code class="go">// todo.go
package gqlgen_todos

type Todo struct {
    ID     string
    Text   string
    Done   bool
    UserID string
}
</code></pre>

<p>將新的 struct 路徑加到 <code>gqlgen.yml</code></p>

<pre><code class="go">// Todo 對應到 todo.go 裡的 struct name
models:
  Todo:
    model: github.com/[username]/gqlgen-todos.Todo
</code></pre>

<p>重新生成檔案</p>

<pre><code class="go">go run github.com/99designs/gqlgen
</code></pre>

<h2>Implement the resolvers</h2>

<p>在 <code>generated.go</code> 產生了很多個 resolvers interface，接著就要實作這些，但 <code>resolver.go</code> 這個檔案，再新增新的 method 時，要重新再產生一份</p>

<pre><code class="go">rm resolver.go
go run github.com/99designs/gqlgen
</code></pre>

<p>實作 <code>resolver.go</code></p>

<pre><code class="go">package gqlgen_todos

import (
    context "context"
    "fmt"
    "math/rand"
)

type Resolver struct {
    todos []Todo
}

func (r *Resolver) Mutation() MutationResolver {
    return &amp;mutationResolver{r}
}
func (r *Resolver) Query() QueryResolver {
    return &amp;queryResolver{r}
}
func (r *Resolver) Todo() TodoResolver {
    return &amp;todoResolver{r}
}

type mutationResolver struct{ *Resolver }

func (r *mutationResolver) CreateTodo(ctx context.Context, input NewTodo) (*Todo, error) {
    todo := &amp;Todo{
        Text:   input.Text,
        ID:     fmt.Sprintf("T%d", rand.Int()),
        UserID: input.UserID,
    }
    r.todos = append(r.todos, *todo)
    return todo, nil
}

type queryResolver struct{ *Resolver }

func (r *queryResolver) Todos(ctx context.Context) ([]Todo, error) {
    return r.todos, nil
}

type todoResolver struct{ *Resolver }

func (r *todoResolver) User(ctx context.Context, obj *Todo) (*User, error) {
    return &amp;User{ID: obj.UserID, Name: "user " + obj.UserID}, nil
}
</code></pre>

<h1>Query</h1>

<pre><code class="go">// open http://localhost:8080
go run server/server.go
</code></pre>

<pre><code class="go">// create
mutation createTodo {
  createTodo(input:{text:"todo", userId:"1"}) {
    user {
      id
    }
    text
    done
  }
}

// show
query findTodos {
    todos {
      text
      done
      user {
        name
      }
    }
}
</code></pre>

<h2>Finishing touches</h2>

<p>At the top of our resolver.go add the following line:</p>

<pre><code class="go">//go:generate go run github.com/99designs/gqlgen
</code></pre>

<p>This magic comment tells go generate what command to run when we want to regenerate our code</p>

<h2>Example</h2>

<ul>
<li><a href="https://github.com/mgleon08/go-packages/tree/master/020.gqlgen-todos">gqlgen-todos</a></li>
</ul>


<h1>Reference</h1>

<ul>
<li><a href="https://gqlgen.com/getting-started/">gqlgen getting-started</a></li>
<li><a href="https://graphql.org/">Graphql</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Golang - Simple RESTful]]></title>
    <link href="https://mgleon08.github.io/blog/2019/04/11/golang-simple-restful/"/>
    <updated>2019-04-11T16:27:10+08:00</updated>
    <id>https://mgleon08.github.io/blog/2019/04/11/golang-simple-restful</id>
    <content type="html"><![CDATA[<!-- more -->


<p>Practice RESTful with golang</p>

<pre><code class="go">GetUsers     GET     /users
GetUser      GET     /users/{id}
CreateUser   POST    /users
UpdateUser   UPDATE  /users/{id}
DeleteUser   DELETE  /users/{id}
</code></pre>

<p>Use <a href="https://github.com/gorilla/mux">gorilla/mux</a> package</p>

<pre><code class="go">package main

import (
    "encoding/json"
    "fmt"
    "log"
    "net/http"
    "strconv"

    "github.com/gorilla/mux"
)

type User struct {
    ID        int    `json:"id,omitempty"`
    Firstname string `json:"firstname,omitempty"`
    Lastname  string `json:"lastname,omitempty"`
    Info      `json:"info,omitempty"`
}
type Info struct {
    City  string `json:"city,omitempty"`
    Phone int    `json:"phone,omitempty"`
}

var users []User

func GetUsers(w http.ResponseWriter, r *http.Request) {
    json.NewEncoder(w).Encode(users)
}

func GetUser(w http.ResponseWriter, r *http.Request) {
    id := convertParams(r)
    for _, u := range users {
        if u.ID == id {
            json.NewEncoder(w).Encode(u)
            return
        }
    }
    json.NewEncoder(w).Encode("User not found")
}

func CreateUser(w http.ResponseWriter, r *http.Request) {
    var user User
    _ = json.NewDecoder(r.Body).Decode(&amp;user)
    users = append(users, user)
    json.NewEncoder(w).Encode(user)
}

func UpdateUser(w http.ResponseWriter, r *http.Request) {
    var user User
    id := convertParams(r)
    _ = json.NewDecoder(r.Body).Decode(&amp;user)
    for i, u := range users {
        if u.ID == id {
            users[i] = user
            json.NewEncoder(w).Encode(user)
            break
        }
    }
}

func DeleteUser(w http.ResponseWriter, r *http.Request) {
    id := convertParams(r)
    for i, u := range users {
        if u.ID == id {
            copy(users[i:], users[i+1:])
            users = users[:len(users)-1]
            break
        }
    }
    json.NewEncoder(w).Encode(users)
}

func convertParams(r *http.Request) int {
    params := mux.Vars(r)
    id, err := strconv.Atoi(params["id"])
    if err != nil {
        log.Fatalf("err: %v", err)
    }
    return id
}

func main() {
    router := mux.NewRouter()
    user1 := User{ID: 1, Firstname: "hello", Lastname: "World", Info: Info{City: "Taipei", Phone: 123}}
    user2 := User{ID: 2, Firstname: "hello", Lastname: "World", Info: Info{City: "Taipei", Phone: 456}}
    users = append(users, user1, user2)
    router.HandleFunc("/users", GetUsers).Methods("GET")
    router.HandleFunc("/users/{id}", GetUser).Methods("GET")
    router.HandleFunc("/users", CreateUser).Methods("POST")
    router.HandleFunc("/users/{id}", UpdateUser).Methods("PUT")
    router.HandleFunc("/users/{id}", DeleteUser).Methods("DELETE")
    fmt.Println("Starting server on port 3000...")
    log.Fatal(http.ListenAndServe(":3000", router))
}
</code></pre>

<p>params</p>

<pre><code class="go">{
  "id": 3,
  "firstname": "hello",
  "lastname": "World",
  "info": {
    "city": "Taipei",
    "phone": 123
  }
}
</code></pre>

<p>run</p>

<pre><code class="go">go run main.go
// http://localhost:3000/users
</code></pre>

<h1>Code</h1>

<ul>
<li><a href="https://github.com/mgleon08/go-packages/blob/master/018.simple_restful/main.go">simple_restful</a></li>
</ul>


<h1>With mongodb</h1>

<ul>
<li><a href="https://github.com/mgleon08/go-packages/tree/master/019.restful_mongodb">restful_mongodb</a></li>
</ul>


<p>Reference</p>

<ul>
<li><a href="https://medium.com/@petrousov/how-to-build-a-restful-api-in-go-for-phonebook-app-d55f7234a10">How to build a RESTful API in Go for phonebook app</a></li>
<li><a href="https://medium.com/@petrousov/implementing-crud-operations-with-go-and-mongodb-cf622f2379c4">Implementing CRUD operations with Go and MongoDB</a></li>
<li><a href="https://github.com/gorilla/mux">gorilla/mux</a></li>
<li><a href="https://yourbasic.org/golang/delete-element-slice/">2 ways to delete an element from a slice</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Golang - MongoDB]]></title>
    <link href="https://mgleon08.github.io/blog/2019/04/10/golang-mongodb/"/>
    <updated>2019-04-10T21:30:30+08:00</updated>
    <id>https://mgleon08.github.io/blog/2019/04/10/golang-mongodb</id>
    <content type="html"><![CDATA[<!-- more -->


<h1>Install the MongoDB Go Driver</h1>

<pre><code class="go">go go get github.com/mongodb/mongo-go-driver
</code></pre>

<p>或使用 go module</p>

<pre><code class="go">go mode init &lt;current package name&gt;
</code></pre>

<h1>Connect to MongoDB using the Go Driver</h1>

<pre><code class="go">package main

import (
    "context"
    "fmt"
    "log"

    "github.com/mongodb/mongo-go-driver/mongo"
    "go.mongodb.org/mongo-driver/mongo/options"
)

func main() {
    client, err := mongo.Connect(context.Background(), options.Client().ApplyURI("mongodb://localhost:27017"))

    if err != nil {
        log.Fatal(err)
    }

    // Check the connection
    err = client.Ping(context.Background(), nil)

    if err != nil {
        log.Fatal(err)
    }

    fmt.Println("Connected to MongoDB!")

    // handle for the trainers collection in the test database
    // collection := client.Database("test").Collection("trainers")

    // Close the connection
    err = client.Disconnect(context.TODO())

    if err != nil {
        log.Fatal(err)
    }
    fmt.Println("Connection to MongoDB closed.")
}
</code></pre>

<ul>
<li><code>mongo.Connect</code> Connect</li>
<li><code>client.Ping</code> Check the connection</li>
<li><code>client.Disconnect</code> Close the connection</li>
</ul>


<h1>BSON (Binary Serialized Document Format, Binary-encoded JSON)</h1>

<ul>
<li>一種二進制形式的存儲格式，採用了類似於 C 語言結構體的名稱</li>
<li>對表示方法支援內嵌的文件物件和陣列物件</li>
<li>具有輕量性、可遍歷性、高效性的特點，可以有效描述非結構化數據和結構化數據</li>
<li>schema-less的存儲形式</li>
<li>優點是靈活性高，但它的缺點是空間利用率不是很理想</li>
<li>不像一般 json 用簡單的 string 和 number，而是可以給予 type (int, long, date, floating point, and decimal128)，可以更方便的去做比較排許等等的</li>
</ul>


<h3>在 Go 中提供了兩種 BSON 的資料格式 <code>D types</code> the <code>Raw types</code></h3>

<p><code>D type</code></p>

<blockquote><p>The D family of types is used to concisely build BSON objects using native Go types. This can be particularly useful for constructing commands passed to MongoDB. The D family consists of four types:</p></blockquote>

<ul>
<li><code>D</code>: A BSON document. This type should be used in situations where order matters, such as MongoDB commands.</li>
<li><code>M</code>: An unordered map. It is the same as D, except it does not preserve order.</li>
<li><code>A</code>: A BSON array.</li>
<li><code>E</code>: A single element inside a D.</li>
</ul>


<p>Example</p>

<pre><code class="go">// D type filter to find where the name field matches either Alice or Bob 
bson.D\{\{
    "name", 
    bson.D\{\{
        "$in", 
        bson.A{"Alice", "Bob"}
    }}
}}
</code></pre>

<p><code>Raw</code></p>

<blockquote><p>The Raw family of types is used for validating a slice of bytes. You can also retrieve single elements from Raw types using a <a href="https://godoc.org/go.mongodb.org/mongo-driver/bson#Raw.Lookup">Lookup</a>. This is useful if you don&rsquo;t want the overhead of having to unmarshall the BSON into another type. This tutorial will just use the D family of types.</p></blockquote>

<h1>CRUD Operations</h1>

<pre><code class="go">type Trainer struct {
    Name string
    Age  int
    City string
}
</code></pre>

<h3>C - Insert documents</h3>

<pre><code class="go">ash := Trainer{"Ash", 10, "Pallet Town"}
misty := Trainer{"Misty", 10, "Cerulean City"}
brock := Trainer{"Brock", 15, "Pewter City"}

// insert one
insertResult, err := collection.InsertOne(context.TODO(), ash)
if err != nil {
  log.Fatal(err)
}
fmt.Println("Inserted a single document: ", insertResult.InsertedID)

// insert many
trainers := []interface{}{misty, brock}
insertManyResult, err := collection.InsertMany(context.TODO(), trainers)
if err != nil {
  log.Fatal(err)
}
fmt.Println("Inserted multiple documents: ", insertManyResult.InsertedIDs)
</code></pre>

<h3>U - Update documents</h3>

<p>需要透過 <code>bson.D</code> types 去找到 match 的 data 再做更新</p>

<ul>
<li><a href="https://docs.mongodb.com/manual/reference/operator/update-field/">Field Update Operators</a></li>
</ul>


<pre><code class="go">// 找出 name ＝ "Ash"
filter := bson.Dname

// 將 age - 1
update := bson.D{
    {"$inc", bson.D{
        {"age", 1},
    }},
}

updateResult, err := collection.UpdateOne(context.TODO(), filter, update)
if err != nil {
    log.Fatal(err)
}

fmt.Printf("Matched %v documents and updated %v documents.\n", updateResult.MatchedCount, updateResult.ModifiedCount)
</code></pre>

<ul>
<li><code>$inc</code> - Increments the value of the field by the specified amount.</li>
<li><code>updateResult.MatchedCount</code> - The number of documents that matched the filter.</li>
<li><code>updateResult.ModifiedCount</code> - The number of documents that were modified.</li>
</ul>


<h3>R - Find documents</h3>

<p><code>Find a document</code> use <code>collection.FindOne()</code></p>

<blockquote><p>To find a document, you will need a filter document as well as a pointer to a value into which the result can be decoded</p></blockquote>

<pre><code class="go">// create a value into which the result can be decoded
var result Trainer

// 取出的值必須要 Decode
err = collection.FindOne(context.TODO(), filter).Decode(&amp;result)
if err != nil {
    log.Fatal(err)
}

fmt.Printf("Found a single document: %+v\n", result)
</code></pre>

<p><code>Find multiple documents</code> use <code>collection.Find()</code></p>

<blockquote><p>This method returns a Cursor. A Cursor provides a stream of documents through which you can iterate and decode one at a time. Once a Cursor has been exhausted, you should close the Cursor.</p>

<p>Here you&rsquo;ll also set some options on the operation using the options package. Specifically, you&rsquo;ll set a limit so only 2 documents are returned.</p></blockquote>

<pre><code class="go">// Pass these options to the Find method
findOptions := options.Find()
findOptions.SetLimit(2)

// Here's an array in which you can store the decoded documents
var results []*Trainer

// Passing nil as the filter matches all documents in the collection
// 範例原本寫 nil 但是有問題所以改成 bson.D{}
cur, err := collection.Find(context.TODO(), bson.D{}, findOptions)
if err != nil {
    log.Fatal(err)
}

// Finding multiple documents returns a cursor
// Iterating through the cursor allows us to decode documents one at a time
for cur.Next(context.TODO()) {

    // create a value into which the single document can be decoded
    var elem Trainer
    err := cur.Decode(&amp;elem)
    if err != nil {
        log.Fatal(err)
    }
    results = append(results, &amp;elem)
}

if err := cur.Err(); err != nil {
    log.Fatal(err)
}

// Close the cursor once finished
cur.Close(context.TODO())

fmt.Printf("Found multiple documents (array of pointers): %+v\n", results)

for index, result := range results {
    fmt.Printf("%d: %+v \n", index, result)
}
</code></pre>

<h3>D - Delete Documents</h3>

<blockquote><p>delete documents using <code>collection.DeleteOne()</code> or <code>collection.DeleteMany()</code>.</p>

<p>Here you pass nil as the filter argument, which will match all documents in the collection. You could also use <a href="https://godoc.org/github.com/mongodb/mongo-go-driver/mongo#Collection.Drop">collection.Drop()</a> to delete an entire collection.</p></blockquote>

<pre><code class="go">// DeleteOne
deleteOneResult, err := collection.DeleteOne(context.TODO(), bson.M{})
if err != nil {
  log.Fatal(err)
}
fmt.Printf("Deleted %v documents in the trainers collection\n", deleteOneResult.DeletedCount)

// DeleteMany
deleteResult, err := collection.DeleteMany(context.TODO(), bson.M{})
// DELETA name = Misty &amp;&amp; age &gt; 10
// deleteResult, err := collection.DeleteMany(context.TODO(), bson.M{"name": "Misty", "age": bson.M{"$gte": 10}})
// deleteResult, err := collection.DeleteMany(context.TODO(), bson.D\{\{"name", "Misty"}, {"age", bson.M{"$gte": 10}}})
if err != nil {
  log.Fatal(err)
}
fmt.Printf("Deleted %v documents in the trainers collection\n", deleteResult.DeletedCount)
</code></pre>

<h1>Example</h1>

<ul>
<li><a href="https://github.com/mgleon08/go-packages/tree/master/017.mongodb">016.mongodb</a></li>
</ul>


<p>Reference</p>

<ul>
<li><a href="https://github.com/mongodb/mongo-go-driver/tree/master/examples/documentation_examples">documentation_examples</a></li>
<li><a href="https://godoc.org/go.mongodb.org/mongo-driver">godoc mongo-driver</a></li>
<li><a href="https://docs.mongodb.com/manual/reference/operator/">BSON Operators</a></li>
<li><a href="http://bsonspec.org/">BSON</a></li>
<li><a href="https://blog.csdn.net/m0_38110132/article/details/77716792">BSON的介紹及BSON與JSON的區別</a></li>
<li><a href="https://www.mongodb.com/blog/post/mongodb-go-driver-tutorial">MongoDB Go Driver Tutorial</a></li>
<li><a href="https://www.jianshu.com/p/0344a21e8040?utm_campaign=maleskine&amp;utm_content=note&amp;utm_medium=seo_notes&amp;utm_source=recommendation">mongodb官方的golang驅動基礎使用課程分享</a></li>
<li><a href="https://zh.shellman.me/articles/mongo-go-driver-demo/">MongoDB官方推出的Go驅動庫“mongo-go-driver”快速課程</a></li>
<li><a href="https://blog.gtwang.org/programming/getting-started-with-mongodb-shell-1/">MongoDB 基礎入門教學：MongoDB Shell 篇</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Golang - Context]]></title>
    <link href="https://mgleon08.github.io/blog/2019/04/10/golang-context/"/>
    <updated>2019-04-10T21:30:20+08:00</updated>
    <id>https://mgleon08.github.io/blog/2019/04/10/golang-context</id>
    <content type="html"><![CDATA[<!-- more -->


<p><code>context</code> 是控制並發的一個 package，之前在 <a href="https://mgleon08.github.io/blog/2018/05/17/golang-goroutine-channel-worker-pool-select-mutex/#worker_pool">Worker Pool</a> 也有提到過另一個 <code>WaitGroup</code>，那為什麼需要兩種，來了解一下</p>

<h1>WaitGroup</h1>

<p>當所有的 <code>goroutine</code> 都完成後，才算完成</p>

<h3>實際場景</h3>

<p>有個監控程式跑很多 <code>gorountine</code>，當要停止時，就必須通知每個 <code>gorountine</code> 並等待所有都完成，才算完成，否則會造成記憶體洩漏</p>

<pre><code class="go">package main

import (
    "fmt"
    "sync"
    "time"
)

func process(i int, wg *sync.WaitGroup) {
    fmt.Println("監控開始 ", i)
    time.Sleep(2 * time.Second)
    fmt.Printf("監控 %d 結束\n", i)
    wg.Done() // 執行完一次就 -1
}

func main() {
    no := 2
    var wg sync.WaitGroup
    for i := 0; i &lt; no; i++ {
        wg.Add(1)          // 每次執行都 + 1
        go process(i, &amp;wg) // wg 一定要用 pointer，否則每個 goroutine 都會有各自的 WaitGroup
    }
    wg.Wait() // 會 wait 到 0 才會繼續下一步
    fmt.Println("所有監控完成")
}
</code></pre>

<p>大部分的 <code>gorountine</code> 啟動後，就會一直跑，大部分情況是等待它自己結束，如果是不會結束的 <code>gorountine</code>，就會一直跑下去，比較笨的方式就是，用一個變數去判斷是否要結束，但這樣就必須一直去檢查這個變數</p>

<p>因此可以改用 <code>chan + select</code> 來通知</p>

<h1>chan + select</h1>

<p>這方式很好的解決上述的問題，並且可以透過給予 <code>chan</code> 值來決定是否要停止，但還是有其他問題</p>

<ul>
<li>如果有很多 <code>goroutine</code> 都需要控制結束怎麼辦?</li>
<li><code>goroutine</code> 又衍生了其它更多的goroutine怎麼?</li>
</ul>


<p>即使定義很多 <code>chan</code> 也很難解決這個問題，因為 <code>goroutine</code> 的關係鏈就導致了這種場景非常複雜，因此就有另一個方式 <code>context</code></p>

<pre><code class="go">package main

import (
    "fmt"
    "time"
)

func process(stop chan bool) {
    for {
        select {
        case &lt;-stop:
            fmt.Println("監控退出，停止了...")
            return
        default:
            fmt.Println("goroutine 監控中...")
            time.Sleep(2 * time.Second)
        }
    }
}

func main() {
    stop := make(chan bool)
    go process(stop)
    time.Sleep(5 * time.Second)
    stop &lt;- true
    fmt.Println("所有監控完成")
}
</code></pre>

<h1>context</h1>

<ul>
<li><a href="https://golang.org/pkg/context/">context</a></li>
</ul>


<p>上面提到的情境是多層級的 <code>goroutine</code>，因此要控制就必須跟蹤 <code>groutine</code></p>

<p>因此 golang 提供了 <code>context</code> 來控制，也就是 <code>groutine</code> 的上下文</p>

<h3>Context 使用原則</h3>

<ul>
<li>不要把 Context 放在結構體中，要以參數的方式傳遞</li>
<li>以 Context 作為參數的函式方法，應該把 Context 作為第一個參數，放在第一位。</li>
<li>給一個函式方法傳遞 Context 的時候，不要傳遞 nil，如果不知道傳遞什麼，就使用 <code>context.TODO</code></li>
<li>Context 的 Value 相關方法應該傳遞必須的數據，不要什麼數據都使用這個傳遞</li>
<li>Context 是執行緒安全的，可以放心的在多個 goroutine 中傳遞</li>
</ul>


<pre><code class="go">package main

import (
    "context"
    "fmt"
    "time"
)

func process(ctx context.Context) {
    for {
        select {
        case &lt;-ctx.Done():
            fmt.Println("監控退出，停止了...")
            return
        default:
            fmt.Println("goroutine監控中...")
            time.Sleep(2 * time.Second)
        }
    }
}

func main() {
    ctx, cancel := context.WithCancel(context.Background())

    go process(ctx)
    time.Sleep(5 * time.Second)
    fmt.Println("通知監控停止")
    cancel()
    time.Sleep(5 * time.Second)
    fmt.Println("所有監控完成")
}
</code></pre>

<ul>
<li><code>context.Background()</code> 回傳一個非 nil 的空 context，不會被取消也沒有值或時間，就是 context 的根節點</li>
<li><code>context.WithCancel(parent)</code> 建立一個可取消的 <code>子 context</code> 當作參數來追蹤 <code>goroutine</code>，另外一個是 <code>cancle</code> 用於取消這個 <code>子 context</code></li>
<li><code>ctx.Done</code> 判斷是否要結束，透過 <code>cancel()</code> 來取消</li>
</ul>


<p>目前為止似乎跟 <code>chan</code> 沒什麼兩樣?接著試著控制多個 goroutine</p>

<pre><code class="go">package main

import (
    "context"
    "fmt"
    "time"
)

func process(ctx context.Context, n int) {
    for {
        select {
        case &lt;-ctx.Done():
            fmt.Println(n, "監控退出，停止了...")
            return
        default:
            fmt.Printf("goroutine %v 監控中...\n", n)
            time.Sleep(2 * time.Second)
        }
    }
}

func main() {
    ctx, cancel := context.WithCancel(context.Background())
    n := 3
    for i := 0; i &lt; n; i++ {
        go process(ctx, i)
    }

    time.Sleep(5 * time.Second)
    fmt.Println("通知監控停止")
    cancel()
    time.Sleep(5 * time.Second)
    fmt.Println("所有監控完成")
}
</code></pre>

<p>可以看到，上面即使有多個 <code>goroutine</code> 依樣只要一個 <code>cancel()</code> 就全部都取消了</p>

<p>如果是用之前 <code>chan</code>，變成只有一個 <code>true</code> 只能夠取消一個，就結束了，導致剩下的 memory 沒辦法釋放，或是一次放三個 <code>true</code> 去控制，但是當一多起來，就會變得很複雜</p>

<h1>Context interface</h1>

<pre><code class="go">type Context interface {
    Deadline() (deadline time.Time, ok bool)

    Done() &lt;-chan struct{}

    Err() error

    Value(key interface{}) interface{}
}
</code></pre>

<ul>
<li><code>Deadline()</code> 是獲取設定的截止時間的意思

<ul>
<li><code>deadline</code> 截止時間，到了這個時間點，Context 會自動發起取消請求</li>
<li><code>ok</code> 如果是 false，表示沒有設定截止時間，如果需要取消的話，需要呼叫取消函式進行取消</li>
</ul>
</li>
<li><code>Done</code> 返回一個 <code>只讀的 chan</code>，類型為 struct{}

<ul>
<li>如果可讀取，表示 <code>parent context</code> 已發起取消的請求(<code>cancel</code>)，收到信號時就會開始清理操作，然後退出 goroutine，釋放資源</li>
</ul>
</li>
<li><code>Err</code> 返回取消的錯誤原因，因為什麼 Context 被取消</li>
<li><code>Value</code> 獲取該 Context 上繫結的值，是一個鍵值對，所以要透過一個 Key 才可以獲取對應的值，這個值一般是執行緒安全的</li>
</ul>


<h1>Other</h1>

<ul>
<li><a href="https://golang.org/pkg/context/#example_WithCancel">WithCancel</a> 主動取消</li>
<li><a href="https://golang.org/pkg/context/#example_WithDeadline">WithDeadline</a> 截止時間取消</li>
<li><a href="https://golang.org/pkg/context/#example_WithTimeout">WithTimeout</a> 超時取消</li>
<li><a href="https://golang.org/pkg/context/#example_WithValue">WithValue</a> 傳值</li>
<li>也可以不包上面的 With，直接使用 <code>context.Background()</code>，可以看到上面的 With 最後回傳的也是 <code>context Context</code></li>
</ul>


<p>Reference</p>

<ul>
<li><a href="https://golang.org/pkg/context/">context</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/58967892">Go Context</a></li>
<li><a href="https://deepzz.com/post/golang-context-package-notes.html">快速掌握 Golang context 包，簡單示例</a></li>
<li><a href="https://segmentfault.com/a/1190000017394302">Golang Context 是好的設計嗎？</a></li>
<li><a href="https://juejin.im/post/5a6873fef265da3e317e55b6">Golang Context深入理解</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
