<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Golang | Leon's Blogging]]></title>
  <link href="http://mgleon08.github.com/blog/categories/golang/atom.xml" rel="self"/>
  <link href="http://mgleon08.github.com/"/>
  <updated>2019-02-11T20:48:23+08:00</updated>
  <id>http://mgleon08.github.com/</id>
  <author>
    <name><![CDATA[LeonJi]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Golang - Maps in Action]]></title>
    <link href="http://mgleon08.github.com/blog/2019/02/08/golang-maps-in-action/"/>
    <updated>2019-02-08T10:55:15+08:00</updated>
    <id>http://mgleon08.github.com/blog/2019/02/08/golang-maps-in-action</id>
    <content type="html"><![CDATA[<!-- more -->


<h1>Introduction</h1>

<p> <code>Hash Table</code> 是 Computer Science 中最有用的資料結構，提供了快速尋找，新增，刪除，Golang 透過 <code>map</code> type 來實踐。</p>

<h1>Declaration and initialization</h1>

<pre><code class="go">map[KeyType]ValueType
</code></pre>

<ul>
<li>KeyType 是 type 可以是任意一個可比較的類型</li>
<li>ValueType 也是可以任意的類型</li>
<li>包括 map type 也可以</li>
</ul>


<p>下面的變數 <code>m</code> 是一個 <code>string keys</code> to <code>int values</code> 的 map</p>

<pre><code class="go">var m map[string]int
</code></pre>

<p>Map 的類型是 <code>reference types</code>, 像是 <code>pointers</code> or <code>slices</code>，因此上面 <code>m</code> 的 value 是 nil</p>

<p>當讀取時 <code>nil map</code> 行為類似空的 map，若嘗試寫入 <code>nil map</code> 則會造成 <code>runtime panic</code></p>

<p>因此如果要初始化一個 map 可以用 <code>make</code> function</p>

<pre><code class="go">m = make(map[string]int)
</code></pre>

<p><code>make</code> function 會分配並且初始化一個 <code>hash map data structure</code> 並返回指向它(<code>make</code>)的 map value</p>

<h1>Working with maps</h1>

<p>Set key <code>route</code> to <code>66</code></p>

<pre><code class="go">m["route"] = 66
</code></pre>

<p>Assign <code>m["route"]</code> to variable <code>66</code></p>

<pre><code class="go">i := m["route"]
</code></pre>

<p>value 是 <code>int</code>，因此如果 key 不存在，則會回傳 <code>0</code>，string 則是回傳空字串</p>

<blockquote><p>前提是要用 make 來建立，否則會 panic</p></blockquote>

<pre><code class="go">j := m["root"]
// j == 0
</code></pre>

<p>回傳 map 的 item 長度</p>

<pre><code class="go">n := len(m)
</code></pre>

<p><code>delete</code> function 根據 key 去做刪除，刪除不會回傳任何東西，如果 key 是不存在則不會做任何事</p>

<pre><code class="go">delete(m, "route")
</code></pre>

<p>map 也可以用兩個變數來取</p>

<ul>
<li>第一個變數 <code>i</code> 是指 <code>m["route"]</code> 裡的值，如果沒有 <code>route</code> 就回傳 <code>0</code></li>
<li>第二個變數 <code>ok</code> 則是用來判斷這個 key 存不存在，true 為存在，反之不存在</li>
</ul>


<pre><code class="go">i, ok := m["route"]
</code></pre>

<p>如果只是要判斷存不存在，並沒有要使用到 value 可以給一個 <code>_</code></p>

<pre><code class="go">_, ok := m["route"]
</code></pre>

<p>要取出 map 的 key &amp; value 可以用 range</p>

<pre><code class="go">for key, value := range m {
    fmt.Println("Key:", key, "Value:", value)
}
</code></pre>

<p>初始化並給值</p>

<pre><code class="go">commits := map[string]int{
    "rsc": 3711,
    "r":   2138,
    "gri": 1908,
    "adg": 912,
}
</code></pre>

<p>初始化並給空的值，效果跟用 <code>make</code> 一樣</p>

<pre><code class="go">m = map[string]int{}
</code></pre>

<h1>Exploiting zero values</h1>

<p>在 map 上利用 0(bool) 值</p>

<h3>map 利用 bool 來作為一種數據結構的檢測，就不需要多一個變數來處理</h3>

<pre><code class="go">package main

import (
    "fmt"
)

func main() {
    // 建立一個 Node 的 struct
    type Node struct {
        Next  *Node
        Value interface{}
    }

    second := &amp;Node{
        Next:  nil,
        Value: 2,
    }

    first := &amp;Node{
        Next:  second,
        Value: 1,
    }
    // 故意讓 first 重複，形成迴圈
    second.Next = first
    visited := make(map[*Node]bool)
    for n := first; n != nil; n = n.Next {
        // 如果遇到一個已經變成 true 代表重複了，就 break
        if visited[n] {
            fmt.Println("cycle detected")
            break
        }
        // 只要有遍歷到就將 value 改成 true
        visited[n] = true
        fmt.Println(n.Value)
    }

}
</code></pre>

<h3>map of slices</h3>

<p>不需要 check key 存不存在，因為 appending 一個 nil 的 slice, 會自動分配新的 slice</p>

<pre><code class="go">package main

import (
    "fmt"
)

func main() {
    type Person struct {
        Name  string
        Likes []string
    }

    var people []*Person
    people = append(people, &amp;Person{"Leon", []string{"cheese", "bacon"}})
    // 也可以 people := []*Person{&amp;Person{"Leon", []string{"cheese", "bacon"}}}

    likes := make(map[string][]*Person)

    // 取出所有 people
    for _, p := range people {
        // 取出每個 person 喜歡的東西
        for _, l := range p.Likes {
            // 列出喜歡這個東西的人
            likes[l] = append(likes[l], p)
        }
    }
    // 列出喜歡起司的人
    for _, p := range likes["cheese"] {
        fmt.Println(p.Name, "likes cheese.")
    }

    // 列出喜歡培根的人數
    fmt.Println(len(likes["bacon"]), "people like bacon.")
}
</code></pre>

<p>由於 range 和 len 都將 nil slice 視為零長度的 slice，所以沒有 data 也不會有問題</p>

<pre><code class="go">package main

import "fmt"

type ListNode struct {
    Val  int
    Next *ListNode
}

func main() {
    mapp := make(map[string]ListNode)
    mapp["a"] = ListNode{Val: 1}
    mapp["b"] = ListNode{Val: 2}
    mapp["a"].Next = mapp["b"]
    fmt.Println(mapp["a"].Val)
}
</code></pre>

<h1>Key types</h1>

<p>先前提到 key 可以是任何可以比較的類型(<code>boolean</code>, <code>numeric</code>, <code>string</code>, <code>pointer</code>, <code>channel</code>, and <code>interface types</code>, and <code>structs</code> or <code>arrays</code>)</p>

<p>注意到這列表上不包括(<code>slices</code>, <code>maps</code>, and <code>functions</code>) 這些類型不能做比較，所以也不能當作 map 的 key</p>

<p>另外 struct key 是比較特別的，因為 struct 的 data 是多維度的面相(可以描述一個 data 的結構)</p>

<p>舉例來說下面是一個 map 包著一個 map，用於統計國家/地區的網頁造訪次數</p>

<pre><code class="go">// 外面 map 的 key 是網頁的路徑 path，裡面的 map 的 key 則是 國家的代碼
hits := make(map[string]map[string]int)
</code></pre>

<p>澳洲(Australian) 的 documentation page 點擊次數</p>

<pre><code class="go">n := hits["/doc/"]["au"]
</code></pre>

<p>但這種方法，再新增新的 data 時，會不太好處理，因為每次給外部 map key 時，就必須再檢查裡面的 map 是否存在，不存在在建立</p>

<pre><code class="go">func add(m map[string]map[string]int, path, country string) {
    // 先確認 value 在不在
    mm, ok := m[path]
    // 如果 value 不存在，就建立新的 inner map，每次都要檢查
    if !ok {
        mm = make(map[string]int)
        m[path] = mm
    }
    // 
    mm[country]++
}
add(hits, "/doc/", "au")
</code></pre>

<p>利用 struct 可以減少上面的複雜性</p>

<pre><code class="go">type Key struct {
    Path, Country string
}
hits := make(map[Key]int)
</code></pre>

<p>當越南人(Vietnamese) 造訪頁面，增加(或建立新的) 可以用一行就解決</p>

<pre><code class="go">hits[Key{"/", "vn"}]++
</code></pre>

<p>要看到瑞士(Swiss)有多少人看到 <code>/ref/spec</code> 也很簡單</p>

<pre><code class="go">n := hits[Key{"/ref/spec", "ch"}]
</code></pre>

<h1>Concurrency</h1>

<p><a href="https://golang.org/doc/faq#atomic_maps">Maps are not safe for concurrent use</a></p>

<p>並發訪問map是不安全的，會出現未定義行為</p>

<p>如果希望多併發讀取 map，必須提供某種同步機制，可以用 <a href="https://golang.org/pkg/sync/#RWMutex">sync.RWMutex</a> 讀寫鎖，確保同步機制(synchronization mechanism)</p>

<p>但是透過讀寫鎖控制 map 的並發訪問時，會導致一定的性能問題，不過能保證程序的安全運行。</p>

<pre><code class="go">package main

import (
    "fmt"
    "sync"
)

func main() {
    var counter = struct {
        sync.RWMutex
        m map[string]int
    }{m: make(map[string]int)}

    // To read from the counter, take the read lock:
    counter.RLock()
    n := counter.m["some_key"]
    counter.RUnlock()
    fmt.Println("some_key:", n)

    // To write to the counter, take the write lock:
    counter.Lock()
    counter.m["some_key"]++
    counter.Unlock()
    fmt.Println("some_key:", counter.m["some_key"])
}
</code></pre>

<ul>
<li><a href="https://colobu.com/2017/07/11/dive-into-sync-Map/">Go 1.9 sync.Map揭秘</a></li>
<li><a href="https://www.jianshu.com/p/10a998089486">go語言坑之並發訪問map</a></li>
</ul>


<h1>Iteration order</h1>

<p>用 <code>range</code> 迭代 map 時，並沒有指定每次的順序一樣，也沒有保證下一次的順序會跟上一次的順序一樣，每次都是隨機的</p>

<p>如果希望能夠每次迭代的順序都一樣的話，必須先將 key 單獨分開來做排序，在迭代排序好的 key mapping 回 map</p>

<pre><code class="go">package main

import (
    "fmt"
    "sort"
)

func main() {

    m := map[int]string{
        1: "A",
        2: "B",
        3: "C",
    }
    // 先將 key 取出來排序
    var keys []int
    for k := range m {
        keys = append(keys, k)
    }
    sort.Ints(keys)
    // 改成以下方法，就會倒過來
    // sort.Sort(sort.Reverse(sort.IntSlice(keys)))

    // 迭代排序好的 slice，並指定 map 的 key
    for _, k := range keys {
        fmt.Println("Key:", k, "Value:", m[k])
    }
}
</code></pre>

<h1>cannot assign to struct field XXX in map</h1>

<p>當 struct 作為 map 裡面的值時，不能透過 map[key].xx = &ldquo;xx&rdquo; 這種賦值，會出現 <code>cannot assign to struct field XXX in map</code> 不予許修改 map 裡的值</p>

<pre><code class="go">package main

import (
    "fmt"
)

type test struct {
    name string
}

func main() {
    a := test{"hello"}
    mapp := make(map[string]test)
    mapp["hey"] = a

    // 因為 map 的 value 是不可尋址的，因此會報錯
    // cannot assign to struct field mapp["test"].name in map
    mapp["hey"].name = "hi"

    // if v, ok := mapp["hey"]; ok {
    // 雖然這樣不會有 error，但實際上 v 是 copy 的值，因此也不會改到原本的 value，所以還是 hello
    //  v.name = "hi"
    // }

    fmt.Println(mapp["hey"].name)

}
</code></pre>

<h3>原因:</h3>

<p>map 的 value 是不可尋址的(<a href="https://golang.org/ref/spec#Address_operators">addressable</a>)，因為 map 中的值會在記憶體中行動，舊的指針地址在 map 改變時會變得無效。</p>

<p>另外 map 是會自動擴容，因此原來存值是 A 地址，擴容後 A 地址就不是原來的值了，因此如果需要改值，必須改用 <code>make(map[string]*test)</code></p>

<p>參考文件</p>

<ul>
<li><a href="https://blog.golang.org/go-maps-in-action">Go maps in action</a></li>
<li><a href="https://stackoverflow.com/questions/32751537/why-do-i-get-a-cannot-assign-error-when-setting-value-to-a-struct-as-a-value-i">Why do I get a “cannot assign” error when setting value to a struct as a value in a map? [duplicate]</a></li>
<li><a href="https://gocn.vip/question/1714">問一個問題。為啥結構體作為map的值，不能透過map[key].成員屬性 = &ldquo;Xxx&rdquo; 這種賦值</a></li>
<li><a href="https://studygolang.com/articles/12714">Golang面試題解析（四）</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Golang - Slices Usage and Internals]]></title>
    <link href="http://mgleon08.github.com/blog/2019/02/03/golang-slices-usage-and-internals/"/>
    <updated>2019-02-03T10:08:15+08:00</updated>
    <id>http://mgleon08.github.com/blog/2019/02/03/golang-slices-usage-and-internals</id>
    <content type="html"><![CDATA[<!-- more -->


<h1>Introduction</h1>

<p>golang 提供很方便 slice，去處理序列化的數據. slice 類似其他語言的 array，但具有特別的屬性</p>

<h1>Arrays</h1>

<p>slices 類型是建立在 array 類型上面，因此要了解 slice 必須先瞭解 array</p>

<p>array 必須指定 type 和 size，像是 <code>[4]int</code> 代表裡面的值必須是 <code>int</code>，並且只能放 4 個值</p>

<p>array size 是固定的，像是 <code>[4]int</code> 和 <code>[5]int</code> 就不一樣，而且是不相容的類型</p>

<pre><code class="go">var a [4]int
a[0] = 1
i := a[0]
// i == 1
</code></pre>

<p>array 不需要顯示的初始化 (initialized explicitly)</p>

<blockquote><p>是指說不需要有 assign 值，像 int 就會是 0，string 就是 “”，不像 slice 或 map 需要用 make()</p></blockquote>

<pre><code class="go">// a[2] == 0, the zero value of the int type
</code></pre>

<p><code>[4]int</code> 指的是，照順序排列的 4 個整數值</p>

<p><img src="https://blog.golang.org/go-slices-usage-and-internals_slice-array.png" alt="" /></p>

<p>Go&rsquo;s arrays are values.</p>

<p>array variable 表示整個 array，並不是指向 array 的第一個元素，這表示當 assign 值給 array 時，將會複製整個 array 的內容 (為了避免複製，可以傳遞一個指向 array 的 pointer)</p>

<pre><code class="go">package main

import (
    "fmt"
)

func assign(num [4]int) {
    fmt.Printf("assign %p\n", &amp;num)
    fmt.Printf("assign %p\n", &amp;num[0])
    fmt.Printf("assign %p\n", &amp;num[1])
}

func main() {
    var a [4]int

    fmt.Printf("main %p\n", &amp;a)
    fmt.Printf("main %p\n", &amp;a[0])
    fmt.Printf("main %p\n", &amp;a[1])
    assign(a)

}

// 可以發現當 assign 之後，address 就不一樣
// main 0x416020
// main 0x416020
// main 0x416024
// assign 0x416050
// assign 0x416050
// assign 0x416054
</code></pre>

<p>另一種思考是將 array 當成一個 struct，但是索引是 <code>index</code> 而不是 <code>name</code></p>

<pre><code class="go">b := [2]string{"Penn", "Teller"}
</code></pre>

<p>也可以用 <code>...</code> 讓編譯器，在編譯的時候幫你計算</p>

<pre><code class="go">b := [...]string{"Penn", "Teller"}
</code></pre>

<p>上面兩個範例的 <code>b</code> 都代表 <code>[2]string</code></p>

<h1>Slices</h1>

<p>上面 array size 都是固定，很不彈性，所以在 golang 當中比較少會使用到，比較常看到的反而是 <code>slices</code> 以 array 為基礎，但是更加彈性方便</p>

<pre><code class="go">// 不需要像 array 給 length
[]T
</code></pre>

<p>slice 宣告方式，跟 array 很像</p>

<pre><code class="go">letters := []string{"a", "b", "c", "d"}
</code></pre>

<p>可以透過 make 來建立 slice</p>

<pre><code class="go">func make([]T, len, cap) []T
</code></pre>

<p>用 make 建立時，要給定 <code>type</code>，<code>len</code>，<code>cap</code>，make 就會分配一個 array，並回傳 reference 到這個 array 的 slice</p>

<pre><code class="go">var s []byte
s = make([]byte, 5, 5)
// s == []byte{0, 0, 0, 0, 0}
</code></pre>

<p><code>cap</code> 可以不寫，默認為 <code>cap</code> 跟 <code>len</code> 一樣</p>

<pre><code class="go">s := make([]byte, 5)
len(s) == 5
cap(s) == 5
</code></pre>

<p>sliec 和 array 可以透過 <code>[:]</code> 來建立另一個 slice，透過前後數字，表示要切的長度</p>

<pre><code class="go">b := []byte{'g', 'o', 'l', 'a', 'n', 'g'}
// b[1:4] == []byte{'o', 'l', 'a'}, sharing the same storage as b
</code></pre>

<p>slice 前後的索引，是可選的，前面不存在代表從 0 開始，後面不存在代表該長度</p>

<pre><code class="go">// b[:2] == []byte{'g', 'o'}
// b[2:] == []byte{'l', 'a', 'n', 'g'}
// b[:] == b
</code></pre>

<p>兩個都不寫也可以，就是原本的數組</p>

<pre><code class="go">x := [3]string{"Лайка", "Белка", "Стрелка"}
s := x[:] // a slice referencing the storage of x
</code></pre>

<h1>Slice internals</h1>

<p>A slice is a descriptor of an array segment.</p>

<p>slice 的組成包含 element 的指標(pointer)、長度(len)、容量(cap)</p>

<p><img src="https://blog.golang.org/go-slices-usage-and-internals_slice-struct.png" alt="" /></p>

<p><code>make([]byte, 5)</code> 像是下面這樣，指標指向 slice 的第一個 element，並對應到 array 中 element</p>

<p><img src="https://blog.golang.org/go-slices-usage-and-internals_slice-1.png" alt="" /></p>

<p>length 是 slice 引用的元素數，capacity 則是 array 底層可以使用到的數量(是指 slice pointer 指到的位置開始數起)</p>

<pre><code class="go">s = s[2:4]
// 範圍是 2~4(不包含 4 的位置)，所以長度會是 2
</code></pre>

<p>以這張圖表示，slice pointer 指向 array[2]，並且 length = 2, capacity = 3</p>

<p><img src="https://blog.golang.org/go-slices-usage-and-internals_slice-2.png" alt="" /></p>

<p>slicing 不會 copy 原本的 slice，而是將 pointer 指向到原來的 array，這也讓 slice 可以那麼有效率的原因</p>

<p>但這也代表，不同 slice 會對應到同一個 array，因此改變 array 的值，所有有指到該 array 的值都會變</p>

<pre><code class="go">d := []byte{'r', 'o', 'a', 'd'}
e := d[2:] 
// e == []byte{'a', 'd'}
e[1] = 'm'
// e == []byte{'a', 'm'}
// d == []byte{'r', 'o', 'a', 'm'}
</code></pre>

<p>之前把 length 切的比 capacity 還要短，可以透過在 slicing 一次，把長度加長</p>

<pre><code class="go">s = s[:cap(s)]
</code></pre>

<p><img src="https://blog.golang.org/go-slices-usage-and-internals_slice-3.png" alt="" /></p>

<p>slice 不能超過其 capacity，否則會 <code>runtime panic</code>，cap 會由 slice 的起點到最後面，因此每次起點都不是 0 cap 則會一直變小</p>

<p>從 0 開始切</p>

<pre><code class="go">a := []int{1, 2, 3, 4}
b := a[:2]
fmt.Println(cap(b[:]))
fmt.Println(b)
// 4
// [1 2]
</code></pre>

<p>從 2 開始切</p>

<pre><code class="go">a := []int{1, 2, 3, 4}
b := a[2:]
fmt.Println(cap(b[:]))
fmt.Println(b)
// 2
// [3 4]
</code></pre>

<h1>Growing slices (the copy and append functions)</h1>

<p>要新增 slice 的 capacity 的方式，就是建立一個新的 slice，並將原本的內容複製過去(這種動態數組實現技術，是來自其他語言)</p>

<p>建立新的 t slice，將 s 的內容複製到 t，再將 t 分配給 s，就能使 s 對應到加倍 cap 的 t</p>

<pre><code class="go">t := make([]byte, len(s), (cap(s)+1)*2) // +1 in case cap(s) == 0
for i := range s {
        t[i] = s[i]
}
s = t
</code></pre>

<p>loop 複製的部分，可以透過內建的 <code>copy</code> 簡單完成</p>

<pre><code class="go">func copy(dst, src []T) int
</code></pre>

<p>也可以在不同長度的 slice 進行 copy</p>

<pre><code class="go">// s 複製到 t
t := make([]byte, len(s), (cap(s)+1)*2)
copy(t, s)
s = t
</code></pre>

<p>更常見的操作，是將 data append 在後面，必要時會產生新的 slice</p>

<pre><code class="go">func AppendByte(slice []byte, data ...byte) []byte {
     // 原本 slice 的長度
    m := len(slice)
    // 原本 slice 的長度 + 新的 data 的長度
    n := m + len(data)
    // 如果加總的長度，比原本的 slice 的容量還長，就建立新的 slice
    if n &gt; cap(slice) { // if necessary, reallocate
        // allocate double what's needed, for future growth.
        newSlice := make([]byte, (n+1)*2)
        copy(newSlice, slice)
        slice = newSlice
    }
    // 將 slice 切到跟加總的長度一樣
    slice = slice[0:n]
    // 將新的 data 複製到，slice 的後面
    copy(slice[m:n], data)
    return slice
}
</code></pre>

<p>像是這樣</p>

<pre><code class="go">p := []byte{2, 3, 5}
p = AppendByte(p, 7, 11, 13)
// p == []byte{2, 3, 5, 7, 11, 13}
</code></pre>

<p>像 AppendByte 的 function 非常有用，因為可以控制 slice 擴充方式</p>

<p>golang 內建就有 <code>append</code></p>

<pre><code class="go">func append(s []T, x ...T) []T
</code></pre>

<p><code>func append</code> 可以將 x 元素，append 在 data 後面，如果需要更大的容量，會自動分配新的 slice</p>

<pre><code class="go">a := make([]int, 1)
// a == []int{0}
a = append(a, 1, 2, 3)
// a == []int{0, 1, 2, 3}
</code></pre>

<p>要 append slice to slice 可以用 <code>...</code>，將參數作為列表</p>

<pre><code class="go">a := []string{"John", "Paul"}
b := []string{"George", "Ringo", "Pete"}
a = append(a, b...) // equivalent to "append(a, b[0], b[1], b[2])"
// a == []string{"John", "Paul", "George", "Ringo", "Pete"}
</code></pre>

<pre><code class="go">package main

import (
    "fmt"
)

// Filter returns a new slice holding only
// the elements of s that satisfy fn()
func Filter(s []int, fn func(int) bool) []int {
    var p []int // == nil
    for _, v := range s {
        if fn(v) {
            p = append(p, v)
        }
    }
    return p
}

func main() {
    p := []int{2, 3, 5, 11, 13, 15}
    f := func(x int) bool {
        return x &gt; 10
    }
    p = Filter(p, f)
    fmt.Println(p)
}

// [11 13 15]
</code></pre>

<h1>A possible &ldquo;gotcha&rdquo;</h1>

<p>之前提到的 re-slice，不會複製到底層的 array，因此完整的 array 會一直留存在記憶體，導致只需要一小部分數據時，卻將所有數據保存在 memory 中</p>

<p>以下為存文件載入到 memory，並回傳 slice 包含第一組的連續數字</p>

<pre><code class="go">var digitRegexp = regexp.MustCompile("[0-9]+")

func FindDigits(filename string) []byte {
    b, _ := ioutil.ReadFile(filename)
    return digitRegexp.Find(b)
}
</code></pre>

<p>此行為就會造成，雖然只要第一組的連續數字，但是 slice 卻會 references 到原本的 array(完整的文件)，導致 memory 的浪費，並且 garbage collector 無法去做釋放</p>

<p>要解決此問題，要先將需要的字串複製到新的 slice，這樣原本的 slice 就可以做釋放</p>

<pre><code class="go">func CopyDigits(filename string) []byte {
    b, _ := ioutil.ReadFile(filename)
    b = digitRegexp.Find(b)
    // 建立新的 slice，長度容量設定為需要的長度即可
    c := make([]byte, len(b))
    copy(c, b)
    return c
}
</code></pre>

<p>也可以使用 <code>append</code> 建立更簡潔的 function</p>

<pre><code class="go">func CopyDigits(filename string) []byte {
    b, _ := ioutil.ReadFile(filename)
    b = digitRegexp.Find(b)
    // 建立新的 slice，長度容量設定為需要的長度即可
    c := make([]int, 1)
    append(c, b...)
    return c
}
</code></pre>

<p>參考文件</p>

<ul>
<li><a href="https://blog.golang.org/go-slices-usage-and-internals">Go Slices: usage and internals</a></li>
<li><a href="https://halfrost.com/go_slice/">深入解析 Go 中 Slice 底層實現</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Golang - Module]]></title>
    <link href="http://mgleon08.github.com/blog/2018/12/27/golang-module/"/>
    <updated>2018-12-27T23:01:48+08:00</updated>
    <id>http://mgleon08.github.com/blog/2018/12/27/golang-module</id>
    <content type="html"><![CDATA[<!-- more -->


<p>go module 是 1.11 版本出的新功能，先介紹之前使用套件的方式</p>

<p>先下載一個套件</p>

<pre><code class="go">go get -u github.com/appleboy/com/random
// -u 如果檔案已經存在，有更新的話就會更新
// 下載後會存在 $GOPATH/src/github.com/appleboy/com/random
</code></pre>

<p>新增檔案 <code>$GOPATH/src/testgomod/main.go</code></p>

<pre><code class="go">// $GOPATH/src/testgomod/main.go
package main

import (
    "fmt"

    "github.com/appleboy/com/random"
)

func main() {
    fmt.Println(random.String(10))
}
</code></pre>

<h3>問題</h3>

<ul>
<li>套件無法分版本，因為都是 <code>$GOPATH/src/github.com/appleboy/com/random</code></li>
<li>專案必須要在 <code>$GOPATH</code> 底下才的 work</li>
</ul>


<h1>govendor</h1>

<p>以前都是用 <a href="https://github.com/kardianos/govendor">govendor</a> 套件來處理</p>

<pre><code class="go">go get -u github.com/kardianos/govendor
</code></pre>

<p>在原本的專案底下執行 <code>govendor init</code></p>

<pre><code class="go">// 會出現新的 vendor 資料夾
.
├── main.go
└── vendor
    └── vendor.json
</code></pre>

<p>在執行 <code>govendor fetch github.com/appleboy/com/random</code></p>

<pre><code class="go">// 後面可以加上版號 govendor fetch github.com/appleboy/com/random@1.0
// 會產生對應的檔案在 vendor 裡面
.
├── main.go
└── vendor
    ├── github.com
    │   └── appleboy
    │       └── com
    │           ├── LICENSE
    │           └── random
    │               └── random.go
    └── vendor.json
</code></pre>

<p>套件相關資訊都會記錄在 <code>vendor.json</code></p>

<pre><code class="go">// $GOPATH/src/testgomod/vendor/vendor.json

{
    "comment": "",
    "ignore": "test",
    "package": [
        {
            "checksumSHA1": "ZPkL/ha7+FVjS65ZmmlDGH8d12A=",
            "path": "github.com/appleboy/com/random",
            "revision": "c0b5901f9622d5256343198ed54af65af5d08cff",
            "revisionTime": "2018-04-10T03:06:38Z"
        }
    ],
    "rootPath": "testgomod"
}
</code></pre>

<h3>問題</h3>

<ul>
<li>專案必須要在 <code>$GOPATH</code> 底下才的 work</li>
</ul>


<h1>Go module</h1>

<p>golang 在版本1.11 新出的功能，初始化專案時必須加上 <code>export GO111MODULE=on</code> 原本預設是 <code>auto</code> 就是 disable</p>

<p>在專案底下執行</p>

<pre><code class="go">go mod init
// go: creating new go.mod: module testgomod
// go: copying requirements from vendor/vendor.json
</code></pre>

<p>多出一個 <code>go.mod</code></p>

<pre><code class="go">// go.mod
// 記錄使用哪個套件，版本，sha1
module testgomod

require github.com/appleboy/com v0.0.0-20180410030638-c0b5901f9622
</code></pre>

<p>接著</p>

<pre><code class="go">go mod download
// or
go run main.go
// or
go build -v -o main .
</code></pre>

<p>會產生 <code>go.sum</code></p>

<pre><code class="go">// go.sum
github.com/appleboy/com v0.0.0-20180410030638-c0b5901f9622 h1:ozHD8HTq7ivv8vTJRCAzjA4wEA8BMGekxMDZrFdqz5M=
github.com/appleboy/com v0.0.0-20180410030638-c0b5901f9622/go.mod h1:rtwjPnHClMOJw4K5oW3ASx9BCPCJ1SDbFbzJjY4Ebqw=
</code></pre>

<p>實際上會存取在 <code>$GOPATH/pkg/mod/</code></p>

<p>這時候可以嘗試將 govendor 的資料夾刪除，並改 module 成 auto</p>

<pre><code class="go">rm -rf vendor
export GO111MODULE=auto
</code></pre>

<p>跑</p>

<pre><code class="go">go run main.go
// or
go build -v -o main .
// -o output
// -v print the names of packages as they are compiled.
</code></pre>

<p>會發現建立不了，再試著將 module 改成 on 去跑</p>

<pre><code class="go">export GO111MODULE=on
</code></pre>

<pre><code class="go">go run main.go
// or
go build -v -o main .

// 就不依賴 goverdor，專案也不一定要在 $GOPATH 底下
</code></pre>

<h3>好處</h3>

<ul>
<li>不需在 $GOPATH 底下才能建立專案</li>
<li>可以切換不同版本</li>
</ul>


<h3>指令</h3>

<pre><code class="go">go download    download modules to local cache
go edit        edit go.mod from tools or scripts
go graph       print module requirement graph
go init        initialize new module in current directory
go tidy        add missing and remove unused modules
go vendor      make vendored copy of dependencies
go verify      verify dependencies have expected content
go why         explain why packages or modules are needed
</code></pre>

<p>參考文件</p>

<ul>
<li><a href="https://blog.wu-boy.com/2018/10/go-1-11-support-go-module/">Go 語言 1.11 版本推出 go module</a></li>
<li><a href="https://colobu.com/2018/08/27/learn-go-module/">跳出Go module的泥潭</a></li>
<li><a href="https://roberto.selbach.ca/intro-to-go-modules/">Introduction to Go Modules</a></li>
<li><a href="https://github.com/kardianos/govendor">govendor</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Golang - Writing Files]]></title>
    <link href="http://mgleon08.github.com/blog/2018/12/18/golang-write-files/"/>
    <updated>2018-12-18T15:16:53+08:00</updated>
    <id>http://mgleon08.github.com/blog/2018/12/18/golang-write-files</id>
    <content type="html"><![CDATA[<!-- more -->


<ul>
<li><a href="#string">Writing string to a file</a></li>
<li><a href="#bytes">Writing bytes to a file</a></li>
<li><a href="#line">Writing strings line by line to a file</a></li>
<li><a href="#appending">Appending to a file</a></li>
<li><a href="#concurrently">Writing to file concurrently</a></li>
</ul>


<h1><span id="string"> Writing string to a file </span></h1>

<ul>
<li><p><a href="https://golang.org/pkg/os/#File">os.File</a></p></li>
<li><p>Create the file</p></li>
<li>Write the string to the file</li>
</ul>


<pre><code class="go">package main

import (
    "fmt"
    "os"
)

func main() {
    // 建立新的 txt 檔案
    f, err := os.Create("test.txt")
    if err != nil {
        fmt.Println(err)
        return
    }
    // 將 String 寫入檔案內
    l, err := f.WriteString("Hello World")
    if err != nil {
        fmt.Println(err)
        // 關閉檔案
        f.Close()
        return
    }
    fmt.Println(l, "bytes written successfully")
    // 關閉檔案
    err = f.Close()
    if err != nil {
        fmt.Println(err)
        return
    }
}
// 11 bytes written successfully
</code></pre>

<h1><span id="bytes"> Writing bytes to a file </span></h1>

<p><a href="https://golang.org/pkg/os/#File.Write">File.Write</a></p>

<pre><code class="go">package main

import (
    "fmt"
    "os"
)

func main() {
    f, err := os.Create("$GOPATH/src/write/bytes")
    if err != nil {
        fmt.Println(err)
        return
    }
    // slice of bytes
    d2 := []byte{104, 101, 108, 108, 111, 32, 119, 111, 114, 108, 100}
    n2, err := f.Write(d2)
    if err != nil {
        fmt.Println(err)
        f.Close()
        return
    }
    fmt.Println(n2, "bytes written successfully")
    err = f.Close()
    if err != nil {
        fmt.Println(err)
        return
    }
}
// 11 bytes written successfully
</code></pre>

<h1><span id="line"> Writing strings line by line to a file </span></h1>

<ul>
<li><a href="https://golang.org/pkg/fmt/#Fprintln">Fprintln</a></li>
</ul>


<pre><code class="go">package main

import (
    "fmt"
    "os"
)

func main() {
    f, err := os.Create("lines")
    if err != nil {
        fmt.Println(err)
        f.Close()
        return
    }
    d := []string{"Welcome to the world of Go1.", "Go is a compiled language.", "It is easy to learn Go."}

    for _, v := range d {
        // Fprintln formats using the default formats for its operands and writes to w. Spaces are always added between operands and a newline is appended
        fmt.Fprintln(f, v)
        if err != nil {
            fmt.Println(err)
            return
        }
    }
    err = f.Close()
    if err != nil {
        fmt.Println(err)
        return
    }
    fmt.Println("file written successfully")
}

// file written successfully
</code></pre>

<h1><span id="appending"> Appending to a file </span></h1>

<ul>
<li><a href="https://golang.org/pkg/os/#OpenFile">OpenFile</a></li>
</ul>


<pre><code class="go">package main

import (
    "fmt"
    "os"
)

func main() {
    // open the file in append and write only mode
    // 0644 權限 -rw-r--r--
    f, err := os.OpenFile("lines", os.O_APPEND|os.O_WRONLY, 0644)
    if err != nil {
        fmt.Println(err)
        return
    }
    newLine := "File handling is easy."
    // Fprintln formats using the default formats for its operands and writes to w. Spaces are always added between operands and a newline is appended
    _, err = fmt.Fprintln(f, newLine)
    if err != nil {
        fmt.Println(err)
        f.Close()
        return
    }
    err = f.Close()
    if err != nil {
        fmt.Println(err)
        return
    }
    fmt.Println("file appended successfully")
}

// file appended successfully
</code></pre>

<h1><span id="concurrently"> Writing to file concurrently </span></h1>

<p>當同時 goroutines 寫進同一個 file 時，會發生 race condition，因此必須避免</p>

<h3>步驟</h3>

<ol>
<li>建立一個 channel 來傳遞要填寫的內容</li>
<li>一次建立 100 個 producer goroutines，並且同時寫一個亂數到 channel</li>
<li>建立一個 consumer goroutine 用來讀取 channel 裡面的 value，因為只有一個所以可以避免造成 race condition</li>
<li>關閉檔案</li>
</ol>


<pre><code class="go">package main

import (
    "fmt"
    _ "math/rand"
    "os"
    "sync"
)

// 用來產生亂數，並傳遞給 channel
func produce(data chan int, wg *sync.WaitGroup, number int) {
    // n := rand.Intn(999)
    // data &lt;- n
    // 改用 1 - 99 比較看的出，goroutine 每次完成的順序都不一樣
    data &lt;- number
    // 執行完一次就 -1
    wg.Done()
}

func consume(data chan int, done chan bool) {
    // 建立檔案 concurrent
    f, err := os.Create("concurrent")
    if err != nil {
        fmt.Println(err)
        return
    }
    // 讀取 data channel 裡面的
    for d := range data {
        _, err = fmt.Fprintln(f, d)
        if err != nil {
            fmt.Println(err)
            f.Close()
            done &lt;- false
            return
        }
    }
    // close file
    err = f.Close()
    if err != nil {
        fmt.Println(err)
        done &lt;- false
        return
    }
    // 到這邊就是完成，傳 true 進去
    done &lt;- true
}

func main() {
    data := make(chan int)
    done := make(chan bool)
    wg := sync.WaitGroup{}
    for i := 0; i &lt; 100; i++ {
        // 每次都加一
        wg.Add(1)
        // 建立 100 goroutine
        go produce(data, &amp;wg, i)
    }
    go consume(data, done)

    // 等待 100 個 goroutine 完成
    go func() {
        // 會 wait 到 0 才會繼續下一步
        wg.Wait()
        // 將 channel 關閉，用 range 取出 channel 的值必須關閉
        close(data)
    }()
    // 等到 done 有東西，才會繼續
    d := &lt;-done
    if d == true {
        fmt.Println("File written successfully")
    } else {
        fmt.Println("File writing failed")
    }
}
// File written successfully
</code></pre>

<p>參考文件:</p>

<ul>
<li><a href="https://golangbot.com/write-files/">golangbot - Writing Files</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Golang - Reading Files]]></title>
    <link href="http://mgleon08.github.com/blog/2018/11/06/golang-reading-files/"/>
    <updated>2018-11-06T15:16:53+08:00</updated>
    <id>http://mgleon08.github.com/blog/2018/11/06/golang-reading-files</id>
    <content type="html"><![CDATA[<!-- more -->


<ul>
<li><a href="#entire">Reading an entire file into memory </a></li>
<li><a href="#chunk">Reading a file in small chunks</a></li>
<li><a href="#line">Reading a file line by line</a></li>
</ul>


<h1><span id="entire"> Reading an entire file into memory </span></h1>

<p>Use <a href="https://golang.org/pkg/io/ioutil/">ioutil</a> package</p>

<ul>
<li><a href="https://golang.org/pkg/io/ioutil/#ReadFile">ReadFile</a></li>
</ul>


<pre><code class="go">// 先建立檔案

filehandling
├── filehandling.go
└── test.txt
</code></pre>

<pre><code class="go">// filehandling.go
package main

import (
    "fmt"
    "io/ioutil"
)

func main() {
    data, err := ioutil.ReadFile("test.txt")
    if err != nil {
        // 當找不到 test file 時，會顯示此訊息
        fmt.Println("File reading error", err)
        return
    }
    // return data 是 slice 透過 string 轉
    // 或是改用 fmt.Printf("Contents of file: %s", data)
    fmt.Println("Contents of file:", string(data))
}
</code></pre>

<p>當你用 <code>go install</code> or <code>go build</code> 出 binary 的 file，但 file 移到不同位置就會找不到檔案，有幾種方式可以解決</p>

<h3>1. 用絕對路徑</h3>

<pre><code class="go">package main

import (
    "fmt"
    "io/ioutil"
)

func main() {
    // $GOPATH 要換成自己電腦的路徑
    data, err := ioutil.ReadFile("$GOPATH/src/filehandling/test.txt")
    if err != nil {
        fmt.Println("File reading error", err)
        return
    }
    fmt.Println("Contents of file:", string(data))
}
</code></pre>

<h3>2. 把路徑當參數，在執行檔案時傳入</h3>

<p>必須用到 <a href="https://golang.org/pkg/flag/">flag</a> package</p>

<pre><code class="go">// flag.go
package main

import (
    "flag"
    "fmt"
)

func main() {
    // 第一個參數 flag name, 第二個 default value, 第三個 flag description
    fptr := flag.String("fpath", "test.txt", "file path to read from")
    // 必須先執行，parse flag
    flag.Parse()
    fmt.Println("value of fpath is", *fptr)
}
</code></pre>

<pre><code class="go">go run flag.go -fpath=/path-of-file/test.txt
</code></pre>

<p>將之前的 <code>test.txt</code> 加上 <code>flag</code> 後</p>

<pre><code class="go">package main

import (
    "flag"
    "fmt"
    "io/ioutil"
)

func main() {
    fptr := flag.String("fpath", "test.txt", "file path to read from")
    flag.Parse()
    data, err := ioutil.ReadFile(*fptr)
    if err != nil {
        fmt.Println("File reading error", err)
        return
    }
    fmt.Println("Contents of file:", string(data))
}
</code></pre>

<pre><code class="go">go run flag.go -fpath=$GOPATH/src/filehandling/test.txt
</code></pre>

<p>執行 binary 的檔案時就可以加上 -fpath</p>

<pre><code class="go">filehandling -fpath=$GOPATH/src/filehandling/test.txt
</code></pre>

<h3>3. 在編譯的時候把檔案一起編譯進去</h3>

<p>可以透過 <a href="https://github.com/gobuffalo/packr">packr</a> package 來實現</p>

<pre><code class="go">package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../filehandling")
    data, err := box.FindString("test.txt")
    if err != nil {
        fmt.Println(err)
    } else {
        fmt.Println("Contents of file:", data)
    }
}
</code></pre>

<pre><code class="go">// 用 go 安裝，編譯成絕對路徑，因此任何地方都可以執行 filehandling
// 但是只要將 test.txt 刪除或改名，就會找不到
go install -v

// 用 packr 安裝，則是連 file 也編譯進去，因此即使把檔案刪除也可以執行
packr install -v filehandling

/*
building box ../filehandling
packing file filehandling.go
packed file filehandling.go
packing file test.txt
packed file test.txt
built box ../filehandling with ["filehandling.go" "test.txt"]
filehandling
*/
</code></pre>

<h1><span id="chunk"> Reading a file in small chunks </span></h1>

<p>前面都是透過 memory 來一次讀取 file，但檔案太大，或是 memory 不夠的時候，就會導致錯誤，因此可以透過另一種方式來執行 <a href="https://golang.org/pkg/bufio/">bufio</a> 將檔案內容做分割</p>

<pre><code class="go">package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
  // 先透過 flag 讀取參數
    fptr := flag.String("fpath", "test.txt", "file path to read from")
  // 解析參數
    flag.Parse()

  // 打開檔案
    f, err := os.Open(*fptr)
    if err != nil {
        log.Fatal(err)
    }
  // function 結束前關閉 file
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
  // returns a new Reader whose buffer has the default size.
    r := bufio.NewReader(f)
  // 建立 byte slice，容量 3，用來一次讀取 3 個
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
</code></pre>

<pre><code class="go">go run filehandling.go -fpath=$GOPATH/src/filehandling/test.txt
</code></pre>

<h1><span id="line"> Reading a file line by line </span></h1>

<p>上面是一次要讀取多少個字元，這次改用一行一行去做讀取，一樣用 <a href="https://golang.org/pkg/bufio/">bufio</a></p>

<ol>
<li>Open the file</li>
<li>Create a new scanner from the file</li>
<li>Scan the file and read it line by line.</li>
</ol>


<pre><code class="go">package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    // 先透過 flag 讀取參數
    fptr := flag.String("fpath", "test.txt", "file path to read from")
    // 解析參數
    flag.Parse()

    // 打開檔案
    f, err := os.Open(*fptr)
    if err != nil {
        log.Fatal(err)
    }
    // function 結束前關閉 file
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    // 透過 Scanner 將一行一行印出
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
</code></pre>

<pre><code class="go">go run filehandling.go -fpath=$GOPATH/src/filehandling/test.txt
</code></pre>

<p>參考文件:</p>

<ul>
<li><a href="https://golangbot.com/read-files/">golangbot - Reading Files</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
